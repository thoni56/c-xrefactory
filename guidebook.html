<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.26">
<meta name="author" content="v{VERSION} - Generated 2026-01-06">
<title>C-xrefactory - a C/Yacc refactoring and code browsing tool - Design Documentation</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.square{list-style-type:square}
ul.circle ul:not([class]),ul.disc ul:not([class]),ul.square ul:not([class]){list-style:inherit}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child{border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:first-child,.sidebarblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child,.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock pre>code{display:block}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active,#footnotes .footnote a:first-of-type:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,td.hdlist1,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/github.min.css">
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>C-xrefactory - a C/Yacc refactoring and code browsing tool - Design Documentation</h1>
<div class="details">
<span id="author" class="author">v{VERSION} - Generated 2026-01-06</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_intro">1. Intro</a>
<ul class="sectlevel2">
<li><a href="#_caution">1.1. Caution</a></li>
<li><a href="#_background">1.2. Background</a></li>
<li><a href="#_goal">1.3. Goal</a></li>
</ul>
</li>
<li><a href="#_context">2. Context</a></li>
<li><a href="#_functional_overview">3. Functional Overview</a>
<ul class="sectlevel2">
<li><a href="#_options_option_files_and_configuration">3.1. Options, option files and configuration</a></li>
<li><a href="#_lsp">3.2. LSP</a></li>
</ul>
</li>
<li><a href="#_quality_attributes">4. Quality Attributes</a></li>
<li><a href="#_constraints">5. Constraints</a></li>
<li><a href="#_principles">6. Principles</a>
<ul class="sectlevel2">
<li><a href="#_reference_database_and_parsing">6.1. Reference Database and Parsing</a></li>
<li><a href="#_tbd">6.2. TBD.</a></li>
</ul>
</li>
<li><a href="#_software_architecture">7. Software Architecture</a>
<ul class="sectlevel2">
<li><a href="#_container_view">7.1. Container View</a></li>
<li><a href="#_containers">7.2. Containers</a></li>
</ul>
</li>
<li><a href="#_code">8. Code</a>
<ul class="sectlevel2">
<li><a href="#_commands">8.1. Commands</a></li>
<li><a href="#_passes">8.2. Passes</a></li>
<li><a href="#_parsers">8.3. Parsers</a></li>
<li><a href="#_integrated_preprocessor">8.4. Integrated Preprocessor</a></li>
<li><a href="#_refactoring_and_the_parsers">8.5. Refactoring and the parsers</a></li>
<li><a href="#_reading_files">8.6. Reading Files</a></li>
<li><a href="#_reference_database">8.7. Reference Database</a></li>
<li><a href="#_editor_plugin">8.8. Editor Plugin</a></li>
<li><a href="#_editor_server">8.9. Editor Server</a></li>
<li><a href="#_refactoring">8.10. Refactoring</a></li>
<li><a href="#_memory_handling">8.11. Memory handling</a></li>
<li><a href="#_configuration">8.12. Configuration</a></li>
</ul>
</li>
<li><a href="#_modules">9. Modules</a>
<ul class="sectlevel2">
<li><a href="#_yylex">9.1. Yylex</a></li>
<li><a href="#_parser">9.2. Parser</a></li>
<li><a href="#_xref">9.3. Xref</a></li>
<li><a href="#_server">9.4. Server</a></li>
<li><a href="#_refactory">9.5. Refactory</a></li>
<li><a href="#_cxref">9.6. Cxref</a></li>
<li><a href="#_main">9.7. Main</a></li>
<li><a href="#_memory">9.8. Memory</a></li>
<li><a href="#_cxfile_2">9.9. Cxfile</a></li>
<li><a href="#_c_xref_el">9.10. c-xref.el</a></li>
<li><a href="#_c_xrefactory_el">9.11. c-xrefactory.el</a></li>
</ul>
</li>
<li><a href="#_data_structures">10. Data Structures</a>
<ul class="sectlevel2">
<li><a href="#_referenceableitem_and_reference_core_domain_concepts">10.1. ReferenceableItem and Reference: Core Domain Concepts</a></li>
<li><a href="#_symbol_parser_symbol_table">10.2. Symbol (Parser Symbol Table)</a></li>
<li><a href="#_files_and_buffers">10.3. Files and Buffers</a></li>
<li><a href="#_modes">10.4. Modes</a></li>
<li><a href="#_options_2">10.5. Options</a></li>
<li><a href="#_arena_allocators_memory">10.6. Arena Allocators (Memory)</a></li>
<li><a href="#_preload_mechanism">10.7. Preload Mechanism</a></li>
<li><a href="#_browser_stack">10.8. Browser Stack</a></li>
<li><a href="#_browser_menu">10.9. Browser Menu</a></li>
<li><a href="#_putting_it_all_together_domain_model_summary">10.10. Putting It All Together: Domain Model Summary</a></li>
</ul>
</li>
<li><a href="#_algorithms">11. Algorithms</a>
<ul class="sectlevel2">
<li><a href="#_how_is_an_extract_refactoring_performed">11.1. How is an Extract refactoring performed?</a></li>
<li><a href="#_how_does_lexem_stream_management_work">11.2. How does lexem stream management work?</a></li>
<li><a href="#_editor_buffers_and_incremental_updates">11.3. Editor Buffers and Incremental Updates</a></li>
<li><a href="#_how_does">11.4. How does &#8230;&#8203;</a></li>
</ul>
</li>
<li><a href="#_development_environment">12. Development Environment</a>
<ul class="sectlevel2">
<li><a href="#_developing_here_be_dragons">12.1. Developing, here be dragons&#8230;&#8203;</a></li>
<li><a href="#_setup">12.2. Setup</a></li>
<li><a href="#_building">12.3. Building</a></li>
<li><a href="#_versions">12.4. Versions</a></li>
<li><a href="#_coding">12.5. Coding</a></li>
<li><a href="#_debugging">12.6. Debugging</a></li>
<li><a href="#_testing">12.7. Testing</a></li>
<li><a href="#_utilities">12.8. Utilities</a></li>
<li><a href="#_debugging_the_protocol">12.9. Debugging the protocol</a></li>
</ul>
</li>
<li><a href="#_deployment">13. Deployment</a></li>
<li><a href="#_decision_log">14. Decision Log</a>
<ul class="sectlevel2">
<li><a href="#_overview">14.1. Overview</a></li>
<li><a href="#_viewing_decision_records">14.2. Viewing Decision Records</a></li>
<li><a href="#_decision_categories">14.3. Decision Categories</a></li>
<li><a href="#_creating_new_adrs">14.4. Creating New ADRs</a></li>
</ul>
</li>
<li><a href="#_roadmap">15. Roadmap</a>
<ul class="sectlevel2">
<li><a href="#_guiding_principles">15.1. Guiding Principles</a></li>
<li><a href="#_recent_accomplishments_2025_q1">15.2. Recent Accomplishments (2025 Q1)</a></li>
<li><a href="#_short_term_goals">15.3. Short-term Goals</a></li>
<li><a href="#_medium_term_goals_6_12_months">15.4. Medium-term Goals (6-12 Months)</a></li>
<li><a href="#_long_term_vision">15.5. Long-term Vision</a></li>
<li><a href="#_migration_and_compatibility_strategy">15.6. Migration and Compatibility Strategy</a></li>
<li><a href="#_success_metrics">15.7. Success Metrics</a></li>
<li><a href="#_risk_management">15.8. Risk Management</a></li>
<li><a href="#_next_actions">15.9. Next Actions</a></li>
<li><a href="#_conclusion">15.10. Conclusion</a></li>
<li><a href="#_related_architecture_decision_records">15.11. Related Architecture Decision Records</a></li>
</ul>
</li>
<li><a href="#_major_codebase_improvements">16. Major Codebase Improvements</a>
<ul class="sectlevel2">
<li><a href="#_lexemstream_api_improvements">16.1. LexemStream API Improvements</a></li>
<li><a href="#clean-persistence-store">16.2. Clean Persistence Store Abstraction</a></li>
<li><a href="#unified-symbol-database">16.3. Unified Symbol Database Architecture</a></li>
<li><a href="#macro-expansion-module">16.4. Extract Macro Expansion Module</a></li>
<li><a href="#move-function-refactoring">16.5. Move Function Between Files</a></li>
<li><a href="#clean-parser-api">16.6. Clean Parser API and Multi-File Definition Support</a></li>
</ul>
</li>
<li><a href="#_planned_or_ongoing_features">17. Planned or Ongoing Features</a>
<ul class="sectlevel2">
<li><a href="#_move_function_between_files">17.1. Move Function Between Files</a></li>
</ul>
</li>
<li><a href="#_insights">18. Insights</a>
<ul class="sectlevel2">
<li><a href="#_yacc_semantic_data">18.1. Yacc semantic data</a></li>
<li><a href="#_navigation_architecture_and_the_preloading_limitation">18.2. Navigation Architecture and the Preloading Limitation</a></li>
</ul>
</li>
<li><a href="#_refactoring_recipes">19. Refactoring Recipes</a>
<ul class="sectlevel2">
<li><a href="#_existing_refactorings">19.1. Existing Refactorings</a></li>
<li><a href="#_suggested_refactorings">19.2. Suggested Refactorings</a></li>
<li><a href="#_introduce_semantic_type_aliases">19.3. Introduce Semantic Type Aliases</a></li>
</ul>
</li>
<li><a href="#_archive">20. Archive</a>
<ul class="sectlevel2">
<li><a href="#_memory_strategies">20.1. Memory strategies</a></li>
<li><a href="#_trivial_prechecks">20.2. Trivial Prechecks</a></li>
<li><a href="#_caching_system">20.3. Caching System</a></li>
<li><a href="#_huge_memory">20.4. HUGE Memory</a></li>
<li><a href="#_bootstrapping">20.5. Bootstrapping</a></li>
<li><a href="#_fill_macros">20.6. FILL macros</a></li>
<li><a href="#_users">20.7. Users</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
This document is very much a work in progress.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_intro">1. Intro</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>c-xrefactory</code> is a software tool and a project aiming at restoring the sources of that
old, but very useful, tool to a state where it can be enhanced and be the foundation for
a highly capable refactoring browser.</p>
</div>
<div class="paragraph">
<p>It <em>is</em> currently in excellent working condition, so you can use it in your daily
work. I do. For information about how to do that, see the
<a href="https://github.com/thoni56/c-xrefactory/blob/main/README.md">README.md</a>.</p>
</div>
<div class="sect2">
<h3 id="_caution">1.1. Caution</h3>
<div class="paragraph">
<p>As indicated by the
<a href="https://github.com/thoni56/c-xrefactory/blob/main/README.md">README.md</a>, this is a long
term restoration project. So anything you find in this document might be old, incorrect,
guesses, temporary holders for thoughts or theories. Or actually true and useful.</p>
</div>
<div class="paragraph">
<p>Especially names of variables, functions and modules is prone to change as understanding
of them increases. They might also be refactored into something entirently different.</p>
</div>
<div class="paragraph">
<p>This document has progressed from non-existing, to a collection of unstructured
thougths, guesses, historic anecdotes, ideas and a collection of unstructured,
pre-existing, wiki pages, and is now quite useful.  Perhaps it will continue to be
improved and "refactored" into something valuable for anyone who venture into this
project.</p>
</div>
<div class="paragraph">
<p>The last part of this document is an Archive where completely obsolete descriptions have
been moved for future software archeologists to find.</p>
</div>
</div>
<div class="sect2">
<h3 id="_background">1.2. Background</h3>
<div class="paragraph">
<p>You will find some background about the project in the
<a href="https://github.com/thoni56/c-xrefactory/blob/main/README.md">README.md</a>.</p>
</div>
<div class="paragraph">
<p>This document tries to collect the knowledge and understanding about how <code>c-xrefactory</code>
actually works, plans for making it better, both in terms of working with the source,
its structure and its features.</p>
</div>
<div class="paragraph">
<p>Hopefully over time this will be the design documentation of <code>c-xrefactory</code>, which, at
that time, will be a fairly well structured and useful piece of software.</p>
</div>
</div>
<div class="sect2">
<h3 id="_goal">1.3. Goal</h3>
<div class="paragraph">
<p>Ultimately <code>c-xrefactory</code> could become <em>the</em> refactoring browser for C, the one that
everybody uses. As suggested by @tajmone in GitHub issue #39, by switching to a general
protocol, we could possibly plug this in to many editors.</p>
</div>
<div class="paragraph">
<p>However, to do that we need to refactor out the protocol parts. And to do that we need a
better structure, and to dare to change that, we need to understand more of the
intricacies of this beast, and we need tests. So the normal legacy code catch 22
applies&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>Test coverage is starting to look good, coming up to slightly above 80% at the time of
writing this. Many "tests" are just "application level" execution, rather than actual
tests, but also this is improving.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_context">2. Context</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>c-xrefactory</code> is designed to be an aid for programmers as they write,
edit, inspect, read and improve the code they are working on.</p>
</div>
<div class="paragraph">
<p>The editor is used for usual manual manipulation of the source
code. <code>C-xrefactory</code> interacts with the editor to provide navigation
and automated edits, refactorings, through the editor.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Failed to generate image: Could not load PlantUML. Either require 'asciidoctor-diagram-plantuml' or specify the location of the PlantUML JAR(s) using the 'DIAGRAM_PLANTUML_CLASSPATH' environment variable. Alternatively a PlantUML binary can be provided (plantuml-native in $PATH).
@startuml
title &lt;size:24&gt;System Context View: C-xrefactory&lt;/size&gt;

set separator none
left to right direction
skinparam ranksep 60
skinparam nodesep 30
hide stereotype

&lt;style&gt;
  root {
    BackgroundColor: #ffffff;
    FontColor: #444444;
  }
  // Element,DB
  .Element-RWxlbWVudCxEQg== {
    BackgroundColor: #ffffff;
    LineColor: #444444;
    LineStyle: 0;
    LineThickness: 2;
    FontColor: #444444;
    FontSize: 24;
    HorizontalAlignment: center;
    Shadowing: 0;
    MaximumWidth: 450;
  }
  // Element,Person,Ext
  .Element-RWxlbWVudCxQZXJzb24sRXh0 {
    BackgroundColor: #686868;
    LineColor: #484848;
    LineStyle: 0;
    LineThickness: 2;
    FontColor: #ffffff;
    FontSize: 24;
    HorizontalAlignment: center;
    Shadowing: 0;
    MaximumWidth: 450;
  }
  // Element,Software System
  .Element-RWxlbWVudCxTb2Z0d2FyZSBTeXN0ZW0= {
    BackgroundColor: #1168bd;
    LineColor: #0b4884;
    LineStyle: 0;
    LineThickness: 2;
    RoundCorner: 20;
    FontColor: #ffffff;
    FontSize: 24;
    HorizontalAlignment: center;
    Shadowing: 0;
    MaximumWidth: 450;
  }
  // Element,Software System,Editor,Ext
  .Element-RWxlbWVudCxTb2Z0d2FyZSBTeXN0ZW0sRWRpdG9yLEV4dA== {
    BackgroundColor: #686868;
    LineColor: #484848;
    LineStyle: 0;
    LineThickness: 2;
    RoundCorner: 20;
    FontColor: #ffffff;
    FontSize: 24;
    HorizontalAlignment: center;
    Shadowing: 0;
    MaximumWidth: 450;
  }
  // Relationship
  .Relationship-UmVsYXRpb25zaGlw {
    LineThickness: 2;
    LineStyle: 10-10;
    LineColor: #444444;
    FontColor: #444444;
    FontSize: 24;
  }
&lt;/style&gt;

person "==Developer\n&lt;size:16&gt;[Person]&lt;/size&gt;\n\nEdits source code using an editor" &lt;&lt;Element-RWxlbWVudCxQZXJzb24sRXh0&gt;&gt; as Developer
rectangle "==Editor\n&lt;size:16&gt;[Software System]&lt;/size&gt;\n\nAllows Developer to modify source code and perform refactoring operations" &lt;&lt;Element-RWxlbWVudCxTb2Z0d2FyZSBTeXN0ZW0sRWRpdG9yLEV4dA==&gt;&gt; as Editor
database "==Source Code\n&lt;size:16&gt;[a set of files stored on disk]&lt;/size&gt;" &lt;&lt;Element-RWxlbWVudCxEQg==&gt;&gt; as 3
rectangle "==C-xrefactory\n&lt;size:16&gt;[Software System]&lt;/size&gt;\n\nAnalyses source code, receives and processes requests for navigation and refactoring" &lt;&lt;Element-RWxlbWVudCxTb2Z0d2FyZSBTeXN0ZW0=&gt;&gt; as Cxrefactory

Editor --&gt; Cxrefactory &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "extends functionality using\n&lt;size:16&gt;[plugin]&lt;/size&gt;"
Cxrefactory --&gt; 3 &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "reads source code from\n&lt;size:16&gt;[file I/O]&lt;/size&gt;"
Developer --&gt; Editor &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "usual editor/IDE operations"
Developer --&gt; Cxrefactory &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "configuration and command line invocations"
Editor --&gt; 3 &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "normal editing operations"
Editor --&gt; Cxrefactory &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "navigation and refactoring requests"
Cxrefactory --&gt; Editor &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "positioning and editing responses"
Cxrefactory --&gt; 3 &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "read/analyze"

@enduml</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_functional_overview">3. Functional Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <em>c-xref</em> program is actually a mish-mash of a multitude of
features baked into one program. This is the major cause of the mess
that it is source-wise.</p>
</div>
<div class="paragraph">
<p>It was</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a generator for persistent cross-reference data</p>
</li>
<li>
<p>a reference server for editors, serving cross-reference, navigational and completion data over a protocol</p>
</li>
<li>
<p>a refactoring server (the worlds first to cross the Refactoring Rubicon)</p>
</li>
<li>
<p><span class="line-through">an HTML cross-reference generator (probably the root of the project)</span> (REMOVED)</p>
</li>
<li>
<p><span class="line-through">a C macro generator for structure fill (and other) functions</span> (REMOVED)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It is the first three that are unique and constitutes the great value
of this project. The last two have been removed from the source, the
last one because it was a hack and prevented modern, tidy, building,
coding and refactoring. The HTML cross-reference generator has been
superseeded by modern alternatives like Doxygen and is not at the core
of the goal of this project.</p>
</div>
<div class="paragraph">
<p>One might surmise that it was the HTML-crossreference generator that
was the initial purpose of what the original <code>Xrefactory</code> was based
upon. Once that was in place the other followed, and were basically
only bolted on top without much re-architecting the C sources.</p>
</div>
<div class="paragraph">
<p>What we&#8217;d like to do is partition the project into separate parts,
each having a clear usage.</p>
</div>
<div class="paragraph">
<p>The following sections are aimed at describing various features of
<code>c-xrefactory</code>.</p>
</div>
<div class="sect2">
<h3 id="_options_option_files_and_configuration">3.1. Options, option files and configuration</h3>
<div class="paragraph">
<p>The current version of C-xrefactory allows only two possible sets of
configuration/options.</p>
</div>
<div class="paragraph">
<p>The primary storage is (currently) the file <code>$HOME/.c-xrefrc</code>
which stores the "standard" options for all projects. Each project has
a separate section which is started with a section marker, the project
name surrounded by square brackets, <code>[project1]</code>.</p>
</div>
<div class="paragraph">
<p>When you start <code>c-xref</code> you can use the command line option <code>-xrefrc</code>
to request that a particular option file should be used instead of the
"standard options".</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When running the edit server there seems to be no way to
indicate a different options files for different
projects/files. Although you can start the server with <code>-xrefrc</code> you
will be stuck with that in the whole session and for all projects.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_lsp">3.2. LSP</h3>
<div class="paragraph">
<p>The LSP protocol is a common protocol for language servers such as
<code>clangd</code> and <code>c-xrefactory</code>. It allows an editor (client) to interface
to a server to request information, such as reference positions, and
operations, such as refactorings, without knowing exactly which server
it talks to.</p>
</div>
<div class="paragraph">
<p>Recent versions of <code>c-xrefactory</code> have an initial implementation of a
very small portion of the LSP protocol. The plan is to fully integrate
the functionality of <code>c-xrefactory</code> into the LSP protocol. This will
allow use of <code>c-xrefactory</code> from not only Emacs but also Visual Studio
Code or any other editor that supports the LSP protocol.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_quality_attributes">4. Quality Attributes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The most important quality attributes are</p>
</div>
<div class="ulist">
<ul>
<li>
<p>correctness - a refactoring should never alter the behaviour of the refactored code</p>
</li>
<li>
<p>completness - no reference to a symbol should ever be missed</p>
</li>
<li>
<p>performance - a refactoring should be sufficiently quick so the user keeps focus on the task at hand</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_constraints">5. Constraints</h2>
<div class="sectionbody">
<div class="paragraph">
<p>TBD.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_principles">6. Principles</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_reference_database_and_parsing">6.1. Reference Database and Parsing</h3>
<div class="paragraph">
<p>The reference database is used only to hold externally visible
identifiers to ensure that references to an identifier can be found
across all files in the used source.</p>
</div>
<div class="paragraph">
<p>All symbols that are only visible inside a unit is handled by
reparsing the file of interest.</p>
</div>
</div>
<div class="sect2">
<h3 id="_tbd">6.2. TBD.</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="_software_architecture">7. Software Architecture</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_container_view">7.1. Container View</h3>
<div class="listingblock">
<div class="content">
<pre>Failed to generate image: Could not load PlantUML. Either require 'asciidoctor-diagram-plantuml' or specify the location of the PlantUML JAR(s) using the 'DIAGRAM_PLANTUML_CLASSPATH' environment variable. Alternatively a PlantUML binary can be provided (plantuml-native in $PATH).
@startuml
title &lt;size:24&gt;Container View: C-xrefactory&lt;/size&gt;

set separator none
left to right direction
skinparam ranksep 60
skinparam nodesep 30
hide stereotype

&lt;style&gt;
  root {
    BackgroundColor: #ffffff;
    FontColor: #444444;
  }
  // Element,Container
  .Element-RWxlbWVudCxDb250YWluZXI= {
    BackgroundColor: #438dd5;
    LineColor: #2e6295;
    LineStyle: 0;
    LineThickness: 2;
    RoundCorner: 20;
    FontColor: #ffffff;
    FontSize: 24;
    HorizontalAlignment: center;
    Shadowing: 0;
    MaximumWidth: 450;
  }
  // Element,Container,DB
  .Element-RWxlbWVudCxDb250YWluZXIsREI= {
    BackgroundColor: #438dd5;
    LineColor: #2e6295;
    LineStyle: 0;
    LineThickness: 2;
    FontColor: #ffffff;
    FontSize: 24;
    HorizontalAlignment: center;
    Shadowing: 0;
    MaximumWidth: 450;
  }
  // Element,DB
  .Element-RWxlbWVudCxEQg== {
    BackgroundColor: #ffffff;
    LineColor: #444444;
    LineStyle: 0;
    LineThickness: 2;
    FontColor: #444444;
    FontSize: 24;
    HorizontalAlignment: center;
    Shadowing: 0;
    MaximumWidth: 450;
  }
  // Element,Person,Ext
  .Element-RWxlbWVudCxQZXJzb24sRXh0 {
    BackgroundColor: #686868;
    LineColor: #484848;
    LineStyle: 0;
    LineThickness: 2;
    FontColor: #ffffff;
    FontSize: 24;
    HorizontalAlignment: center;
    Shadowing: 0;
    MaximumWidth: 450;
  }
  // Element,Software System,Editor,Ext
  .Element-RWxlbWVudCxTb2Z0d2FyZSBTeXN0ZW0sRWRpdG9yLEV4dA== {
    BackgroundColor: #686868;
    LineColor: #484848;
    LineStyle: 0;
    LineThickness: 2;
    RoundCorner: 20;
    FontColor: #ffffff;
    FontSize: 24;
    HorizontalAlignment: center;
    Shadowing: 0;
    MaximumWidth: 450;
  }
  // Relationship
  .Relationship-UmVsYXRpb25zaGlw {
    LineThickness: 2;
    LineStyle: 10-10;
    LineColor: #444444;
    FontColor: #444444;
    FontSize: 24;
  }
  // C-xrefactory
  .Boundary-Qy14cmVmYWN0b3J5 {
    BackgroundColor: #ffffff;
    LineColor: #0b4884;
    LineStyle: 0;
    LineThickness: 2;
    FontColor: #1168bd;
    FontSize: 24;
    HorizontalAlignment: center;
    Shadowing: 0;
  }
&lt;/style&gt;

person "==Developer\n&lt;size:16&gt;[Person]&lt;/size&gt;\n\nEdits source code using an editor" &lt;&lt;Element-RWxlbWVudCxQZXJzb24sRXh0&gt;&gt; as Developer
rectangle "==Editor\n&lt;size:16&gt;[Software System]&lt;/size&gt;\n\nAllows Developer to modify source code and perform refactoring operations" &lt;&lt;Element-RWxlbWVudCxTb2Z0d2FyZSBTeXN0ZW0sRWRpdG9yLEV4dA==&gt;&gt; as Editor
database "==Source Code\n&lt;size:16&gt;[a set of files stored on disk]&lt;/size&gt;" &lt;&lt;Element-RWxlbWVudCxEQg==&gt;&gt; as 3

rectangle "C-xrefactory\n&lt;size:16&gt;[Software System]&lt;/size&gt;" &lt;&lt;Boundary-Qy14cmVmYWN0b3J5&gt;&gt; {
  rectangle "==cxrefCore\n&lt;size:16&gt;[Container: Refactoring Browser core]&lt;/size&gt;\n\nC Language program" &lt;&lt;Element-RWxlbWVudCxDb250YWluZXI=&gt;&gt; as Cxrefactory.cxrefCore
  database "==settingsStore\n&lt;size:16&gt;[Container: Configuration file for project settings]&lt;/size&gt;\n\nNon-standard format settings file" &lt;&lt;Element-RWxlbWVudCxDb250YWluZXIsREI=&gt;&gt; as Cxrefactory.settingsStore
  rectangle "==editorExtension\n&lt;size:16&gt;[Container: Plugin]&lt;/size&gt;\n\nExtends the Editor with c-xref operations and interfaces to the c-xrefactory API" &lt;&lt;Element-RWxlbWVudCxDb250YWluZXI=&gt;&gt; as Cxrefactory.editorExtension
  database "==referencesDb\n&lt;size:16&gt;[Container: Persistent symbol database storing references, definitions, and metadata for all project symbols. Created via -create/-update operations, indexed by symbol hash for fast lookup]&lt;/size&gt;\n\nCross-Reference Database (.cx files)" &lt;&lt;Element-RWxlbWVudCxDb250YWluZXIsREI=&gt;&gt; as Cxrefactory.referencesDb
}

Editor --&gt; Cxrefactory.editorExtension &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "extends functionality using\n&lt;size:16&gt;[plugin]&lt;/size&gt;"
Cxrefactory.cxrefCore --&gt; 3 &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "reads source code from\n&lt;size:16&gt;[file I/O]&lt;/size&gt;"
Cxrefactory.cxrefCore --&gt; Cxrefactory.referencesDb &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "builds and queries\n&lt;size:16&gt;[hash-based lookup]&lt;/size&gt;"
Cxrefactory.editorExtension --&gt; Cxrefactory.settingsStore &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "writes\n&lt;size:16&gt;[new project wizard]&lt;/size&gt;"
Cxrefactory.cxrefCore --&gt; Cxrefactory.settingsStore &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "read"
Cxrefactory.editorExtension --&gt; Cxrefactory.cxrefCore &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "API\n&lt;size:16&gt;[requests information and gets commands to modify source code]&lt;/size&gt;"
Cxrefactory.cxrefCore --&gt; Cxrefactory.referencesDb &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "read/write"
Cxrefactory.cxrefCore --&gt; 3 &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "read/analyze"
Developer --&gt; Editor &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "usual editor/IDE operations"
Editor --&gt; 3 &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "normal editing operations"
Editor --&gt; Cxrefactory.editorExtension &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "extends\n&lt;size:16&gt;[Editor extension protocol]&lt;/size&gt;"
Developer --&gt; Cxrefactory.settingsStore &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "edit"
Cxrefactory.editorExtension --&gt; 3 &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "extended c-xrefactory operations"

@enduml</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_containers">7.2. Containers</h3>
<div class="paragraph">
<p>At this point the description of the internal structure of the containers are
tentative. The actual interfaces are not particularly clean, most code
files can and do include much every other module.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
One focus area for the ongoing work is to try to pry out modules/components
from the code mess by moving functions around, renaming and hiding
functions, where possible.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_cxrefcore">7.2.1. CxrefCore</h4>
<div class="listingblock">
<div class="content">
<pre>Failed to generate image: Could not load PlantUML. Either require 'asciidoctor-diagram-plantuml' or specify the location of the PlantUML JAR(s) using the 'DIAGRAM_PLANTUML_CLASSPATH' environment variable. Alternatively a PlantUML binary can be provided (plantuml-native in $PATH).
@startuml
title &lt;size:24&gt;Component View: C-xrefactory - cxrefCore&lt;/size&gt;

set separator none
left to right direction
skinparam ranksep 60
skinparam nodesep 30
hide stereotype

&lt;style&gt;
  root {
    BackgroundColor: #ffffff;
    FontColor: #444444;
  }
  // Element,Component
  .Element-RWxlbWVudCxDb21wb25lbnQ= {
    BackgroundColor: #85bbf0;
    LineColor: #5d82a8;
    LineStyle: 0;
    LineThickness: 2;
    RoundCorner: 20;
    FontColor: #ffffff;
    FontSize: 24;
    HorizontalAlignment: center;
    Shadowing: 0;
    MaximumWidth: 450;
  }
  // Element,Container,DB
  .Element-RWxlbWVudCxDb250YWluZXIsREI= {
    BackgroundColor: #438dd5;
    LineColor: #2e6295;
    LineStyle: 0;
    LineThickness: 2;
    FontColor: #ffffff;
    FontSize: 24;
    HorizontalAlignment: center;
    Shadowing: 0;
    MaximumWidth: 450;
  }
  // Element,DB
  .Element-RWxlbWVudCxEQg== {
    BackgroundColor: #ffffff;
    LineColor: #444444;
    LineStyle: 0;
    LineThickness: 2;
    FontColor: #444444;
    FontSize: 24;
    HorizontalAlignment: center;
    Shadowing: 0;
    MaximumWidth: 450;
  }
  // Relationship
  .Relationship-UmVsYXRpb25zaGlw {
    LineThickness: 2;
    LineStyle: 10-10;
    LineColor: #444444;
    FontColor: #444444;
    FontSize: 24;
  }
  // C-xrefactory
  .Boundary-Qy14cmVmYWN0b3J5 {
    BackgroundColor: #ffffff;
    LineColor: #0b4884;
    LineStyle: 0;
    LineThickness: 2;
    FontColor: #1168bd;
    FontSize: 24;
    HorizontalAlignment: center;
    Shadowing: 0;
  }
  // cxrefCore
  .Boundary-Y3hyZWZDb3Jl {
    BackgroundColor: #ffffff;
    LineColor: #2e6295;
    LineStyle: 0;
    LineThickness: 2;
    FontColor: #438dd5;
    FontSize: 24;
    HorizontalAlignment: center;
    Shadowing: 0;
  }
&lt;/style&gt;

database "==Source Code\n&lt;size:16&gt;[a set of files stored on disk]&lt;/size&gt;" &lt;&lt;Element-RWxlbWVudCxEQg==&gt;&gt; as 3

rectangle "C-xrefactory\n&lt;size:16&gt;[Software System]&lt;/size&gt;" &lt;&lt;Boundary-Qy14cmVmYWN0b3J5&gt;&gt; {
  rectangle "cxrefCore\n&lt;size:16&gt;[Container: Refactoring Browser core]&lt;/size&gt;" &lt;&lt;Boundary-Y3hyZWZDb3Jl&gt;&gt; {
    rectangle "==main\n&lt;size:16&gt;[Component: C]&lt;/size&gt;\n\nMain program" &lt;&lt;Element-RWxlbWVudCxDb21wb25lbnQ=&gt;&gt; as Cxrefactory.cxrefCore.main
    rectangle "==xref\n&lt;size:16&gt;[Component: C]&lt;/size&gt;\n\nCross-referencer" &lt;&lt;Element-RWxlbWVudCxDb21wb25lbnQ=&gt;&gt; as Cxrefactory.cxrefCore.xref
    rectangle "==server\n&lt;size:16&gt;[Component: C]&lt;/size&gt;\n\nEditor Server" &lt;&lt;Element-RWxlbWVudCxDb21wb25lbnQ=&gt;&gt; as Cxrefactory.cxrefCore.server
    rectangle "==refactory\n&lt;size:16&gt;[Component: C]&lt;/size&gt;\n\nRefactory" &lt;&lt;Element-RWxlbWVudCxDb21wb25lbnQ=&gt;&gt; as Cxrefactory.cxrefCore.refactory
    rectangle "==lsp\n&lt;size:16&gt;[Component: Language Server Protocol implementation for IDE integration - currently limited by symbol database architecture]&lt;/size&gt;\n\nLSP Server" &lt;&lt;Element-RWxlbWVudCxDb21wb25lbnQ=&gt;&gt; as Cxrefactory.cxrefCore.lsp
    rectangle "==lspAdapter\n&lt;size:16&gt;[Component: Converts LSP requests to c-xrefactory operations - needs symbol database abstraction]&lt;/size&gt;\n\nLSP Adapter" &lt;&lt;Element-RWxlbWVudCxDb21wb25lbnQ=&gt;&gt; as Cxrefactory.cxrefCore.lspAdapter
    rectangle "==cxref\n&lt;size:16&gt;[Component: C]&lt;/size&gt;\n\nReference handler" &lt;&lt;Element-RWxlbWVudCxDb21wb25lbnQ=&gt;&gt; as Cxrefactory.cxrefCore.cxref
    rectangle "==cxfile\n&lt;size:16&gt;[Component: Manages persistent cross-reference database with symbol indexing and file-based storage]&lt;/size&gt;\n\nReference Storage (.cx files)" &lt;&lt;Element-RWxlbWVudCxDb21wb25lbnQ=&gt;&gt; as Cxrefactory.cxrefCore.cxfile
    rectangle "==browserStack\n&lt;size:16&gt;[Component: Runtime symbol context stack for navigation, containing current references and symbol menus]&lt;/size&gt;\n\nBrowser Stack" &lt;&lt;Element-RWxlbWVudCxDb21wb25lbnQ=&gt;&gt; as Cxrefactory.cxrefCore.browserStack
    rectangle "==symbolResolver\n&lt;size:16&gt;[Component: Converts cursor positions to symbols, loads references, and finds definitions]&lt;/size&gt;\n\nSymbol Resolution Pipeline" &lt;&lt;Element-RWxlbWVudCxDb21wb25lbnQ=&gt;&gt; as Cxrefactory.cxrefCore.symbolResolver
    rectangle "==referenceTable\n&lt;size:16&gt;[Component: Runtime symbol cache loaded from .cx files for active session]&lt;/size&gt;\n\nIn-Memory Reference Table" &lt;&lt;Element-RWxlbWVudCxDb21wb25lbnQ=&gt;&gt; as Cxrefactory.cxrefCore.referenceTable
    rectangle "==yylex\n&lt;size:16&gt;[Component: C]&lt;/size&gt;\n\nLexical Analyser" &lt;&lt;Element-RWxlbWVudCxDb21wb25lbnQ=&gt;&gt; as Cxrefactory.cxrefCore.yylex
    rectangle "==parser\n&lt;size:16&gt;[Component: C]&lt;/size&gt;\n\nParser" &lt;&lt;Element-RWxlbWVudCxDb21wb25lbnQ=&gt;&gt; as Cxrefactory.cxrefCore.parser
  }

  database "==referencesDb\n&lt;size:16&gt;[Container: Persistent symbol database storing references, definitions, and metadata for all project symbols. Created via -create/-update operations, indexed by symbol hash for fast lookup]&lt;/size&gt;\n\nCross-Reference Database (.cx files)" &lt;&lt;Element-RWxlbWVudCxDb250YWluZXIsREI=&gt;&gt; as Cxrefactory.referencesDb
}

Cxrefactory.cxrefCore.main --&gt; Cxrefactory.cxrefCore.xref &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "dispatches to\n&lt;size:16&gt;[call]&lt;/size&gt;"
Cxrefactory.cxrefCore.main --&gt; Cxrefactory.cxrefCore.server &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "dispatches to\n&lt;size:16&gt;[call]&lt;/size&gt;"
Cxrefactory.cxrefCore.main --&gt; Cxrefactory.cxrefCore.refactory &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "dispatches to\n&lt;size:16&gt;[call]&lt;/size&gt;"
Cxrefactory.cxrefCore.main --&gt; Cxrefactory.cxrefCore.lsp &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "dispatches to\n&lt;size:16&gt;[call]&lt;/size&gt;"
Cxrefactory.cxrefCore.refactory --&gt; Cxrefactory.cxrefCore.server &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "uses\n&lt;size:16&gt;[call]&lt;/size&gt;"
Cxrefactory.cxrefCore.cxref --&gt; Cxrefactory.cxrefCore.symbolResolver &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "delegates symbol lookup to\n&lt;size:16&gt;[call]&lt;/size&gt;"
Cxrefactory.cxrefCore.symbolResolver --&gt; Cxrefactory.cxrefCore.cxfile &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "loads symbol data via\n&lt;size:16&gt;[call]&lt;/size&gt;"
Cxrefactory.cxrefCore.symbolResolver --&gt; Cxrefactory.cxrefCore.referenceTable &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "populates and queries\n&lt;size:16&gt;[call]&lt;/size&gt;"
Cxrefactory.cxrefCore.symbolResolver --&gt; Cxrefactory.cxrefCore.browserStack &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "builds navigation context in\n&lt;size:16&gt;[call]&lt;/size&gt;"
Cxrefactory.cxrefCore.cxfile --&gt; Cxrefactory.cxrefCore.referenceTable &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "loads symbols into\n&lt;size:16&gt;[batch loading]&lt;/size&gt;"
Cxrefactory.cxrefCore.lsp --&gt; Cxrefactory.cxrefCore.lspAdapter &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "delegates to\n&lt;size:16&gt;[call]&lt;/size&gt;"
Cxrefactory.cxrefCore.lspAdapter --&gt; Cxrefactory.cxrefCore.refactory &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "uses for refactoring\n&lt;size:16&gt;[call]&lt;/size&gt;"
Cxrefactory.cxrefCore.lspAdapter --&gt; Cxrefactory.cxrefCore.cxref &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "uses for navigation\n&lt;size:16&gt;[call]&lt;/size&gt;"
Cxrefactory.cxrefCore.lspAdapter --&gt; Cxrefactory.cxrefCore.symbolResolver &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "attempts symbol lookup via\n&lt;size:16&gt;[call]&lt;/size&gt;"
Cxrefactory.cxrefCore.xref --&gt; Cxrefactory.cxrefCore.cxref &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "handles references using\n&lt;size:16&gt;[call]&lt;/size&gt;"
Cxrefactory.cxrefCore.server --&gt; Cxrefactory.cxrefCore.cxref &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "handles references using\n&lt;size:16&gt;[call]&lt;/size&gt;"
Cxrefactory.cxrefCore.refactory --&gt; Cxrefactory.cxrefCore.cxref &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "handles references using\n&lt;size:16&gt;[call]&lt;/size&gt;"
Cxrefactory.cxrefCore.parser --&gt; Cxrefactory.cxrefCore.yylex &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "reads tokenized source using\n&lt;size:16&gt;[buffering]&lt;/size&gt;"
Cxrefactory.cxrefCore.xref --&gt; Cxrefactory.cxrefCore.parser &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "parses source code using\n&lt;size:16&gt;[call]&lt;/size&gt;"
Cxrefactory.cxrefCore.server --&gt; Cxrefactory.cxrefCore.parser &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "parses source code using\n&lt;size:16&gt;[call]&lt;/size&gt;"
Cxrefactory.cxrefCore.yylex --&gt; 3 &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "reads source code from\n&lt;size:16&gt;[file I/O]&lt;/size&gt;"
Cxrefactory.cxrefCore.cxfile --&gt; Cxrefactory.referencesDb &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "builds and queries\n&lt;size:16&gt;[hash-based lookup]&lt;/size&gt;"

@enduml</pre>
</div>
</div>
<div class="paragraph">
<p><code>cxrefCore</code> is the core container. It does all the work when it comes
to finding and reporting references to symbols, communicating
refactoring requests as well as storing reference information for
longer term storage and caching.</p>
</div>
<div class="paragraph">
<p>Although <code>c-xref</code> can be used as a command line tool, which can be
handy when debugging or exploring, it is normally used in "server"
mode. In server mode the communication between the editor extension
and the cxrefCore container is a back-and-forth communication using a
non-standard protocol over standard pipes.</p>
</div>
<div class="paragraph">
<p>The responsibilities of <code>cxrefCore</code> can largely be divided into</p>
</div>
<div class="ulist">
<ul>
<li>
<p>parsing source files to create, maintain the references database which stores all inter-module references</p>
</li>
<li>
<p>parsing source files to get important information such as positions for a functions begin and end</p>
</li>
<li>
<p>managing editor buffer state (as it might differ from the file on disc)</p>
</li>
<li>
<p>performing symbol navigation</p>
</li>
<li>
<p>creating and serving completion suggestions</p>
</li>
<li>
<p>performing refactorings such as renames, extracts and parameter manipulation</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>At this point it seems like refactorings are performed as separate
invocations of <code>c-xref</code> rather than through the server interface.</p>
</div>
</div>
<div class="sect3">
<h4 id="_editorextension">7.2.2. EditorExtension</h4>
<div class="listingblock">
<div class="content">
<pre>Failed to generate image: Could not load PlantUML. Either require 'asciidoctor-diagram-plantuml' or specify the location of the PlantUML JAR(s) using the 'DIAGRAM_PLANTUML_CLASSPATH' environment variable. Alternatively a PlantUML binary can be provided (plantuml-native in $PATH).
@startuml
title &lt;size:24&gt;Component View: C-xrefactory - editorExtension&lt;/size&gt;

set separator none
left to right direction
skinparam ranksep 60
skinparam nodesep 30
hide stereotype

&lt;style&gt;
  root {
    BackgroundColor: #ffffff;
    FontColor: #444444;
  }
  // Element,Component
  .Element-RWxlbWVudCxDb21wb25lbnQ= {
    BackgroundColor: #85bbf0;
    LineColor: #5d82a8;
    LineStyle: 0;
    LineThickness: 2;
    RoundCorner: 20;
    FontColor: #ffffff;
    FontSize: 24;
    HorizontalAlignment: center;
    Shadowing: 0;
    MaximumWidth: 450;
  }
  // Element,Software System,Editor,Ext
  .Element-RWxlbWVudCxTb2Z0d2FyZSBTeXN0ZW0sRWRpdG9yLEV4dA== {
    BackgroundColor: #686868;
    LineColor: #484848;
    LineStyle: 0;
    LineThickness: 2;
    RoundCorner: 20;
    FontColor: #ffffff;
    FontSize: 24;
    HorizontalAlignment: center;
    Shadowing: 0;
    MaximumWidth: 450;
  }
  // Relationship
  .Relationship-UmVsYXRpb25zaGlw {
    LineThickness: 2;
    LineStyle: 10-10;
    LineColor: #444444;
    FontColor: #444444;
    FontSize: 24;
  }
  // C-xrefactory
  .Boundary-Qy14cmVmYWN0b3J5 {
    BackgroundColor: #ffffff;
    LineColor: #0b4884;
    LineStyle: 0;
    LineThickness: 2;
    FontColor: #1168bd;
    FontSize: 24;
    HorizontalAlignment: center;
    Shadowing: 0;
  }
  // editorExtension
  .Boundary-ZWRpdG9yRXh0ZW5zaW9u {
    BackgroundColor: #ffffff;
    LineColor: #2e6295;
    LineStyle: 0;
    LineThickness: 2;
    FontColor: #438dd5;
    FontSize: 24;
    HorizontalAlignment: center;
    Shadowing: 0;
  }
&lt;/style&gt;

rectangle "==Editor\n&lt;size:16&gt;[Software System]&lt;/size&gt;\n\nAllows Developer to modify source code and perform refactoring operations" &lt;&lt;Element-RWxlbWVudCxTb2Z0d2FyZSBTeXN0ZW0sRWRpdG9yLEV4dA==&gt;&gt; as Editor

rectangle "C-xrefactory\n&lt;size:16&gt;[Software System]&lt;/size&gt;" &lt;&lt;Boundary-Qy14cmVmYWN0b3J5&gt;&gt; {
  rectangle "editorExtension\n&lt;size:16&gt;[Container: Plugin]&lt;/size&gt;" &lt;&lt;Boundary-ZWRpdG9yRXh0ZW5zaW9u&gt;&gt; {
    rectangle "==cxref.el\n&lt;size:16&gt;[Component: elisp]&lt;/size&gt;" &lt;&lt;Element-RWxlbWVudCxDb21wb25lbnQ=&gt;&gt; as Cxrefactory.editorExtension.cxrefel
    rectangle "==cxrefactory.el\n&lt;size:16&gt;[Component: elisp]&lt;/size&gt;" &lt;&lt;Element-RWxlbWVudCxDb21wb25lbnQ=&gt;&gt; as Cxrefactory.editorExtension.cxrefactoryel
    rectangle "==cxrefprotocol.el\n&lt;size:16&gt;[Component: elisp]&lt;/size&gt;" &lt;&lt;Element-RWxlbWVudCxDb21wb25lbnQ=&gt;&gt; as Cxrefactory.editorExtension.cxrefprotocolel
  }

}

Editor --&gt; Cxrefactory.editorExtension.cxrefactoryel &lt;&lt;Relationship-UmVsYXRpb25zaGlw&gt;&gt; : "extends functionality using\n&lt;size:16&gt;[plugin]&lt;/size&gt;"

@enduml</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>EditorExtension</code> container is responsible for plugging into an
editor of choice and handle the user interface, buffer management and
executing the refactoring edit operations.</p>
</div>
<div class="paragraph">
<p>Currently there is only one such extension supported, for <code>Emacs</code>,
although there existed code, still available in the repo history, for
an extension for <code>jEdit</code> which hasn&#8217;t been updated, modified or checked
for a long time and no longer is a part of this project.</p>
</div>
</div>
<div class="sect3">
<h4 id="_referencesdb">7.2.3. ReferencesDB</h4>
<div class="paragraph">
<p>The References database stores crossreferencing information for
symbols visible outside the module it is defined in. Information about
local/static symbols are not stored but gathered by parsing that
particular source file on demand.</p>
</div>
<div class="paragraph">
<p>Currently this information is stored in a somewhat cryptic, optimized
text format.</p>
</div>
<div class="paragraph">
<p>This storage can be divided into multiple files, probably for faster
access. Symbols are then hashed to know which of the "database" files
it is stored in. As all crossreferencing information for a symbol is
stored in the same "record", this allows reading only a single file
when a symbol is looked up.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_code">8. Code</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_commands">8.1. Commands</h3>
<div class="paragraph">
<p>The <em>editorExtension</em> calls the server using command line
options. These are then converted to first a command enum starting in
<code>OLO</code> ("on-line operation") or <code>AVR</code> ("available refactoring").</p>
</div>
<div class="paragraph">
<p>Some times the server needs to call the crossreferencer which is
performed in the same manner, command line options, but this call is
internal so the wanted arguments are stored in a vector which is
passed to the <code>xref()</code> in the same manner as <code>main()</code> passes the
actual <code>argc</code>/<code>argv</code>.</p>
</div>
<div class="paragraph">
<p>Many of the commands require extra arguments like positions/markers
which are passed in as extra arguments. E.g. a rename requires the
name to rename to which is sent in the <code>renameto=</code> option, which is
argparsed and stored in the option structure.</p>
</div>
<div class="paragraph">
<p>Some of these extra arguments are fairly random, like <code>-olcxparnum=</code>
and <code>-olcxparnum2=</code>. This should be cleaned up.</p>
</div>
<div class="paragraph">
<p>A move towards "events" with arguments would be helpful. This would
mean that we need to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>List all "events" that <code>c-xref</code> need to handle</p>
</li>
<li>
<p>Define the parameters/extra info that each of them need</p>
</li>
<li>
<p>Clean up the command line options to follow this</p>
</li>
<li>
<p>Create event structures to match each event and pass this to <code>server</code>, <code>xref</code> and <code>refactory</code></p>
</li>
<li>
<p>Rebuild the main command loop to parse command line options into event structures</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_passes">8.2. Passes</h3>
<div class="paragraph">
<p>There is a variable in <code>main()</code> called <code>firstPassing</code> which is set and passed
down through <code>mainEditServer()</code> until it is reset in
<code>mainFileProcessingInitialisations()</code>.</p>
</div>
<div class="paragraph">
<p>This is probably related to the fact that <code>c-xref</code> allows for passing
over the analyzed source multiple passes in case you compile the
project sources with different C defines. Variables in the <code>c-xref</code>
sources indicate this, e.g the loops in <code>mainEditServerProcessFile()</code>
and <code>mainXrefProcessInputFile()</code> (which are both strangely limited by
setting the maxPass variable to 1 before entering the loop&#8230;&#8203;).</p>
</div>
</div>
<div class="sect2">
<h3 id="_parsers">8.3. Parsers</h3>
<div class="paragraph">
<p><em>C-xref</em> uses a patched version of Berkley yacc to generate
parsers. There are a number of parsers</p>
</div>
<div class="ulist">
<ul>
<li>
<p>C</p>
</li>
<li>
<p>Yacc</p>
</li>
<li>
<p>C pre-processor expressions</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There might also exist small traces of the Java parser, which was
previously a part of the free <code>c-xref</code>, and the C++ parser that
existed but was proprietary.</p>
</div>
<div class="paragraph">
<p>The patch to byacc is mainly to the skeleton and seems to relate
mostly to handling of errors and adding a recursive parsing feature
that is required for Java, which was supported previously. It is not
impossible that this patch might not be necessary now that Java parsing
is not necessary, but this has not been tried.</p>
</div>
<div class="paragraph">
<p>Some changes are also made to be able to accomodate multiple parsers
in the same executable, mostly solved by CPP macros renaming the
parsing datastructures so that they can be accessed using the standard
names in the parsing skeleton. The Makefile generates the parsers and
renames the generated files as appropriate.</p>
</div>
</div>
<div class="sect2">
<h3 id="_integrated_preprocessor">8.4. Integrated Preprocessor</h3>
<div class="paragraph">
<p><em>C-xrefactory</em> includes its own integrated C preprocessor implementation rather than using the system&#8217;s preprocessor (cpp, clang preprocessor, etc.). This is a crucial architectural decision that enables core functionality.</p>
</div>
<div class="sect3">
<h4 id="_why_not_use_the_system_preprocessor">8.4.1. Why Not Use the System Preprocessor?</h4>
<div class="paragraph">
<p>Using an external preprocessor would mean that all macros would be expanded before c-xrefactory sees the code. This would make it impossible to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Navigate to macro definitions</p>
</li>
<li>
<p>Show macro usage and references</p>
</li>
<li>
<p>Refactor macro names and parameters</p>
</li>
<li>
<p>Complete macro identifiers</p>
</li>
<li>
<p>See macro arguments as distinct symbols</p>
</li>
<li>
<p>Understand the code structure as the programmer wrote it</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>By parsing the source at the macro level, c-xrefactory operates as a <strong>source-level tool</strong> rather than a post-preprocessed tool. This allows it to work with the code as developers see and write it, preserving all macro information for navigation and refactoring.</p>
</div>
</div>
<div class="sect3">
<h4 id="_implementation_details">8.4.2. Implementation Details</h4>
<div class="paragraph">
<p>The integrated preprocessor is implemented in <code>yylex.c</code> and includes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Macro definition handling (<code>processDefineDirective()</code>)</p>
</li>
<li>
<p>Macro expansion with argument substitution</p>
</li>
<li>
<p>Conditional compilation (<code>#if</code>, <code>#ifdef</code>, <code>#ifndef</code>, <code>#elif</code>, <code>#else</code>, <code>#endif</code>)</p>
</li>
<li>
<p>Include file processing (<code>#include</code>, <code>#include_next</code>)</p>
</li>
<li>
<p>Pragma directives (limited support)</p>
</li>
<li>
<p>Expression evaluation for <code>#if</code> directives (<code>cppexp_parser.y</code>)</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_limitations">8.4.3. Limitations</h4>
<div class="paragraph">
<p>The integrated preprocessor does not support all modern preprocessor features:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Platform-specific predefined macros (like <code><em>arm64</em></code>, <code><em>x86_64</em></code>) are not automatically defined</p>
</li>
<li>
<p>Some compiler-specific extensions may not be recognized (e.g. <code><em>has_feature()</code>, <code></em>building_module()</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These limitations mean that c-xrefactory may report syntax errors when encountering modern platform headers that use these features, even though the code compiles correctly with standard compilers.</p>
</div>
</div>
<div class="sect3">
<h4 id="_trade_offs">8.4.4. Trade-offs</h4>
<div class="paragraph">
<p>This design choice represents a fundamental trade-off:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Gained</strong>: Full macro-level navigation and refactoring capabilities</p>
</li>
<li>
<p><strong>Lost</strong>: Perfect compatibility with all preprocessor extensions and platform-specific features</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The benefit of macro-level refactoring is considered more valuable than perfect preprocessor compatibility, as it is a key differentiator for c-xrefactory.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_refactoring_and_the_parsers">8.5. Refactoring and the parsers</h3>
<div class="paragraph">
<p>Some refactorings need more detailed information about the code, maybe all do?</p>
</div>
<div class="paragraph">
<p>One example, at least, is parameter manipulation.  Then the refactorer
calls the appropriate parser (<code>serverEditParseBuffer()</code>) which
collects information in the corresponding semantic actions.  This
information is stored in various global variables, like
<code>parameterBeginPosition</code>.</p>
</div>
<div class="paragraph">
<p>The parser is filling out a ParsedInfo structure which conveys
information that can be used e.g. when extracting functions etc.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
At this point I don&#8217;t understand exactly how this interaction is
performed, there seems to be no way to parse only appropriate parts,
so the whole file need to be re-parsed.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Findings:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>some global variables are set as a result of command line
and arguments parsing, depending on which "command" the server is
acting on</p>
</li>
<li>
<p>the semantic rules in the parser(s) contains code that matches these
global variables and then inserts special lexems in the lexem stream</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>One example is how a Java 'move static method' was performed. It
requires a target position. That position is transferred from command
line options to global variables. When the Java parser was parsing a
class or similar it (or rather the lexer) looks at that "ddtarget
position information" and inserts a <code>OL_MARKER_TOKEN</code> in the stream.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
TODO: What extra "operation" the parsing should perform and return
data for should be packaged into some type of "command" or parameter
object that should be passed to the parser, rather than relying on
global variables.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_reading_files">8.6. Reading Files</h3>
<div class="paragraph">
<p>Here are some speculations about how the complex file reading is structured.</p>
</div>
<div class="paragraph">
<p>Each file is identified by a filenumber, which is an index into the
file table, and seems to have a <code>lexBuffer</code> tied to it so that you can
just continue from where ever you were. That in turn contains a
<code>CharacterBuffer</code> that handles the actual character reading.</p>
</div>
<div class="paragraph">
<p>And there is also an "editorBuffer"&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>The intricate interactions between these are hard to follow as the code
here are littered with short character names which are copies of fields
in the structures, and infested with many macros, probably in an ignorant
attempt at optimizing. ("The root of all evil is premature optimization" and
"Make it work, make it right, make it fast".)</p>
</div>
<div class="paragraph">
<p>It seems that everything start in <code>initInput()</code> in <code>yylex.c</code> where the
only existing call to <code>fillFileDescriptor()</code> is made. But you might
wonder why this function does some initial reading, this should be
pushed down to the buffers in the file descriptor.</p>
</div>
<div class="sect3">
<h4 id="_lexingscanning">8.6.1. Lexing/scanning</h4>
<div class="paragraph">
<p>Lexing/scanning is performed in two layers, one in <code>lexer.c</code> which
seems to be doing the actual lexing into lexems which are put in a
lexembuffer. This contains a sequence of encoded and compressed
symbols which first has a <code>LexemCode</code> which is followed by extra data,
like <code>Position</code>. These seems to always be added but not always necessary.</p>
</div>
<div class="paragraph">
<p>The higher level "scanning" is performed, as per ususal,
by <code>yylex.c</code>. <code>lexembuffer</code> defines some functions to put and get
lexems, chars (identifiers and file names?) as well as integers and
positions.</p>
</div>
<div class="paragraph">
<p>At this point the put/get lexem functions take a pointer to a pointer
to chars (which presumably is the lexem stream in the lexembuffer)
which it also advances. This requires the caller to manage the
LexemBuffer&#8217;s internal pointers outside and finally set them right
when done.</p>
</div>
<div class="paragraph">
<p>It would be much better to call the "putLexem()"-functions with a
lexemBuffer but there seems to be a few cases where the destination
(often <code>dd</code>) is not a lexem stream inside a lexemBuffer. These might
be related to macro handling.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This is a work-in-progress.  Currently most of the "normal"
usages are prepared to use the LexemBuffer&#8217;s pointers.  But the
handling of macros and defines are cases where the lexems are not put
in a LexemBuffer.  See the TODO.org for current status of this Mikado
sequence.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_semantic_information">8.6.2. Semantic information</h4>
<div class="paragraph">
<p>As the refactoring functions need some amount of semantic information,
in the sense of information gathered during parsing, this information
is collected in various ways when <code>c-xref</code> calls the "sub-task" to do
the parsing required.</p>
</div>
<div class="paragraph">
<p>Two structures hold information about various things, among which are
the memory index at certain points of the parsing. Thus it is possible
to verify e.g. that a editor region does not cover a break in block or
function structure. This structure is, at the point of writing, called
<code>parsedInfo</code> and definitely need to be tidied up.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_reference_database">8.7. Reference Database</h3>
<div class="paragraph">
<p><code>c-xref</code> run in "xref" mode creates, or updates, a database of
references for all externally visible symbols it encounters.</p>
</div>
<div class="paragraph">
<p>A good design should have a clean and generic interface to the
reference database, but this is still a work in progress to chisel
this out.</p>
</div>
<div class="sect3">
<h4 id="_architecture_overview">8.7.1. Architecture Overview</h4>
<div class="paragraph">
<p>c-xrefactory&#8217;s core functionality relies on a sophisticated symbol database that stores cross-references, definitions, and usage information for all symbols in a project. The database is implemented as a collection of binary <code>.cx</code> files and supports:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Creation</strong> via <code>-create</code> operations that parse all project files</p>
</li>
<li>
<p><strong>Updates</strong> via <code>-update</code> operations (incremental or full)</p>
</li>
<li>
<p><strong>Queries</strong> during symbol lookup operations</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_database_structure_and_format">8.7.2. Database Structure and Format</h4>
<div class="paragraph">
<p>The symbol database uses a hash-partitioned file structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">cxrefs/
 files        # File metadata and paths
 0000         # Symbol data for hash bucket 0
 0001         # Symbol data for hash bucket 1
 ...          # Additional hash buckets based on referenceFileCount</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each <code>.cx</code> file contains structured records with specific keys:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CXFI_FILE_NAME</code>: File paths and metadata</p>
</li>
<li>
<p><code>CXFI_SYMBOL_NAME</code>: Symbol names, types, and attributes</p>
</li>
<li>
<p><code>CXFI_REFERENCE</code>: Individual symbol references with positions and usage types</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_symbol_resolution_pipeline">8.7.3. Symbol Resolution Pipeline</h4>
<div class="paragraph">
<p>The symbol lookup process follows this pipeline:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">1. Cursor Position Input
   
2. Parse current file to identify symbol at position
   
3. scanReferencesToCreateMenu(symbolName)
   
4. Load symbol data from .cx files
   
5. Populate sessionData.browserStack
   
6. Find best definition via olcxOrderRefsAndGotoDefinition()
   
7. Navigate to definition position</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_key_data_structures">8.7.4. Key Data Structures</h4>
<div class="sect4">
<h5 id="_browser_stack_sessiondata_browserstack">Browser Stack (<code>sessionData.browserStack</code>)</h5>
<div class="paragraph">
<p>The browser stack is the runtime data structure for symbol navigation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct {
    OlcxReferences *top;           // Current symbol being browsed
    OlcxReferences *root;          // Stack base
} OlcxReferencesStack;

typedef struct {
    Reference *current;            // Current reference
    Reference *references;         // All references for symbol
    SymbolsMenu *symbolsMenu;      // Available symbols for selection
    Position callerPosition;       // Where lookup was initiated
    ServerOperation operation;     // Type of operation (OLO_PUSH, etc.)
} OlcxReferences;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_reference_information">Reference Information</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct {
    Position position;             // File, line, column
    Usage usage;                   // UsageDefined, UsageDeclared, UsageUsed
    struct Reference *next;        // Linked list of references
} Reference;

typedef struct {
    char *linkName;               // Symbol name with scope information
    Type type;                    // Symbol type (function, variable, etc.)
    Storage storage;              // Storage class
    Scope scope;                  // Visibility scope
    int includedFileNumber;       // File containing symbol
    Reference *references;        // All references to this symbol
} ReferenceItem;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_database_operations">8.7.5. Database Operations</h4>
<div class="sect4">
<h5 id="_database_creation_create">Database Creation (-create)</h5>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Parse all project files using C/Yacc parsers</p>
</li>
<li>
<p>Generate <code>ReferenceItem</code> entries for each symbol</p>
</li>
<li>
<p>Create <code>Reference</code> entries for each symbol usage</p>
</li>
<li>
<p>Write structured records to <code>.cx</code> files</p>
</li>
<li>
<p>Build hash-based index for fast lookup</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_database_updates_update">Database Updates (-update)</h5>
<div class="ulist">
<ul>
<li>
<p><strong>Full Update</strong>: Rebuild entire database</p>
</li>
<li>
<p><strong>Fast Update</strong>: Only process modified files based on timestamps</p>
</li>
<li>
<p><strong>Incremental</strong>: Smart detection of changed dependencies</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_symbol_lookup_olo_push_operations">Symbol Lookup (OLO_PUSH operations)</h5>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>scanReferencesToCreateMenu(symbolName)</code> loads symbol data</p>
</li>
<li>
<p><code>createSelectionMenu()</code> builds navigation menus</p>
</li>
<li>
<p><code>olProcessSelectedReferences()</code> populates browser stack</p>
</li>
<li>
<p><code>olcxOrderRefsAndGotoDefinition()</code> finds best definition</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_lsp_integration_challenges">8.7.6. LSP Integration Challenges</h4>
<div class="sect4">
<h5 id="_architectural_mismatch">Architectural Mismatch</h5>
<div class="paragraph">
<p>The current architecture was designed for <strong>batch processing</strong> and <strong>persistent databases</strong>, while LSP requires <strong>on-demand processing</strong> and <strong>responsive queries</strong>.</p>
</div>
<div class="paragraph">
<p><strong>Current LSP Problems:</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Persistent File Dependency</strong>: LSP <code>findDefinition()</code> calls <code>scanReferencesToCreateMenu()</code> which expects pre-existing <code>.cx</code> files</p>
</li>
<li>
<p><strong>Project-Wide Requirement</strong>: Full project analysis required before individual file operations</p>
</li>
<li>
<p><strong>Batch Processing Model</strong>: No support for incremental, per-request symbol resolution</p>
</li>
<li>
<p><strong>Cold Start Problem</strong>: New projects have no <code>.cx</code> files, causing all LSP operations to fail</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Error Flow in LSP Mode:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">LSP textDocument/definition request

findDefinition() called

scanReferencesToCreateMenu() called

No .cx files exist  empty results

browserStack remains empty

All definition requests return same default position</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_performance_characteristics">Performance Characteristics</h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Operation</th>
<th class="tableblock halign-left valign-top">File-Based (.cx)</th>
<th class="tableblock halign-left valign-top">On-Demand Parsing</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Cold Start</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Requires <code>-create</code> first</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parse file immediately</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Warm Queries</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">O(1) hash lookup</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">O(file_size) parsing</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Memory Usage</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Low (streaming)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">High (in-memory cache)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Incremental Updates</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Smart file tracking</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Per-file invalidation</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Multi-project</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Separate databases</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Workspace-scoped</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A proposal for a unified symbol database architecture has been documented. See <a href="16-proposed-refactorings.html#unified-symbol-database">Proposed Unified Symbol Database</a> in the Proposed Refactorings chapter.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_cxfile">8.7.7. CXFILE</h4>
<div class="paragraph">
<p>The current implementation of the reference database is file based,
with an optimized storage format.</p>
</div>
<div class="paragraph">
<p>There is limited support to automatically keep these updated during an
edit-compile cycle, you might have to update manually now and then.</p>
</div>
<div class="paragraph">
<p>The project settings (or command line options) indicate where the
file(s) are created and one option controls the number of files to be
used, <code>-refnum</code>.</p>
</div>
<div class="paragraph">
<p>This file (or files) contains compact, but textual representations of
the cross-reference information. Format is somewhat complex, but here
are somethings that I think I have found out:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the encoding has single character markers which are listed at the top
of cxfile.c</p>
</li>
<li>
<p>the coding seems to often start with a number and then a character,
such as '4l' (4 ell) means line 4, 23c mean column 23</p>
</li>
<li>
<p>references seems to be optimized to not repeat information if it
would be a repetition, such as '15l3cr7cr' means that there are two
references on line 15, one in column 3 the other in column 7</p>
</li>
<li>
<p>so there is a notion of "current" for all values which need not be
repeated</p>
</li>
<li>
<p>e.g. references all use 'fsulc' fields, i.e. file, symbol index,
usage, line and column, but do not repeat a 'fsulc' as long as it is
the same</p>
</li>
<li>
<p>some "fields" have a length indicator before, such as filenames
('6:/abc.c') indicated by ':' and version information ('34v file
format: C-xrefactory 1.6.0 ') indicated by 'v'.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>So a line might say</p>
</div>
<div class="literalblock">
<div class="content">
<pre>12205f 1522108169p m1ia 84:/home/...</pre>
</div>
</div>
<div class="paragraph">
<p>The line identifies the file with id 12205. The file was last included
in an update of refs at sometime which is identified by 1522108169
(mtime), has not been part of a full update of xrefs, was mentioned on
the command line. (I don&#8217;t know what the 'a' means&#8230;&#8203;) Finally, the
file name itself is 84 characters long.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
TODO: Build a tool to decipher this so that tests can query the
generated data for expected data. This is now partly ongoing in the
'utils' directory.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_reference_database_reading">8.7.8. Reference Database Reading</h4>
<div class="paragraph">
<p>All information about an externally visible symbol is stored in one,
and only one reference file, determined by hashing the linkname of the
symbol. So it will always suffice to read one reference file when
consulting the reference database (in the form of CXFILE) for a
symbol.</p>
</div>
<div class="paragraph">
<p>The reading of the CXFILE format is controlled by
`scanFunctionTable`s. These consists of a list of entries, one for
each key/tag/recordCode (see format description above) that the scan
will process.</p>
</div>
<div class="paragraph">
<p>As the reference file reading encounters a key/tag/recordCode it will
consult the table and see if there is an entry pointing to a handler
function for that key/tag/recordCode. If so, it will be called.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_editor_plugin">8.8. Editor Plugin</h3>
<div class="paragraph">
<p>The editor plugin has three different responsibilities:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>serve as the UI for the user when interacting with certain <code>c-xref</code>
related functions</p>
</li>
<li>
<p>query <code>c-xref server</code> for symbol references and support navigating
these in the source</p>
</li>
<li>
<p>initiate source code operations ("refactorings") and execute the
resulting edits</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Basically Emacs (and probably other editors) starts <code>c-xref</code> in
"server-mode" using <code>-server</code> which connects the editor
with <code>c-xref</code> through stdout/stdin. If you have <code>(setq
c-xref-debug-mode t)</code> this command is logged in the <code>*Messages*</code> buffer
with the prefix "calling:".</p>
</div>
<div class="paragraph">
<p>Commands are sent from the editor to the server on its standard input.
They looks very much like normal command line options, and in fact
<code>c-xref</code> will parse that input in the same way using the same
code. When the editor sends an <code>end-of-options</code> line, the server will
start executing whatever was sent, and return some information in the
file given as an <code>-o</code> option when the editor starts the <code>c-xref</code>
server process. The file is named and created by the editor and
usually resides in <code>/tmp</code>. With <code>c-xref-debug-mode</code> set to on this is
logged as "sending:". If you <code>(setq c-xref-debug-preserve-tmp-files
t)</code> Emacs will also not delete the temporary files it creates so that
you can inspect them afterwards.</p>
</div>
<div class="paragraph">
<p>When the server has finished processing the command and placed the
output in the output file it sends a <code>&lt;sync&gt;</code> reply.</p>
</div>
<div class="paragraph">
<p>The editor can then pick up the result from the output file and do
what it needs to do with it ("dispatching:").</p>
</div>
<div class="sect3">
<h4 id="_invocations">8.8.1. Invocations</h4>
<div class="paragraph">
<p>The editor invokes a new <code>c-xref</code> process for the following cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Refactoring</p>
<div class="paragraph">
<p>Each refactoring operation calls a new instance of <code>c-xref</code>?</p>
</div>
</li>
<li>
<p>Create Project</p>
<div class="paragraph">
<p>When a <code>c-xref</code> function is executed in the editor and there is no
project covering that file, an interactive "create project" session is
started, which is run by a separate <code>c-xref</code> process.</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_buffers">8.8.2. Buffers</h4>
<div class="paragraph">
<p>There is some magical editor buffer management happening inside of
<code>c-xref</code> which is not clear to me at this point. Basically it looks
like the editor-side tries to keep the server in sync with which
buffers are opened with what file&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>At this point I suspect that <code>-preload &lt;file1&gt; &lt;file2&gt;</code> means that the
editor has saved a copy of <code>&lt;file1&gt;</code> in <code>&lt;file2&gt;</code> and requests the server
to set up a "buffer" describing that file and use it instead of the
<code>&lt;file1&gt;</code> that recides on disk.</p>
</div>
<div class="paragraph">
<p>This is essential when doing refactoring since the version of the file
most likely only exists in the editor, so the editor has to tell the
server the current content somehow, this is the <code>-preload</code> option.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_editor_server">8.9. Editor Server</h3>
<div class="paragraph">
<p>When serving an editor the c-xrefactory application is divided into
the server, <em>c-xref</em> and the editor part, at this point only Emacs:en
are supported so that&#8217;s implemented in the
<code>editor/Emacs</code>-packages.</p>
</div>
<div class="sect3">
<h4 id="_interaction">8.9.1. Interaction</h4>
<div class="paragraph">
<p>The initial invocation of the edit server creates a process with which
communication is over stdin/stdout using a protocol which from the editor
is basically a version of the command line options.</p>
</div>
<div class="paragraph">
<p>When the editor has delivered all information to the server it sends
'end-of-option' as a command and the edit server processes whatever it
has and responds with <code>&lt;sync&gt;</code> which means that the editor can fetch
the result in the file it named as the output file using the '-o'
option.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As long as the communication between the editor and the server
is open, the same output file will be used. This makes it hard to
catch some interactions, since an editor operation might result in
multiple interactions, and the output file is then re-used.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Setting the emacs variable <code>c-xref-debug-mode</code> forces the editor to
copy the content of such an output file to a separate temporary file
before re-using it.</p>
</div>
<div class="paragraph">
<p>For some interactions the editor starts a completely new and fresh
<code>c-xref</code> process, see below. And actually you can&#8217;t do refactorings
using the server, they have to be separate calls. (Yes?) I have yet to
discover why this design choice was made.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
There are many things in the sources that handles refactorings
separately, such as <code>refactoring_options</code>, which is a separate copy of
the options structure used only when refactoring.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_protocol">8.9.2. Protocol</h4>
<div class="paragraph">
<p>Communication between the editor and the server is performed using
text through standard input/output to/from <em>c-xref</em>. The protocol is
defined in src/protocol.tc and must match <code>editor/emacs/c-xrefprotocol.el</code>.</p>
</div>
<div class="paragraph">
<p>The definition of the protocol only caters for the server&#8594;editor part,
the editor&#8594;server part consists of command lines resembling the command
line options and arguments, and actually is handled by the same code.</p>
</div>
<div class="paragraph">
<p>The file <code>protocol.tc</code> is included in <code>protocol.h</code> and <code>protocol.c</code>
which generates definitions and declarations for the elements through
using some macros.</p>
</div>
<div class="paragraph">
<p>There is a similar structure with <em>c-xrefprotocol.elt</em> which
includes <em>protocol.tc</em> to wrap the PROTOCOL_ITEMs into
<code>defvar</code>s.</p>
</div>
<div class="paragraph">
<p>There is also some Makefile trickery that ensures that the C and elisp
impementations are in sync.</p>
</div>
<div class="paragraph">
<p>One noteable detail of the protocol is that it carries strings in their native format,
utf-8. This means that lengths need to indicate <em>characters</em> not bytes.</p>
</div>
</div>
<div class="sect3">
<h4 id="_invocation_of_server">8.9.3. Invocation of server</h4>
<div class="paragraph">
<p>The editor fires up a server and keeps talking over the established
channel (elisp function 'c-xref-start-server-process'). This probably
puts extra demands on the memory management in the server, since it
might need to handle multiple information sets and options (as read
from a .cxrefrc-file) for multiple projects simultaneously over a
longer period of time. (E.g. if the user enters the editor starting
with one project and then continues to work on another then new
project options need to be read, and new reference information be
generated, read and cached.)</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
TODO: Figure out and describe how this works by looking at the
elisp-sources.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>FINDINGS:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>c-xref-start-server-process in c-xref.el</p>
</li>
<li>
<p>c-xref-send-data-to-running-process in c-xref.el</p>
</li>
<li>
<p>c-xref-server-call-refactoring-task in c-xref.el</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_communication_protocol">8.9.4. Communication Protocol</h4>
<div class="paragraph">
<p>The editor server is started using the appropriate command line option
and then it keeps the communication over stdin/stdout open.</p>
</div>
<div class="paragraph">
<p>The editor part sends command line options to the server, which looks
something like (from the read_xrefs test case):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>-encoding=european -olcxpush -urldirect  "-preload" "&lt;file&gt;" "-olmark=0" "-olcursor=6" "&lt;file&gt;" -xrefrc ".c-xrefrc" -p "&lt;project&gt;"
end-of-options</pre>
</div>
</div>
<div class="paragraph">
<p>In this case the "-olcxpush" is the operative command which results in
the following output</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;goto&gt;
 &lt;position-lc line=1 col=4 len=66&gt;CURDIR/single_int1.c&lt;/position-lc&gt;
&lt;/goto&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>As we can see from this interaction, the server will handle (all?)
input as a command line and manage the options as if it was a command
line invocation.</p>
</div>
<div class="paragraph">
<p>This explains the intricate interactions between the main program and
the option handling.</p>
</div>
<div class="paragraph">
<p>The reason behind this might be that a user of the editor might be
editing files on multiple projects at once, so every
interrogation/operation needs to clearly set the context of that
operation, which is what a user would do with the command line
options.</p>
</div>
</div>
<div class="sect3">
<h4 id="_olcx_naming">8.9.5. OLCX Naming</h4>
<div class="paragraph">
<p>It seems that all on-line editing server functions have an <code>olcx</code>
prefix, "On-Line C-Xrefactory", maybe&#8230;&#8203;</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_refactoring">8.10. Refactoring</h3>
<div class="paragraph">
<p>This is of course, the core in why I want to restore this, to get at its refactoring capabilities. So far, much is not understood, but here are some bits and pieces.</p>
</div>
<div class="sect3">
<h4 id="_editor_interface">8.10.1. Editor interface</h4>
<div class="paragraph">
<p>One thing that really confused me in the beginning was that the editor, primarily Emacs, don&#8217;t use the actual server that it has started for refactoring operations (and perhaps for other things also?). Instead it creates a separate instance with which it talks to about one refactoring.</p>
</div>
<div class="paragraph">
<p>I&#8217;ve just managed to create the first automatic test for refactorings, <code>olcx_refactory_rename</code>. It was created by running the sandboxed emacs to record the communication and thus finding the commands to use.</p>
</div>
<div class="paragraph">
<p>Based on this learning it seems that a refactoring typically is a single invocation of <code>c-xref</code> with appropriate arguments (start &amp; stop markers, the operation, and so on) and the server then answers with a sequence of operations, like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">&lt;goto&gt;
 &lt;position-off off=3 len=&lt;n&gt;&gt;CURDIR/test_source/single_int1.c&lt;/position-off&gt;
&lt;/goto&gt;
&lt;precheck len=&lt;n&gt;&gt; single_int_on_line_1_col_4;&lt;/precheck&gt;
&lt;replacement&gt;
 &lt;str len=&lt;n&gt;&gt;single_int_on_line_1_col_4&lt;/str&gt;  &lt;str len=&lt;n&gt;&gt;single_int_on_line_1_col_44&lt;/str&gt;
&lt;/replacement&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_interactions">8.10.2. Interactions</h4>
<div class="paragraph">
<p>I haven&#8217;t investigated the internal flow of such a sequence, but it is starting to look like <code>c-xref</code> is internally re-reading the initialization, I&#8217;m not at this point sure what this means, I hope it&#8217;s not internal recursion&#8230;&#8203;</p>
</div>
</div>
<div class="sect3">
<h4 id="_extraction">8.10.3. Extraction</h4>
<div class="paragraph">
<p>Each type of refactoring has it&#8217;s own little "language". E.g. extracting a method/function using <code>-refactory -rfct-extract-function</code> will return something like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">&lt;extraction-dialog type=newFunction_&gt; &lt;str len=20&gt;	newFunction_(str);
&lt;/str&gt;
 &lt;str len=39&gt;static void newFunction_(char str[]) {
&lt;/str&gt;
 &lt;str len=3&gt;}

&lt;/str&gt;
  &lt;int val=2 len=0&gt;&lt;/int&gt;
&lt;/extraction-dialog&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>So there is much logic in the editor for this. I suspect that the three <code>&lt;str&gt;</code> parts are</p>
</div>
<div class="ulist">
<ul>
<li>
<p>what to replace the current region with</p>
</li>
<li>
<p>what to place before the current region</p>
</li>
<li>
<p>what to place after the current region</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If this is correct then all extractions copy the region verbatim and then the server only have to figure out how to "glue" that to a semantically correct call/argument list.</p>
</div>
<div class="paragraph">
<p>As a side note the editor asks for a new name for the function and then calls the edit server with a rename request (having preloaded the new source file(s) of course).</p>
</div>
</div>
<div class="sect3">
<h4 id="_protocol_2">8.10.4. Protocol</h4>
<div class="paragraph">
<p>Dechiffrering the interaction between an editor and the edit server in
<code>c-xrefactory</code> isn&#8217;t easy. The protocol isn&#8217;t very clear or
concise. Here I&#8217;m starting to collect the important bits of the
invocation, the required and relevant options and the returned
information.</p>
</div>
<div class="paragraph">
<p>The test cases for various refactoring operations should give you some
more details.</p>
</div>
<div class="paragraph">
<p>All of these require a <code>-p</code> (project) option to know which c-xref
project options to read.</p>
</div>
<div class="sect4">
<h5 id="_general_principles">General Principles</h5>
<div class="paragraph">
<p>Refactorings are done using a separate invocation, the edit server
mode cannot handle refactorings. At least that is how the Emacs client
does it (haven&#8217;t looked at the Jedit version).</p>
</div>
<div class="paragraph">
<p>I suspect that it once was a single server that did both the symbol
management and the refactoring as there are remnants of a separate
instance of the option structure named "refactoringOptions". Also the
check for the refactoring mode is done using
<code>options.refactoringRegime == RegimeRefactory</code> which seems strange.</p>
</div>
<div class="paragraph">
<p>Anyway, if the refactoring succeeds the suggested edits is as per usual
in the communications buffer.</p>
</div>
<div class="paragraph">
<p>However, there are a couple of cases where the communcation does not
end there. Possibly because the client needs to communicate some
information back before the refactoring server can finish the job,
like presenting some menu selection.</p>
</div>
<div class="paragraph">
<p>My guess at this point is that it is the refactoring
server that closes the connection when it is done&#8230;&#8203;</p>
</div>
</div>
<div class="sect4">
<h5 id="_rename">Rename</h5>
<div class="paragraph">
<p><strong>Invocation:</strong> <code>-rfct-rename -renameto=NEW_NAME -olcursor=POSITION FILE</code></p>
</div>
<div class="paragraph">
<p><strong>Semantics:</strong> The symbol under the cursor (at POSITION in FILE) should
be renamed (replaced at all occurrences) by NEW_NAME.</p>
</div>
<div class="paragraph">
<p><strong>Result:</strong> sequence of</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">&lt;goto&gt;
 &lt;position-off off=POSITION len=N&gt;FILE&lt;/position-off&gt;
&lt;/goto&gt;
&lt;precheck len=N&gt;STRING&lt;/precheck&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>followed by sequence of</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">&lt;goto&gt;
 &lt;position-off off=POSITION len=N&gt;FILE&lt;/position-off&gt;
&lt;/goto&gt;
&lt;replacement&gt;
 &lt;str len=N&gt;ORIGINAL&lt;/str&gt;  &lt;str len=N&gt;REPLACEMENT&lt;/str&gt;
&lt;/replacement&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_protocol_messages">Protocol Messages</h5>
<div class="dlist">
<dl>
<dt class="hdlist1">&lt;goto&gt;{position-off}&lt;/goto&gt; &#8594; editor</dt>
<dd>
<p>Request the editor to move cursor to the indicated position (file, position).</p>
</dd>
<dt class="hdlist1">&lt;precheck len={int}&gt;{string}&lt;/precheck&gt; &#8594; editor</dt>
<dd>
<p>Requests that the editor verifies that the text under the cursor matches the string.</p>
</dd>
<dt class="hdlist1">&lt;replacement&gt;{str}{str}&lt;/replacement&gt;</dt>
<dd>
<p>Requests that the editor replaces the string under the cursor, which should be 'string1', with 'string2'.</p>
</dd>
<dt class="hdlist1">&lt;position-off off={int} len={int}&gt;{absolute path to file}&lt;/position-off&gt;</dt>
<dd>
<p>Indicates a position in the given file. 'off' is the character position in the file.</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_memory_handling">8.11. Memory handling</h3>
<div class="paragraph">
<p>c-xrefactory uses custom memory management via arena allocators rather than malloc/free for performance-critical operations.</p>
</div>
<div class="paragraph">
<p>See the <strong>Modules</strong> chapter for the design and architecture of the Memory module, and the <strong>Data Structures</strong> chapter for details on the arena allocator data structure and allocation model.</p>
</div>
<div class="paragraph">
<p>For debugging memory issues, especially arena lifetime violations, see the <strong>Development Environment</strong> chapter.</p>
</div>
<div class="sect3">
<h4 id="_the_memory_type">8.11.1. The Memory Type</h4>
<div class="paragraph">
<p>Memory allocation is managed through the <code>Memory</code> structure, which implements an arena/bump allocator. Different memory arenas serve different purposes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>cxMemory</code> - Cross-reference database (with overflow handling)</p>
</li>
<li>
<p><code>ppmMemory</code> - Preprocessor macro expansion</p>
</li>
<li>
<p><code>macroBodyMemory</code> - Macro definition storage</p>
</li>
<li>
<p><code>macroArgumentsMemory</code> - Macro argument expansion</p>
</li>
<li>
<p><code>fileTableMemory</code> - File table entries</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See <strong>Modules</strong> chapter for detailed description of each arena&#8217;s purpose and lifetime.</p>
</div>
</div>
<div class="sect3">
<h4 id="_option_memory">8.11.2. Option Memory</h4>
<div class="paragraph">
<p>The <code>optMemory</code> arena requires special handling because <code>Options</code> structures are copied during operation. When copying, all pointers into option memory must be adjusted to point into the target structure&#8217;s memory area, not the source&#8217;s.</p>
</div>
<div class="paragraph">
<p>Functions like <code>copyOptions()</code> perform this pointer adjustment through careful memory arithmetic, traversing a linked list of all memory locations that need updating.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The linked list nodes themselves are allocated in the Options structure&#8217;s dynamic memory.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_configuration">8.12. Configuration</h3>
<div class="paragraph">
<p>The legacy <code>c-xref</code> normally, in "production", uses a common configuration file in the
users home directory, <code>.c-xrefrc</code>. When a new project is defined its options will be
stored in this file as a new section.</p>
</div>
<div class="paragraph">
<p>It is possible to point to a specific configuration file using the command line option
<code>-xrefrc</code> which is used extensively in the tests to isolate them from the users
configuration.</p>
</div>
<div class="paragraph">
<p>Each "project" or "section" requires a name of the "project", which is the argument to
the <code>-p</code> command line option. And it may contain most other command line options on one
line each. These are always read, unless <code>-no-stdop</code> is used, before anything else. This
allows for different "default" options for each project.</p>
</div>
<div class="sect3">
<h4 id="_options">8.12.1. Options</h4>
<div class="paragraph">
<p>There are three possible sources for options.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Configuration files (~/.c-xrefrc)</p>
</li>
<li>
<p>Command line options at invocation, including server</p>
</li>
<li>
<p>Piped options sent to the server in commands</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Not all options are relevant in all cases.</p>
</div>
<div class="paragraph">
<p>All options sources uses exactly the same format so that the same code for decoding them can be used.</p>
</div>
</div>
<div class="sect3">
<h4 id="_logic">8.12.2. Logic</h4>
<div class="paragraph">
<p>When the editor has a file open it needs to "belong" to a project. The
logic for finding which is very intricate and complicated.</p>
</div>
<div class="paragraph">
<p>In this code there is also checks for things like if the file is
already in the index, if the configuration file has changed since last
time, indicating there are scenarios that are more complicated (the
server, obviously).</p>
</div>
<div class="paragraph">
<p>But I also think this code should be simplified a lot.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_modules">9. Modules</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The current state of <code>c-xrefactory</code> is not such that clean modules can
easily be identified and located. This is obviously one important goal
of the continuing refactoring work.</p>
</div>
<div class="paragraph">
<p>To be able to do that we need to understand the functionality enough
so that clusters of code can be refactored to be more and more clear
in terms of responsibilities and interfaces.</p>
</div>
<div class="paragraph">
<p>This section makes a stab at identifying some candidated to modules,
as illustrated by the component diagram for <code>cxrefCore</code>.</p>
</div>
<div class="sect2">
<h3 id="_yylex">9.1. Yylex</h3>
<div class="sect3">
<h4 id="_responsibilities">9.1.1. Responsibilities</h4>
<div class="ulist">
<ul>
<li>
<p>Transform source text to sequences of lexems and additional
information</p>
</li>
<li>
<p>Register and apply C pre-processor macros and defines as well as
defines made as command line options (<code>-D</code>)</p>
</li>
<li>
<p>Handle include files by pushing and poping read contexts</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_interface">9.1.2. Interface</h4>
<div class="paragraph">
<p>The <code>yylex</code> module has the standard interface required by any
<code>yacc</code>-based parser, which is a simple <code>yylex(void)</code> function.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_parser">9.2. Parser</h3>

</div>
<div class="sect2">
<h3 id="_xref">9.3. Xref</h3>

</div>
<div class="sect2">
<h3 id="_server">9.4. Server</h3>

</div>
<div class="sect2">
<h3 id="_refactory">9.5. Refactory</h3>

</div>
<div class="sect2">
<h3 id="_cxref">9.6. Cxref</h3>

</div>
<div class="sect2">
<h3 id="_main">9.7. Main</h3>

</div>
<div class="sect2">
<h3 id="_memory">9.8. Memory</h3>
<div class="sect3">
<h4 id="_responsibilities_2">9.8.1. Responsibilities</h4>
<div class="paragraph">
<p>The Memory module provides arena-based allocation for performance-critical and request-scoped operations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Fast allocation for macro expansion and lexical analysis</p>
</li>
<li>
<p>Bulk deallocation for request-scoped cleanup</p>
</li>
<li>
<p>Multiple specialized arenas for different data lifetimes</p>
</li>
<li>
<p>Overflow detection and optional dynamic resizing</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_design_rationale">9.8.2. Design Rationale</h4>
<div class="sect4">
<h5 id="_historical_context">Historical Context</h5>
<div class="paragraph">
<p>In the 1990s when c-xrefactory originated, memory was scarce. The design had to:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Minimize allocation overhead (no malloc/free per token)</p>
</li>
<li>
<p>Support large projects despite limited RAM</p>
</li>
<li>
<p>Allow overflow recovery via flushing and reuse</p>
</li>
<li>
<p>Enable efficient bulk cleanup</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Most memory arenas use statically allocated areas. Only <code>cxMemory</code> supports dynamic resizing to handle out-of-memory situations by discarding, flushing and reusing memory. This forced implementation of a complex caching strategy since overflow could happen mid-file.</p>
</div>
</div>
<div class="sect4">
<h5 id="_modern_benefits">Modern Benefits</h5>
<div class="paragraph">
<p>Even with abundant modern memory, arena allocators provide:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Performance</strong>: Bump pointer allocation is ~10x faster than malloc</p>
</li>
<li>
<p><strong>Cache locality</strong>: Related data allocated contiguously</p>
</li>
<li>
<p><strong>Automatic cleanup</strong>: Bulk deallocation prevents leaks</p>
</li>
<li>
<p><strong>Request scoping</strong>: Natural fit for parsing/expansion operations</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_arena_types_and_lifetimes">9.8.3. Arena Types and Lifetimes</h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 50%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Arena</th>
<th class="tableblock halign-left valign-top">Purpose</th>
<th class="tableblock halign-left valign-top">Lifetime</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>cxMemory</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Symbol database, reference tables, cross-reference data</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">File or session</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>ppmMemory</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Preprocessor macro expansion buffers (temporary allocations)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Per macro expansion</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>macroBodyMemory</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Macro definition storage</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Session</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>macroArgumentsMemory</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Macro argument expansion</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Per macro invocation</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>fileTableMemory</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">File metadata and paths</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Session</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>optMemory</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Command-line and config option strings (with special pointer adjustment)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Session</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_key_design_patterns">9.8.4. Key Design Patterns</h4>
<div class="sect4">
<h5 id="_marker_based_cleanup">Marker-Based Cleanup</h5>
<div class="paragraph">
<p>Functions save a marker before temporary allocations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">char *marker = ppmAllocc(0);   // Save current index
// ... temporary allocations ...
ppmFreeUntil(marker);          // Bulk cleanup</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_buffer_growth_pattern">Buffer Growth Pattern</h5>
<div class="paragraph">
<p>Long-lived buffers that may need to grow:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">// Allocate initial buffer
bufferDesc.buffer = ppmAllocc(initialSize);

// ... use buffer, may need growth ...

// Free temporaries FIRST
ppmFreeUntil(marker);

// NOW buffer can grow (it's at top-of-stack)
expandPreprocessorBufferIfOverflow(&amp;bufferDesc, writePointer);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_overflow_handling">Overflow Handling</h5>
<div class="paragraph">
<p>The <code>cxMemory</code> arena supports dynamic resizing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">bool cxMemoryOverflowHandler(int n) {
    // Attempt to resize arena
    // Return true if successful
}

memoryInit(&amp;cxMemory, "cxMemory", cxMemoryOverflowHandler, initialSize);</code></pre>
</div>
</div>
<div class="paragraph">
<p>When overflow occurs, handler can:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Resize the arena (if within limits)</p>
</li>
<li>
<p>Flush old data and reset</p>
</li>
<li>
<p>Signal failure (fatal error)</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_interface_2">9.8.5. Interface</h4>
<div class="paragraph">
<p>Key functions (see <code>memory.h</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">// Initialization
void memoryInit(Memory *memory, char *name,
                bool (*overflowHandler)(int n), int size);

// Allocation
void *memoryAlloc(Memory *memory, size_t size);
void *memoryAllocc(Memory *memory, int count, size_t size);

// Reallocation (only for most recent allocation)
void *memoryRealloc(Memory *memory, void *pointer,
                    size_t oldSize, size_t newSize);

// Bulk deallocation
size_t memoryFreeUntil(Memory *memory, void *marker);

// Guards
bool memoryIsAtTop(Memory *memory, void *pointer, size_t size);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_common_pitfalls">9.8.6. Common Pitfalls</h4>
<div class="paragraph">
<p>See the "Arena Allocator Lifetime Violations" section in the Development Environment chapter for:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Attempting to resize buffers not at top-of-stack</p>
</li>
<li>
<p>Calling <code>FreeUntil()</code> too late</p>
</li>
<li>
<p>Mixing arena lifetimes</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_future_directions">9.8.7. Future Directions</h4>
<div class="paragraph">
<p>Modern systems have abundant virtual memory. Possible improvements:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Simplify overflow handling</strong> - Allocate larger initial arenas</p>
</li>
<li>
<p><strong>Separate lifetime management</strong> - Don&#8217;t mix temporary and long-lived allocations</p>
</li>
<li>
<p><strong>Consider alternatives</strong> - Linear allocators for some use cases</p>
</li>
<li>
<p><strong>Add debug modes</strong> - Track allocation patterns and detect violations</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The experimental <code>FlushableMemory</code> type explores some of these ideas but hasn&#8217;t replaced current implementation.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_cxfile_2">9.9. Cxfile</h3>
<div class="sect3">
<h4 id="_responsibilities_3">9.9.1. Responsibilities</h4>
<div class="paragraph">
<p>Read and write the CXref database in "plain" text format.</p>
</div>
</div>
<div class="sect3">
<h4 id="_file_format">9.9.2. File format</h4>
<div class="paragraph">
<p>The current file format for the cross-reference data consists of records with the general format</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;number&gt;&lt;key&gt;[&lt;value&gt;]</pre>
</div>
</div>
<div class="paragraph">
<p>There are two important types of lines, a file information line and a
symbol information line.</p>
</div>
<div class="paragraph">
<p>The actual keys are documented in <code>cxfile.c</code>, but here is an example
file information line:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>32571f  1715027668m 21:/usr/include/ctype.h</pre>
</div>
</div>
<div class="paragraph">
<p>First we have two simple value/key pairs. We see "32571f" indicating
that this is file information for file with file number 32571.</p>
</div>
<div class="paragraph">
<p>Secondly we have "1715027668m". This is the modification time of the
file which is stored to be able to see if that file has been updated
since the reference database was last written.</p>
</div>
<div class="paragraph">
<p>And the third part is "21:/usr/include/ctype.h", which is of a record
type that is a bit more complex. The number is the length of the
value. The ':' indicates that the record is a filename.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_c_xref_el">9.10. c-xref.el</h3>

</div>
<div class="sect2">
<h3 id="_c_xrefactory_el">9.11. c-xrefactory.el</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="_data_structures">10. Data Structures</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are a lot of different data structures used in <code>c-xrefactory</code>.
This is a first step towards visualising some of them.</p>
</div>
<div class="sect2">
<h3 id="_referenceableitem_and_reference_core_domain_concepts">10.1. ReferenceableItem and Reference: Core Domain Concepts</h3>
<div class="paragraph">
<p>These are the fundamental cross-reference data structures that represent the "what" and "where" of code entities.</p>
</div>
<div class="sect3">
<h4 id="_referenceableitem">10.1.1. ReferenceableItem</h4>
<div class="paragraph">
<p>A <code>ReferenceableItem</code> represents a <strong>referenceable entity</strong> in the codebase - something that can be referenced from multiple locations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Functions and variables</p>
</li>
<li>
<p>Types (structs, unions, enums, typedefs)</p>
</li>
<li>
<p>Macros</p>
</li>
<li>
<p>Include directives (special case: <code>TypeCppInclude</code>)</p>
</li>
<li>
<p>Yacc non-terminals and rules</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Each <code>ReferenceableItem</code> contains:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>linkName</code> - Fully qualified name (e.g., <code>"MyClass::method"</code>)</p>
</li>
<li>
<p><code>type</code> - What kind of entity (function, variable, type, etc.)</p>
</li>
<li>
<p><code>storage</code>, <code>scope</code>, <code>visibility</code> - Language properties</p>
</li>
<li>
<p><code>includeFile</code> - For <code>TypeCppInclude</code> items, which file is being included</p>
</li>
<li>
<p><code>references</code> - Linked list of all <code>Reference</code> (occurrences) of this entity</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>ReferenceableItems are stored in the <code>referenceableItemTable</code> (hash table) and persisted to <code>.cx</code> files.</p>
</div>
</div>
<div class="sect3">
<h4 id="_reference_occurrence">10.1.2. Reference (Occurrence)</h4>
<div class="paragraph">
<p>A <code>Reference</code> represents a <strong>single occurrence</strong> of a ReferenceableItem at a specific location:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>position</code> - File, line, and column where this occurrence appears</p>
</li>
<li>
<p><code>usage</code> - How it&#8217;s used (definition, declaration, usage, etc.)</p>
</li>
<li>
<p><code>next</code> - Pointer to next occurrence in the list</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Each ReferenceableItem maintains a linked list of all its References, allowing you to find every place that entity appears in the codebase.</p>
</div>
<div class="paragraph">
<p><strong>Note:</strong> The term "Reference" in this context means "occurrence" - one specific use of an entity at one location. This is distinct from C++ references or reference semantics.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_symbol_parser_symbol_table">10.2. Symbol (Parser Symbol Table)</h3>
<div class="paragraph">
<p>There is also a structure called <code>Symbol</code>. This is <strong>separate from ReferenceableItem</strong> and serves a different purpose:</p>
</div>
<div class="paragraph">
<p><strong><code>Symbol</code></strong> - Parser-level symbol table entry (temporary, exists only during parsing):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Used by the C/Yacc parser for semantic analysis</p>
</li>
<li>
<p>Contains type information, position, storage class</p>
</li>
<li>
<p>Lives in <code>symbolTable</code> (hash table) during file parsing</p>
</li>
<li>
<p><strong>Not persisted</strong> - discarded after parsing completes</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong><code>ReferenceableItem</code></strong> - Cross-reference entity (persistent across entire codebase):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Created FROM Symbol properties when a referenceable construct is found</p>
</li>
<li>
<p>Stored in <code>referenceableItemTable</code> and saved to <code>.cx</code> files</p>
</li>
<li>
<p>Accumulates References from all files in the project</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Relationship:</strong> During parsing, when the parser encounters a referenceable symbol (function, variable, etc.), it:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Creates a <code>Symbol</code> in <code>symbolTable</code> for semantic analysis</p>
</li>
<li>
<p>Creates or finds a <code>ReferenceableItem</code> by copying Symbol properties</p>
</li>
<li>
<p>Adds a <code>Reference</code> to that ReferenceableItem&#8217;s list</p>
</li>
<li>
<p>Discards the Symbol when parsing completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This separation allows the parser to maintain its own temporary symbol table while building the persistent cross-reference database.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="diagrams/symbol-structures.svg" alt="Symbol structures">
</div>
<div class="title">Figure 1. Symbol and Reference Data Structures</div>
</div>
</div>
<div class="sect2">
<h3 id="_files_and_buffers">10.3. Files and Buffers</h3>
<div class="paragraph">
<p>Many strange things are going on with reading files so that is not completely understood yet.</p>
</div>
<div class="paragraph">
<p>Here is an initial attempt at illustrating how some of the file and text/lexem buffers are related.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="diagrams/buffer-structures.svg" alt="Buffer structures">
</div>
<div class="title">Figure 2. File Descriptor and Buffer Relationships</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It would be nice if the <code>LexemStream</code> structure could point to a
<code>LexemBuffer</code> instead of holding separate pointers which are
impossible to know what they actually point to&#8230;&#8203;
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This could be achieved if we could remove the CharacterBuffer
from LexemBuffer and make that a reference instead of a
composition. Then we&#8217;d need to add a CharacterBuffer to the structures
that has a LexemBuffer as a component (if they use it).
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_modes">10.4. Modes</h3>
<div class="paragraph">
<p><code>c-xrefactory</code> operates in different modes ("regimes" in original
<code>c-xref</code> parlance):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>xref - batch mode reference generation</p>
</li>
<li>
<p>server - editor server</p>
</li>
<li>
<p>refactory - refactory browser</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The default mode is "xref". The command line options <code>-server</code> and <code>-refactory</code>
selects one of the other modes. Branching is done in the final lines in
<code>main()</code>.</p>
</div>
<div class="paragraph">
<p>The code for the modes are intertwined, probably through re-use of
already existing functionality when extending to a refactoring
browser.</p>
</div>
<div class="paragraph">
<p>One evidence for this is that the refactory module calls the "main
task" as a "sub-task".  This forces some intricate fiddling with the
options data structure, like copying it.  Which I don&#8217;t
fully understand yet.</p>
</div>
<div class="paragraph">
<p>TODO?: Strip away the various "regimes" into more separated concerns
and handle options differently.</p>
</div>
</div>
<div class="sect2">
<h3 id="_options_2">10.5. Options</h3>
<div class="paragraph">
<p>The <code>Options</code> datastructure is used to collect options from the
command line as well as from options/configuration files and piped
options from the editor client using process-to-process
communication.</p>
</div>
<div class="paragraph">
<p>It consists of a collection of fields of the types</p>
</div>
<div class="ulist">
<ul>
<li>
<p>elementary types (bool, int, &#8230;&#8203;)</p>
</li>
<li>
<p>string (pointers to strings)</p>
</li>
<li>
<p>lists of strings (linked lists of pointers to strings)</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_allocation_copying">10.5.1. Allocation &amp; Copying</h4>
<div class="paragraph">
<p>Options has its own allocation using <code>optAlloc</code> which allocates in a
separate area, currently part of the options structure and utilizing
"dynamic allocation" (<code>dm_</code> functions on the <code>Memory</code> structure).</p>
</div>
<div class="paragraph">
<p>The Options structure are copied multiple times during a session, both
as a backup (<code>savedOptions</code>) and into a separate options structure
used by the Refactorer (<code>refactoringOptions</code>).</p>
</div>
<div class="paragraph">
<p>Since the options memory is then also copied, all pointers into the
options memory need to be updated. To be able to do this, the options
structure contains lists of addresses that needs to by "shifted".</p>
</div>
<div class="paragraph">
<p>When an option with a string or string list value is modified the
option is registered in either the list of string valued options or
the list of string list valued options. When an options structure is
copied it must be performed using a deep copy function which "shifts"
those options and their values (areas in the options memory) in the
copy so that they point into the memory area of the copy, not the
original.</p>
</div>
<div class="paragraph">
<p>After the deep copy the following point into the option memory of the
copy</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the lists of string and string list valued options (option fields)</p>
</li>
<li>
<p>all string and string valued option fields that are used (allocated)</p>
</li>
<li>
<p>all list nodes for the used option (allocated)</p>
</li>
<li>
<p>all list nodes for the string lists (allocated)</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_arena_allocators_memory">10.6. Arena Allocators (Memory)</h3>
<div class="paragraph">
<p>Arena allocators (also called region-based or bump allocators) are the fundamental memory management strategy used throughout c-xrefactory for performance-critical operations like macro expansion and lexical analysis.</p>
</div>
<div class="sect3">
<h4 id="_the_memory_structure">10.6.1. The Memory Structure</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct memory {
    char   *name;              // Arena name for diagnostics
    bool  (*overflowHandler)(int n); // Optional resize handler
    int     index;             // Next allocation offset (bump pointer)
    int     max;               // High-water mark
    size_t  size;              // Total arena size
    char   *area;              // Actual memory region
} Memory;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_allocation_model">10.6.2. Allocation Model</h4>
<div class="paragraph">
<p>Arena allocators use <strong>bump pointer allocation</strong>:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Allocation: Return <code>&amp;area[index]</code>, then <code>index += size</code></p>
</li>
<li>
<p>Deallocation: Bulk rollback via <code>FreeUntil(marker)</code></p>
</li>
<li>
<p>Reallocation: Only possible for most recent allocation</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This is extremely fast (O(1) allocation) but requires stack-like discipline for deallocation.</p>
</div>
</div>
<div class="sect3">
<h4 id="_stack_like_discipline">10.6.3. Stack-Like Discipline</h4>
<div class="paragraph">
<p>Arenas follow LIFO (last-in-first-out) cleanup:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">marker = ppmAllocc(0);        // Save current index
temp1 = ppmAllocc(100);       // Allocate
temp2 = ppmAllocc(200);       // Allocate
// Use temp1, temp2...
ppmFreeUntil(marker);         // Free both temp1 and temp2</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_key_constraint_top_of_stack_reallocation">10.6.4. Key Constraint: Top-of-Stack Reallocation</h4>
<div class="paragraph">
<p>Only the most recent allocation can be resized:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">buffer = ppmAllocc(1000);     // Allocate buffer
temp = ppmAllocc(500);        // Allocate temporary
ppmReallocc(buffer, ...);     //  FAILS - buffer not at top</code></pre>
</div>
</div>
<div class="paragraph">
<p>This constraint is enforced by guards in <code>memory.c</code> (see Development Environment chapter).</p>
</div>
</div>
<div class="sect3">
<h4 id="_memory_arena_types">10.6.5. Memory Arena Types</h4>
<div class="paragraph">
<p>c-xrefactory uses specialized arenas for different purposes (see Modules chapter for details):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>cxMemory</code> - Cross-reference database and symbol tables</p>
</li>
<li>
<p><code>ppmMemory</code> - Preprocessor macro expansion (temporary)</p>
</li>
<li>
<p><code>macroBodyMemory</code> - Macro body buffers</p>
</li>
<li>
<p><code>macroArgumentsMemory</code> - Macro argument expansion</p>
</li>
<li>
<p><code>fileTableMemory</code> - File table entries</p>
</li>
<li>
<p><code>optMemory</code> - Option strings (with special pointer adjustment)</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_preload_mechanism">10.7. Preload Mechanism</h3>
<div class="paragraph">
<p>The preload mechanism allows the server to work with editor buffer contents that haven&#8217;t been saved to disk. This is essential for providing real-time symbol navigation and completion while the user is actively editing.</p>
</div>
<div class="sect3">
<h4 id="_how_it_works">10.7.1. How It Works</h4>
<div class="paragraph">
<p>When an editor buffer is modified but not yet saved:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Editor Action</strong>: The Emacs client writes the current buffer content to a temporary file</p>
</li>
<li>
<p><strong>Server Request</strong>: The client sends a request with <code>-preload &lt;filename&gt; &lt;tmpfile&gt;</code> options</p>
</li>
<li>
<p><strong>Buffer Association</strong>: The server creates an <code>EditorBuffer</code> structure linking the on-disk filename to the temporary file containing the actual content</p>
</li>
<li>
<p><strong>Transparent Parsing</strong>: When the server needs to parse the file, it transparently reads from the temporary file instead of the on-disk file</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_why_its_needed">10.7.2. Why It&#8217;s Needed</h4>
<div class="paragraph">
<p>Without preload, the server would only see the last saved version of the file. The preload mechanism ensures that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Symbol navigation works with the current buffer state</p>
</li>
<li>
<p>Completion suggests symbols based on what&#8217;s actually typed</p>
</li>
<li>
<p>Refactorings operate on the current code, not stale saved content</p>
</li>
<li>
<p>Users get immediate feedback without having to save constantly</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_reference_management">10.7.3. Reference Management</h4>
<div class="paragraph">
<p>When a file is preloaded, the server must handle reference updates carefully:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Old references</strong> from the previous file version must be removed from the reference table before parsing</p>
</li>
<li>
<p>This prevents duplicate references (one set at old positions, another at new positions)</p>
</li>
<li>
<p>The removal happens in <code>removeReferencesForFile()</code> when preloaded content is detected</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_browser_stack">10.8. Browser Stack</h3>
<div class="paragraph">
<p>The browser stack maintains navigation history for symbol references, allowing users to browse through code by pushing symbol lookups and navigating back through previous queries.</p>
</div>
<div class="sect3">
<h4 id="_structure">10.8.1. Structure</h4>
<div class="paragraph">
<p>The browser stack is a linked list of <code>OlcxReferences</code> entries, where each entry represents a symbol lookup session:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Stack entries</strong> contain complete symbol information and reference lists for one navigation session</p>
</li>
<li>
<p><strong>Top pointer</strong> indicates the current active entry being navigated</p>
</li>
<li>
<p><strong>Root pointer</strong> tracks the base of the stack (most recent entry still available)</p>
</li>
<li>
<p>Entries between root and top are "future" navigation states that can be returned to via "next"</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_lifecycle">10.8.2. Lifecycle</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Push</strong>: When user requests symbol references (e.g., <code>-olcxpush</code>), a new empty entry is created on the stack</p>
</li>
<li>
<p><strong>Population</strong>: After parsing, the entry is filled with <code>BrowserMenu</code> structures containing references</p>
</li>
<li>
<p><strong>Navigation</strong>: Commands like <code>-olcxnext</code> and <code>-olcxprevious</code> move through references in the current entry</p>
</li>
<li>
<p><strong>Pop</strong>: User can pop back to previous entries to return to earlier symbol lookups</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_relationship_to_parsing">10.8.3. Relationship to Parsing</h4>
<div class="paragraph">
<p>The browser stack is populated in two stages:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Parse-time</strong>: References are collected in the referenceableItemTable during file parsing</p>
</li>
<li>
<p><strong>Menu Creation</strong>: ReferenceableItems are wrapped in BrowserMenu structures and added to the browser stack entry via <code>putOnLineLoadedReferences()</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This separation means that browser stack entries can become stale if files are reparsed (e.g., with preloaded content) without refreshing the stack. Users typically need to pop and re-push to get fresh reference lists after edits.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_browser_menu">10.9. Browser Menu</h3>
<div class="paragraph">
<p>A browser menu is a navigable list of referenceable items with their occurrences, organized for presentation to the user in Emacs. Multiple items may appear in a single menu when name resolution finds several candidates (e.g., symbols with the same name in different scopes).</p>
</div>
<div class="sect3">
<h4 id="_browsermenu_structure">10.9.1. BrowserMenu Structure</h4>
<div class="paragraph">
<p>Each <code>BrowserMenu</code> entry is a menu item wrapping a <code>ReferenceableItem</code> with UI presentation state:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>referenceable</strong>: The embedded <code>ReferenceableItem</code> (the entity being browsed)</p>
<div class="ulist">
<ul>
<li>
<p>Contains <code>linkName</code>, <code>type</code>, <code>storage</code>, <code>scope</code>, <code>visibility</code></p>
</li>
<li>
<p>Contains the list of <code>references</code> (occurrences) for this item</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>selected</strong>: Whether this item is currently selected for operations</p>
</li>
<li>
<p><strong>visible</strong>: Whether this item passes current visibility filters</p>
</li>
<li>
<p><strong>defaultPosition</strong>: The "best" occurrence to jump to (usually the definition)</p>
</li>
<li>
<p><strong>defaultUsage</strong>: The usage type of the default occurrence</p>
</li>
<li>
<p><strong>outOnLine</strong>: Display line number in the Emacs menu</p>
</li>
<li>
<p><strong>markers</strong>: Editor markers for refactoring operations</p>
</li>
<li>
<p><strong>next</strong>: Pointer to next menu item in the list</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Key insight:</strong> <code>BrowserMenu</code> is not just a menu - it&#8217;s a <strong>menu item</strong>. A collection of <code>BrowserMenu</code> items forms the actual menu shown to the user.</p>
</div>
</div>
<div class="sect3">
<h4 id="_multiple_menu_items_in_one_session">10.9.2. Multiple Menu Items in One Session</h4>
<div class="paragraph">
<p>A single browser stack entry (<code>OlcxReferences</code>) can contain multiple <code>BrowserMenu</code> items:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>hkSelectedSym</strong>: Menu items that matched at the cursor position (after disambiguation)</p>
</li>
<li>
<p><strong>symbolsMenu</strong>: Complete menu including related items (same name, similar signatures)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This allows users to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>See all candidates when a symbol is ambiguous</p>
</li>
<li>
<p>Navigate between related definitions (different scopes, include files)</p>
</li>
<li>
<p>Select specific items for refactoring operations</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_menu_population">10.9.3. Menu Population</h4>
<div class="paragraph">
<p>Browser menus are populated by scanning the referenceableItemTable:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Symbol lookup</strong>: Find all <code>ReferenceableItem</code> entries matching the requested symbol</p>
</li>
<li>
<p><strong>Menu item creation</strong>: Wrap each matching item in a <code>BrowserMenu</code> structure</p>
</li>
<li>
<p><strong>Reference collection</strong>: References are already in the ReferenceableItem</p>
</li>
<li>
<p><strong>Sorting and filtering</strong>: Order items by relevance and apply visibility filters</p>
</li>
<li>
<p><strong>Selection</strong>: Mark items that best match the cursor context (e.g., same file)</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_putting_it_all_together_domain_model_summary">10.10. Putting It All Together: Domain Model Summary</h3>
<div class="paragraph">
<p>Understanding the complete flow from parsing to browsing:</p>
</div>
<div class="sect3">
<h4 id="_during_parsing_building_the_cross_reference_database">10.10.1. During Parsing (Building the Cross-Reference Database)</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Parser creates Symbols</strong>: As the C/Yacc parser processes source code, it creates <code>Symbol</code> entries in <code>symbolTable</code> for semantic analysis</p>
</li>
<li>
<p><strong>ReferenceableItems are created/found</strong>: When encountering referenceable constructs (functions, variables, types, etc.):</p>
<div class="ulist">
<ul>
<li>
<p>Create a <code>ReferenceableItem</code> from Symbol properties</p>
</li>
<li>
<p>Check if it already exists in <code>referenceableItemTable</code></p>
</li>
<li>
<p>If new, add it to the table; if exists, reuse the existing one</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>References are recorded</strong>: Add a <code>Reference</code> (occurrence) to the ReferenceableItem&#8217;s list, recording position and usage</p>
</li>
<li>
<p><strong>Symbols are discarded</strong>: After parsing completes, the <code>symbolTable</code> is cleared (Symbols are temporary)</p>
</li>
<li>
<p><strong>Database is persisted</strong>: ReferenceableItems and their References are saved to <code>.cx</code> files</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Result:</strong> A persistent database mapping each entity (ReferenceableItem) to all its occurrences (References) across the entire codebase.</p>
</div>
</div>
<div class="sect3">
<h4 id="_during_browsing_interactive_navigation">10.10.2. During Browsing (Interactive Navigation)</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>User requests symbol info</strong>: User places cursor on a symbol and invokes a command (e.g., "push to symbol")</p>
</li>
<li>
<p><strong>Symbol lookup</strong>: Server finds matching ReferenceableItem(s) in <code>referenceableItemTable</code></p>
</li>
<li>
<p><strong>BrowserMenu creation</strong>: Each matching ReferenceableItem is wrapped in a <code>BrowserMenu</code> structure</p>
<div class="ulist">
<ul>
<li>
<p>Adds UI state (selected, visible, display position)</p>
</li>
<li>
<p>Marks best-fit match (e.g., same file as cursor)</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Stack push</strong>: BrowserMenu items are added to the browser stack (<code>OlcxReferences</code> entry)</p>
</li>
<li>
<p><strong>Display to user</strong>: Menu sent to Emacs showing all matching items and their occurrences</p>
</li>
<li>
<p><strong>Navigation</strong>: User can browse through references, select items, invoke refactorings</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Result:</strong> Interactive navigation through the cross-reference database with selection and filtering.</p>
</div>
</div>
<div class="sect3">
<h4 id="_key_relationships">10.10.3. Key Relationships</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">Symbol (parser)
     (creates during parsing)
ReferenceableItem (persistent entity)
     references: Reference* (list of occurrences)
     stored in: referenceableItemTable
          (wrapped for browsing)
      BrowserMenu (UI wrapper)
          stored in: OlcxReferences.symbolsMenu (browser stack)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This architecture separates concerns:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Parser symbols</strong> - Temporary, for semantic analysis</p>
</li>
<li>
<p><strong>Cross-reference database</strong> - Persistent, for finding all uses</p>
</li>
<li>
<p><strong>Browser menus</strong> - Presentation layer, for user interaction</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_algorithms">11. Algorithms</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The code does not always explain the algorithms that it
implements. This chapter will ultimately be a description of various
algorithms used by <em>c-xrefactory</em>.</p>
</div>
<div class="sect2">
<h3 id="_how_is_an_extract_refactoring_performed">11.1. How is an Extract refactoring performed?</h3>
<div class="paragraph">
<p>The region (mark and point/cursor positions) is sent to the <em>c-xref</em>
server in a <code>-refactory -rfct-extract</code> command.</p>
</div>
<div class="paragraph">
<p>The server parses the relevant file and sets some information that can
be used in some prechecks that are then performed, such as structure
check, and then the server answers with</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">&lt;extraction-dialog&gt;
    &lt;str .... /str&gt;
    &lt;str .... /str&gt;
    &lt;str .... /str&gt;
&lt;/extraction-dialog&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first string is the code that will replace the extracted code,
such as a call to the extracted function. The second string is the header
part that will preceed the extracted code ("preamble"), and the third is then of
course any code that needs to go after the extracted code ("postamble").</p>
</div>
<div class="paragraph">
<p>The actual code in the region is never sent to, or returned from, the
server. This is handled completely by the editor extension, and used
verbatim (except if it is a macro that is extracted, in which case
each line is terminated by the backslash) so no changes to that code
can be made.</p>
</div>
<div class="paragraph">
<p>The pre- and post-ambles might be of varying complexity. E.g. when
extracting a macro, the postamble can be completely empty. When
extracting a function both may contain code to transfer and restore
parameters into local variables to propagate in/out variables as
required.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The editor then requests a name from the user that it will use in a
rename operation that renames the default named
function/macro/variable.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_how_does_lexem_stream_management_work">11.2. How does lexem stream management work?</h3>
<div class="paragraph">
<p>Lexical analysis uses a stack of <code>LexemStream</code> structures to handle nested macro expansions. The key insight is that the stream type acts as a <strong>discriminator</strong> for buffer ownership and cleanup strategy.</p>
</div>
<div class="sect3">
<h4 id="_the_stream_types">11.2.1. The Stream Types</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef enum {
    NORMAL_STREAM,              // File or local buffer
    MACRO_STREAM,               // Macro expansion
    MACRO_ARGUMENT_STREAM,      // Macro argument expansion
} LexemStreamType;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Historically, there was also a <code>CACHED_STREAM</code> type when the caching mechanism was still active. This confirms that stream types are fundamentally about <strong>buffer ownership and refill strategy</strong> - each type encodes where the buffer came from and how to handle it when exhausted.
</td>
</tr>
</table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><strong>NORMAL_STREAM</strong></dt>
<dd>
<p>Buffer from file&#8217;s <code>lexemBuffer</code> or a local temporary. Not allocated from arena memory, so no cleanup needed when stream exhausted.</p>
</dd>
<dt class="hdlist1"><strong>MACRO_STREAM</strong></dt>
<dd>
<p>Buffer allocated from <code>macroBodyMemory</code> arena during macro expansion. Must call <code>mbmFreeUntil(stream.begin)</code> when popping from stack to free the arena allocation.</p>
</dd>
<dt class="hdlist1"><strong>MACRO_ARGUMENT_STREAM</strong></dt>
<dd>
<p>Buffer allocated from <code>ppmMemory</code> arena during macro argument expansion. Signals <code>END_OF_MACRO_ARGUMENT_EXCEPTION</code> when exhausted (cleanup handled by caller).</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_the_refill_algorithm">11.2.2. The Refill Algorithm</h4>
<div class="paragraph">
<p>When <code>currentInput</code> runs out of lexems (<code>read &gt;= write</code>), <code>refillInputIfEmpty()</code> uses the stream type to decide what to do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">while (currentInput.read &gt;= currentInput.write) {
    LexemStreamType inputType = currentInput.streamType;

    if (insideMacro()) {  // Stack not empty
        if (inputType == MACRO_ARGUMENT_STREAM) {
            return END_OF_MACRO_ARGUMENT_EXCEPTION;
        }
        // Only free MACRO_STREAM buffers (allocated from macroBodyMemory)
        if (inputType == MACRO_STREAM) {
            mbmFreeUntil(currentInput.begin);
        }
        currentInput = macroInputStack[--macroStackIndex];  // Pop
    }
    else if (inputType == NORMAL_STREAM) {
        // Refill from file
        buildLexemFromCharacters(&amp;currentFile.characterBuffer, ...);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_key_invariant">11.2.3. Key Invariant</h4>
<div class="paragraph">
<p><strong>Stream type must match buffer allocation:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>MACRO_STREAM</code>  buffer allocated from <code>macroBodyMemory</code></p>
</li>
<li>
<p><code>NORMAL_STREAM</code>  buffer NOT from macro arenas</p>
</li>
<li>
<p><code>MACRO_ARGUMENT_STREAM</code>  buffer from <code>ppmMemory</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Violating this invariant causes fatal errors when trying to free buffers from the wrong arena.</p>
</div>
</div>
<div class="sect3">
<h4 id="_common_bug_pattern">11.2.4. Common Bug Pattern</h4>
<div class="paragraph">
<p>Pushing a <code>NORMAL_STREAM</code> onto the macro stack, then trying to free it as if it were <code>MACRO_STREAM</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">// WRONG: Blindly freeing without checking type
mbmFreeUntil(currentInput.begin);  // Fails if currentInput is NORMAL_STREAM!

// CORRECT: Check type first
if (inputType == MACRO_STREAM) {
    mbmFreeUntil(currentInput.begin);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_editor_buffers_and_incremental_updates">11.3. Editor Buffers and Incremental Updates</h3>
<div class="paragraph">
<p>This section describes how <code>c-xrefactory</code> handles the reality that source code exists in
two places: on disk as files, and in memory as editor buffers. It also explains the
different update strategies and how references flow through the system.</p>
</div>
<div class="sect3">
<h4 id="_editor_buffer_abstraction">11.3.1. Editor Buffer Abstraction</h4>
<div class="sect4">
<h5 id="_the_duality_of_source_code">The Duality of Source Code</h5>
<div class="paragraph">
<p>When a user edits code in Emacs, the source code exists in two forms:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Disk files</strong>: The saved state on the filesystem</p>
</li>
<li>
<p><strong>Editor buffers</strong>: The current (possibly unsaved) state in the editor</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For code analysis to be useful during active editing, c-xrefactory must treat <strong>editor
buffers as the source of truth</strong> when they exist.</p>
</div>
</div>
<div class="sect4">
<h5 id="_the_preloading_mechanism">The Preloading Mechanism</h5>
<div class="paragraph">
<p>When the Emacs client sends a command to the <code>c-xref</code> server (like PUSH or NEXT), it uses
the <code>-preload</code> option to transmit modified buffers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>-preload &lt;original-file&gt; &lt;temp-file&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>-olcxnext -olcursor=5 /project/foo.c -preload /project/foo.c /tmp/emacs-xxx.tmp</pre>
</div>
</div>
<div class="paragraph">
<p><strong>The process:</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Emacs creates a temporary file containing the current buffer content</p>
</li>
<li>
<p>The temp file&#8217;s modification time represents when the buffer was last modified</p>
</li>
<li>
<p>The server loads this into an <code>EditorBuffer</code> structure</p>
</li>
<li>
<p>When parsing, the server reads from the temp file (buffer content) instead of the disk file</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This ensures that the server analyzes what the user sees in the editor, not the potentially stale disk file.</p>
</div>
</div>
<div class="sect4">
<h5 id="_editorbuffer_lifecycle">EditorBuffer Lifecycle</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">EditorBuffer {
    char *name;              // Original filename
    char *preLoadedFromFile; // Path to temp file with buffer content
    time_t modificationTime; // When buffer was last modified
    ...
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Created by <code>loadAllOpenedEditorBuffers()</code> at the start of each server operation</p>
</li>
<li>
<p>Lives only for the duration of that operation</p>
</li>
<li>
<p>Destroyed by <code>closeAllEditorBuffers()</code> at operation end</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_modification_time_tracking">11.3.2. Modification Time Tracking</h4>
<div class="paragraph">
<p>To implement incremental updates, c-xrefactory tracks when each file/buffer was last parsed.</p>
</div>
<div class="sect4">
<h5 id="_the_fields">The Fields</h5>
<div class="paragraph">
<p>Each <code>FileItem</code> in the file table has:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>lastParsedMtime</code> - The modification time when we last parsed this file (any update mode)</p>
</li>
<li>
<p><code>lastFullUpdateMtime</code> - The modification time when we last did a FULL update (including header propagation)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These are <code>time_t</code> values (seconds since epoch).</p>
</div>
</div>
<div class="sect4">
<h5 id="_dual_semantics">Dual Semantics</h5>
<div class="paragraph">
<p>The <code>lastParsedMtime</code> field has dual semantics depending on context:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>For disk files</strong>: Stores the file&#8217;s mtime when it was parsed</p>
</li>
<li>
<p><strong>For editor buffers</strong>: Stores the buffer&#8217;s mtime (from the preloaded temp file)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This works because <code>editorFileModificationTime()</code> abstracts over both:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">time_t editorFileModificationTime(char *filename) {
    EditorBuffer *buffer = getEditorBuffer(filename);
    if (buffer != NULL &amp;&amp; buffer-&gt;preLoadedFromFile != NULL) {
        return buffer-&gt;modificationTime;  // Buffer time
    } else {
        return fileModificationTime(filename);  // Disk time
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The abstraction is seamless: code can check "has this file changed?" without caring whether it&#8217;s a disk file or editor buffer.</p>
</div>
</div>
<div class="sect4">
<h5 id="_change_detection">Change Detection</h5>
<div class="paragraph">
<p>To determine if a file/buffer needs reparsing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">if (editorFileModificationTime(fileItem-&gt;name) != fileItem-&gt;lastParsedMtime) {
    // File/buffer has changed since we last parsed it
    reparse(fileItem);
    fileItem-&gt;lastParsedMtime = editorFileModificationTime(fileItem-&gt;name);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This pattern appears in:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>schedulingToUpdate()</code> - Marks files needing update before batch processing</p>
</li>
<li>
<p><code>processModifiedFilesForNavigation()</code> - Detects modified buffers during navigation</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_update_strategies">11.3.3. Update Strategies</h4>
<div class="paragraph">
<p><code>C-xrefactory</code> has two update strategies that trade off speed against completeness.</p>
</div>
<div class="sect4">
<h5 id="_fast_update_default">Fast Update (Default)</h5>
<div class="paragraph">
<p><strong>When used:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Automatic updates before PUSH operations (if enabled)</p>
</li>
<li>
<p>Explicit <code>-fastupdate</code> command</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>What it does:</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Checks which source files (.c) have changed (compares modification times)</p>
</li>
<li>
<p>Reparses only those changed source files</p>
</li>
<li>
<p>Updates the references database</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Trade-off:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p> <strong>Fast</strong>: Only reparses files that actually changed</p>
</li>
<li>
<p> <strong>Incomplete</strong>: Doesn&#8217;t detect when header files change</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre>foo.h modified  fast update  foo.h not reparsed
foo.c unchanged  foo.c not reparsed
Result: foo.c still has stale information about symbols from foo.h</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_full_update">Full Update</h5>
<div class="paragraph">
<p><strong>When used:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Explicit <code>-update</code> command</p>
</li>
<li>
<p>When <code>-exactpositionresolve</code> is enabled (forces full update)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>What it does:</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Checks which files (source OR headers) have changed</p>
</li>
<li>
<p>If a header changed, finds all source files that include it (transitively)</p>
</li>
<li>
<p>Reparses all affected source files</p>
</li>
<li>
<p>Updates the references database</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>The algorithm</strong> (<code>makeIncludeClosureOfFilesToUpdate</code>):</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Mark all changed files as <code>scheduledToUpdate</code></p>
</li>
<li>
<p>For each marked file:</p>
<div class="ulist">
<ul>
<li>
<p>Find all files that <code>#include</code> it (by looking up include references)</p>
</li>
<li>
<p>Mark those files as <code>scheduledToUpdate</code> too</p>
</li>
</ul>
</div>
</li>
<li>
<p>Repeat until no new files are added (transitive closure)</p>
</li>
<li>
<p>Reparse all marked source files</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Trade-off:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p> <strong>Complete</strong>: Catches header changes and propagates to all users</p>
</li>
<li>
<p> <strong>Slower</strong>: Can trigger reparsing of many source files if a common header changes</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre>common.h modified  full update  finds 50 files that include it
Result: Reparses all 50 source files to pick up header changes</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_when_does_the_difference_matter">When Does the Difference Matter?</h5>
<div class="paragraph">
<p>With modern CPUs and SSDs, the performance difference is often negligible for small to
medium projects. The fast update&#8217;s header-blindness can lead to subtle bugs where
changes don&#8217;t propagate. Full update is generally safer and more correct.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_reference_lifecycle">11.3.4. Reference Lifecycle</h4>
<div class="paragraph">
<p>References flow through multiple stages in c-xrefactory, with different storage
locations and ownership models at each stage.</p>
</div>
<div class="sect4">
<h5 id="_stage_1_parsing">Stage 1: Parsing</h5>
<div class="paragraph">
<p>When a file is parsed:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Symbols are discovered (functions, variables, types, etc.)</p>
</li>
<li>
<p>For each symbol, a <code>ReferenceableItem</code> is created or looked up in the <code>referenceableItemTable</code></p>
</li>
<li>
<p>Each usage of that symbol creates a <code>Reference</code> with a position</p>
</li>
<li>
<p>The reference is added to the referenceable&#8217;s reference list</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Storage:</strong> <code>cxMemory</code> (a custom arena allocator)</p>
</div>
<div class="paragraph">
<p><strong>Lifetime:</strong> Lives until the next update that reparses that file</p>
</div>
</div>
<div class="sect4">
<h5 id="_stage_2_the_referenceableitemtable">Stage 2: The ReferenceableItemTable</h5>
<div class="paragraph">
<p>The canonical storage for all references.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">ReferenceableItem {
    char *linkName;        // Symbol identifier
    Type type;             // Function, variable, macro, etc.
    Reference *references; // Linked list of all uses
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Key properties:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Allocated in <code>cxMemory</code></p>
</li>
<li>
<p>Persistent across multiple server operations</p>
</li>
<li>
<p>Updated incrementally as files are reparsed</p>
</li>
<li>
<p>References are <strong>not individually free&#8217;d</strong> - they&#8217;re arena-allocated</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_stage_3_session_stacks">Stage 3: Session Stacks</h5>
<div class="paragraph">
<p>When a user performs a PUSH operation (browsing a symbol), a session is created:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">SessionStackEntry {
    BrowserMenu *menu;       // Selected symbols
    Reference *references;   // COPY of references for navigation
    Reference *current;      // Current position in navigation
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Key properties:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>references</code> list is a <strong>copy</strong> (via <code>malloc</code>) of references from the referenceableItemTable</p>
</li>
<li>
<p>Each reference is individually allocated with <code>malloc</code> (see <code>addReferenceToList</code>)</p>
</li>
<li>
<p>When the session is destroyed, references are individually <code>free&#8217;d (see `freeReferences</code>)</p>
</li>
<li>
<p>Sessions are <strong>snapshots in time</strong> - they don&#8217;t automatically update when the table changes</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_why_separate_storage">Why Separate Storage?</h5>
<div class="paragraph">
<p><strong>Memory ownership:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Table references: Arena-allocated, freed in bulk</p>
</li>
<li>
<p>Session references: Individually allocated, individually freed</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If sessions pointed directly to table references, we&#8217;d have:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Dangling pointers when the table is updated</p>
</li>
<li>
<p>Double-free errors when sessions are destroyed</p>
</li>
<li>
<p>Memory corruption from mixed allocation strategies</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Snapshots vs. live data:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The table is the "live" source of truth</p>
</li>
<li>
<p>Sessions are working copies for a specific browsing operation</p>
</li>
<li>
<p>Users expect their navigation stack to be stable during browsing</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_the_staleness_problem">The Staleness Problem</h5>
<div class="paragraph">
<p>The separation causes a problem: session references can become stale.</p>
</div>
<div class="paragraph">
<p><strong>Scenario:</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>User PUSHes symbol <code>foo</code>  Session created with references at lines 10, 50, 100</p>
</li>
<li>
<p>User edits a file, adding lines</p>
</li>
<li>
<p>User navigates with NEXT  Session still points to lines 10, 50, 100 (wrong!)</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Solution:</strong> <code>processModifiedFilesForNavigation()</code></p>
</div>
<div class="paragraph">
<p>When NEXT/PREVIOUS operations occur, the server:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Detects which editor buffers have changed (modification time check)</p>
</li>
<li>
<p>Reparses those buffers (updates referenceableItemTable)</p>
</li>
<li>
<p><strong>Rebuilds</strong> the current session&#8217;s reference list from the updated table</p>
</li>
<li>
<p>Preserves the user&#8217;s navigation position by index</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">// Find user's position in old list
int currentIndex = 0;
Reference *ref = session-&gt;references;
while (ref != NULL &amp;&amp; ref != session-&gt;current) {
    currentIndex++;
    ref = ref-&gt;next;
}

// Free old list and rebuild from table
freeReferences(session-&gt;references);
session-&gt;references = NULL;
for (BrowserMenu *menu = session-&gt;menu; menu != NULL; menu = menu-&gt;next) {
    if (menu-&gt;selected) {
        ReferenceableItem *updatedItem = lookupInTable(&amp;menu-&gt;referenceable);
        addReferencesFromFileToList(updatedItem-&gt;references, ANY_FILE,
                                    &amp;session-&gt;references);
    }
}

// Restore position by index
ref = session-&gt;references;
for (int i = 0; i &lt; currentIndex &amp;&amp; ref-&gt;next != NULL; i++) {
    ref = ref-&gt;next;
}
session-&gt;current = ref;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This keeps navigation working correctly with live-edited code.</p>
</div>
</div>
<div class="sect4">
<h5 id="_trade_offs_of_the_incremental_approach">Trade-offs of the Incremental Approach</h5>
<div class="paragraph">
<p><strong>Advantages:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Minimal latency - only reparses changed buffers</p>
</li>
<li>
<p>Uses editor buffer content (user&#8217;s current view)</p>
</li>
<li>
<p>Preserves navigation position naturally</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Limitations:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Like fast update: doesn&#8217;t reparse includers of changed headers</p>
</li>
<li>
<p>Only updates the current session (other sessions on the stack remain stale)</p>
</li>
<li>
<p>Only happens during NEXT/PREVIOUS (not other operations)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For typical usage (navigating within files being actively edited), these limitations rarely matter. A fresh PUSH creates a new session with fresh references.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_summary">11.3.5. Summary</h4>
<div class="paragraph">
<p>The key insights:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Editor buffers are the source of truth</strong> when they exist (via preloading)</p>
</li>
<li>
<p><strong>Modification times</strong> are tracked uniformly for files and buffers</p>
</li>
<li>
<p><strong>Fast update</strong> trades completeness for speed (doesn&#8217;t chase headers)</p>
</li>
<li>
<p><strong>Full update</strong> is more thorough but can reparse many files</p>
</li>
<li>
<p><strong>References live in two places</strong>: canonical table (arena memory) and session copies (malloc)</p>
</li>
<li>
<p><strong>Sessions are snapshots</strong> that can become stale, requiring incremental rebuilding during navigation</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_how_does">11.4. How does &#8230;&#8203;</h3>
<div class="paragraph">
<p>TBD.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_development_environment">12. Development Environment</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_developing_here_be_dragons">12.1. Developing, here be dragons&#8230;&#8203;</h3>
<div class="paragraph">
<p>First the code is <strong>terrible</strong>, lots of single and double character
variables (<code>cc</code>, <code>ccc</code>, ..) and lost of administration on local
variables rather than the structures that are actually there. And
there are also a lot of macros. Unfortunately macros are hard to
refactor to functions. (But I&#8217;m making progress&#8230;&#8203;)</p>
</div>
<div class="paragraph">
<p>As there is no general way to refactor a macro to a function, various
techniques must be applied. I wrote <a href="https://www.responsive.se/thomas/2020/05/14/refactoring-macros-to-functions/">a blog post</a>
about one that have been fairly successful.</p>
</div>
<div class="paragraph">
<p>But actually it&#8217;s rather fun to be able to make small changes and
see the structure emerge, hone your refactoring and design skills,
and working on a project that started 20 years ago which still is
valuable, to me, and I hope, to others.</p>
</div>
<div class="paragraph">
<p>There should probably be a whole section on how to contribute and
develop <code>c-xrefactory</code> but until then here&#8217;s a short list of what
you need:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>C development environment (GNU/Clang/Make/&#8230;&#8203;)</p>
</li>
<li>
<p>Unittests are written using <a href="https://github.com/cgreen-devs/cgreen"><code>Cgreen</code></a></p>
</li>
<li>
<p>Clean code and refactoring knowledge (to drive the code to a better and cleaner state)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Helpful would be:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Compiler building knowledge (in the general sense, Yacc, but AST:s
and symbol table stuff are heavily used)</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_setup">12.2. Setup</h3>
<div class="paragraph">
<p>TBD.</p>
</div>
</div>
<div class="sect2">
<h3 id="_building">12.3. Building</h3>
<div class="paragraph">
<p>You should be able build <code>c-xref</code> using something like (may have changed over time&#8230;&#8203;)</p>
</div>
<div class="literalblock">
<div class="content">
<pre>cd src
make
make unit
make test</pre>
</div>
</div>
<div class="paragraph">
<p>But since the details of the building process are somewhat contrieved
and not so easy to see through, here&#8217;s the place where that should be
described.</p>
</div>
<div class="paragraph">
<p>One step in the build process was generating initialization information
for all the things in standard include files, which of course became
very dependent on the system you are running this on. This has now moved
into functions inside <code>c-xref</code> itself, like finding DEFINEs and include
paths.</p>
</div>
<div class="paragraph">
<p>The initial recovered c-xrefactory relied on having a working <em>c-xref</em>
for the current system. I don&#8217;t really know how they managed to do
that for all the various systems they were supporting.</p>
</div>
<div class="paragraph">
<p>Modern thinking is that you should always be able to build from
source, so this is something that needed change. We also want to
distribute <em>c-xref</em> as an el-get library which requires building from
source and should generate a version specific for the current system.</p>
</div>
<div class="paragraph">
<p><span class="line-through">The strategy selected, until some better idea comes along, is to try
to build a <em>c-xref.bs</em>, if there isn&#8217;t one already, from the sources in
the repository and then use that to re-generate the definitions and
rebuild a proper <em>c-xref</em>. See Bootstrapping.</span></p>
</div>
<div class="paragraph">
<p>We have managed to remove the complete bootstrapping step, so <code>c-xrefactory</code>
now builds like any other project.</p>
</div>
</div>
<div class="sect2">
<h3 id="_versions">12.4. Versions</h3>
<div class="paragraph">
<p>The current sources are in 1.6.X range. This is the same as the orginal
xrefactory and probably also the proprietary C++ supporting version.</p>
</div>
<div class="paragraph">
<p>There is an option, "-xrefactory-II", that might indicate that
something was going on. But currently the only difference seems to be
if the edit server protocol output is in the form of non-structured
fprintf:s or using functions in the <code>ppc</code>-family (either calling
<code>ppcGenRecord()</code> or `fprint`ing using some PPC-symbol). This, and
hinted to in how the emacs-part starts the server and some initial
server option variables in refactory.c, indicates that the
communication from the editor and the refactory server is using
this. It does <strong>not</strong> look like this is a forward to next generation
attempt.</p>
</div>
<div class="paragraph">
<p>What we should do is investigate if this switch actually is used
anywhere but in the editor server context, and if so, if it can be
made the default and the 'non-xrefactory-II' communication removed.</p>
</div>
</div>
<div class="sect2">
<h3 id="_coding">12.5. Coding</h3>
<div class="sect3">
<h4 id="_naming">12.5.1. Naming</h4>
<div class="paragraph">
<p><em>C-xref</em> started (probably) as a cross-referencer for the languages
supported (C, Java, C++), orginally had the name "xref" which became
"xrefactory" when refactoring support was added. And when Marin
released a "C only" version in 2009 most of all the "xref" references
and names was changed to "c-xref". So, as most software, there is a
history and a naming legacy to remember.</p>
</div>
<div class="paragraph">
<p>Here are some of the conventions in naming that are being used:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">olcx</dt>
<dd>
<p>"On-line CX" (Cross-reference) ?</p>
</dd>
<dt class="hdlist1">OLO</dt>
<dd>
<p>"On-line option" - some kind of option for the server</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_modules_and_include_files">12.5.2. Modules and Include Files</h4>
<div class="paragraph">
<p>The source code for <code>c-xrefactory</code> was using a very old C style with a
separate <code>proto.h</code> where all prototypes for all externally visible
functions were placed. Definitions are all over the place and it was
hard to see where data is actually declared. This must change into
module-oriented include-strategy.</p>
</div>
<div class="paragraph">
<p>Of course this will have to change into the modern x.h/x.c externally
visible interface model so that we get clean modules that can be
unittested.</p>
</div>
<div class="paragraph">
<p>The function prototypes have been now moved out to header files for
each "module". Some of the types have also done that, but this is
still a work in progress.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_debugging">12.6. Debugging</h3>
<div class="paragraph">
<p>TBD. Attachning <code>gdb</code>, <code>server-driver</code>&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p><code>yaccp</code> from <code>src/.gdbinit</code> can ease the printing of Yacc semantic data fields&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>A helpful option is the recently added <code>-commandlog=&#8230;&#8203;</code> which allows
you to capture all command arguments sent to the server/xref process
to a file. This makes it possible to capture command sequences and
"replay" them. Useful both for debugging and creating tests.</p>
</div>
<div class="sect3">
<h4 id="_arena_allocator_lifetime_violations">12.6.1. Arena Allocator Lifetime Violations</h4>
<div class="paragraph">
<p>The preprocessor macro expansion code uses arena allocators (<code>ppmMemory</code>, <code>macroBodyMemory</code>)
with stack-like discipline. Arena allocators are fast (pointer bumping) but require
careful lifetime management.</p>
</div>
<div class="sect4">
<h5 id="_the_problem_pattern">The Problem Pattern</h5>
<div class="paragraph">
<p>Arena allocators can only resize the most recent allocation ("top-of-stack").
A common violation occurs when trying to resize a buffer after other allocations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">buffer = ppmAllocc(size);           // Allocate buffer
marker = ppmAllocc(0);              // Save marker for cleanup
temp = ppmAllocc(tempSize);         // Allocate temporary
ppmReallocc(buffer, newSize, ...);  //  FAILS - buffer not at top!
ppmFreeUntil(marker);               // Free temporaries</code></pre>
</div>
</div>
<div class="paragraph">
<p>The correct pattern frees temporaries <strong>before</strong> growing the buffer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">buffer = ppmAllocc(size);           // Allocate buffer
marker = ppmAllocc(0);              // Save marker
temp = ppmAllocc(tempSize);         // Allocate temporary (use it)
ppmFreeUntil(marker);               // Free temporaries FIRST
ppmReallocc(buffer, newSize, ...);  //  Works - buffer now at top</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_lifetime_violation_guards">Lifetime Violation Guards</h5>
<div class="paragraph">
<p>The arena allocator includes guards that catch lifetime violations with detailed diagnostics:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><strong>Guard 1: Buffer Resize Guard</strong> (<code>memory.c</code> in <code>memoryRealloc()</code>)</dt>
<dd>
<p>Checks buffer is at top-of-stack before resizing. Provides expected vs actual locations
and suggests moving <code>ppmFreeUntil()</code> earlier.</p>
</dd>
<dt class="hdlist1"><strong>Guard 2: FreeUntil Bounds Guard</strong> (<code>memory.c</code> in <code>memoryFreeUntil()</code>)</dt>
<dd>
<p>Ensures marker is within valid allocated range. Catches corrupted or wrong-arena markers.</p>
</dd>
<dt class="hdlist1"><strong>Guard 3: Top-of-Stack Helper</strong> (<code>memoryIsAtTop()</code>)</dt>
<dd>
<p>Allows explicit verification before operations requiring top-of-stack:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">assert(memoryIsAtTop(&amp;ppmMemory, buffer, oldSize));
ppmReallocc(buffer, newSize, sizeof(char), oldSize);</code></pre>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_example_test_collation_long_expansion">Example: test_collation_long_expansion</h5>
<div class="paragraph">
<p>This test case triggered the violation guard when macro expansion created a very large
output (19 <code>FLAG_STRING</code> invocations). The <code>collate()</code> function was calling <code>ppmFreeUntil()</code>
<strong>after</strong> <code>copyRemainingLexems()</code>, which needed to grow the caller&#8217;s buffer.</p>
</div>
<div class="paragraph">
<p>The fix: move <code>ppmFreeUntil()</code> to <strong>before</strong> <code>copyRemainingLexems()</code>. By this point,
temporary allocations from macro expansion were already used and could be freed,
allowing the buffer to become top-of-stack again.</p>
</div>
</div>
<div class="sect4">
<h5 id="_debugging_with_guards">Debugging With Guards</h5>
<div class="paragraph">
<p>When a guard triggers:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Read the fatal error messages - they explain what went wrong</p>
</li>
<li>
<p>Look for the assertion location in the stack trace</p>
</li>
<li>
<p>Check if <code>ppmFreeUntil()</code> is being called too late</p>
</li>
<li>
<p>Verify buffer growth happens after temporaries are freed</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The guards turn subtle crashes into clear diagnostics that point to the fix.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_testing">12.7. Testing</h3>
<div class="sect3">
<h4 id="_unittests">12.7.1. Unittests</h4>
<div class="paragraph">
<p>There are not very many unittests at this point, only covering a quarter of the
code. The "units" in this project are unclear and entangled so creating unittests is
hard since it was not build to be tested, test driven or even clearly modularized.</p>
</div>
<div class="paragraph">
<p>All unittests use <code>Cgreen</code> as the unittest framework. If you are unfamiliar with it the
most important point is that it can mock functions, so you will find mock
implementations of all external functions for a module in a corresponding
<code>&lt;module&gt;.mock</code> file.</p>
</div>
<div class="paragraph">
<p>Many modules are at least under test, meaning there is a &lt;module&gt;_tests.c in the
unittest directory. Often only containing an empty test.</p>
</div>
</div>
<div class="sect3">
<h4 id="_acceptance_tests">12.7.2. Acceptance Tests</h4>
<div class="paragraph">
<p>In the <code>tests</code> directory you will find tests that exercise the external behaviour of
<code>c-xref</code>, "acceptance tests" or "system tests". Some tests actually do only that, they
wouldn&#8217;t really count as tests as there are no verification except for the code being
executed.</p>
</div>
<div class="paragraph">
<p>There are two basic strategies for the tests:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>run a <code>c-xref</code> command, catch its output and verify</p>
</li>
<li>
<p>run a series of command using the EDIT_SERVER_DRIVER, collect output and results and verify</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Some tests do not even test its output in any meaningful way and only provide coverage.</p>
</div>
<div class="paragraph">
<p>Some tests do a very bad job at verifying, either because my understanding at that time
was very low, or because it is hard to verify the output. E.g. a "test" for generating
references might only grepping the CXrefs files for some strings, not verifying that
they actually point to the correct place.</p>
</div>
<div class="paragraph">
<p>Hopefully this will change as the code gets into a better state and the understanding
grows.</p>
</div>
</div>
<div class="sect3">
<h4 id="_test_structure">12.7.3. Test Structure</h4>
<div class="paragraph">
<p>Tests live in the <code>tests</code> directory and are auto-discovered by name: any directory starting with <code>test_</code> will be recognized as a test case.</p>
</div>
<div class="paragraph">
<p>Each test typically includes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>source.c</code> (or similar) - the code under test</p>
</li>
<li>
<p><code>expected</code> - the expected output</p>
</li>
<li>
<p><code>Makefile</code> - test runner that uses the boilerplate</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Most tests use <code>tests/Makefile.boilerplate</code> which provides common macros:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-makefile hljs" data-lang="makefile">include ../Makefile.boilerplate

$(TEST):
	$(COMMAND) source.c -o output.tmp
	$(NORMALIZE) output.tmp &gt; output
	$(VERIFY)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The key macros are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>$(COMMAND)</code></dt>
<dd>
<p>Runs <code>c-xref</code> with standard options and the test&#8217;s <code>.c-xrefrc</code></p>
</dd>
<dt class="hdlist1"><code>$(NORMALIZE)</code></dt>
<dd>
<p>Removes timestamps and other variable output</p>
</dd>
<dt class="hdlist1"><code>$(VERIFY)</code></dt>
<dd>
<p>Compares <code>output</code> with <code>expected</code>, removes <code>output</code> on success</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>When <code>$(VERIFY)</code> passes, the <code>output</code> file is removed. This means you can easily identify failing tests by looking for test directories that still contain an <code>output</code> file. The <code>utils/failing</code> script lists these.</p>
</div>
<div class="paragraph">
<p>To suspend a test (skip it during test runs), create a <code>.suspended</code> file in the test directory.</p>
</div>
</div>
<div class="sect3">
<h4 id="_general_setup">12.7.4. General Setup</h4>
<div class="paragraph">
<p>Since all(?) <code>c-xref</code> operation rely on an options file which must
contain absolute file paths (because the server runs as a separate
process) it must be generated whenever the tests are to be run in a
different location (new clone, test was renamed, &#8230;&#8203;).</p>
</div>
<div class="paragraph">
<p>This is performed by using a common template in <code>tests</code> and a target
in <code>tests/Maefile.boilerplate</code>.</p>
</div>
<div class="paragraph">
<p>Each test should have a <code>clean</code> target that removes any temporary and
generated files, including the <code>.c-xrefrc</code> file and generated
references. This way it is easy to ensure that all tests have updated
<code>.c-xrefrc</code> files.</p>
</div>
</div>
<div class="sect3">
<h4 id="_edit_server_driver_tests">12.7.5. Edit Server Driver Tests</h4>
<div class="paragraph">
<p>Since many operations are performed from the editor, and the editor
starts an "edit server" process, many tests need to emulate this
behaviour.</p>
</div>
<div class="paragraph">
<p>The edit server session is mostly used for navigation. Refactorings
are actually performed as separate invocations of <code>c-xref</code>.</p>
</div>
<div class="paragraph">
<p>In <code>utils</code> there is a <code>server_driver.py</code> script, which will take as
input a file containing a sequence of commands. You can use this to
start an edit, refactory or reference server session and then feed it
with commands in the same fashion as an editor would do. The script
also handles the communication through the buffer file (see [Editor
Interface](./Design:-Editor-Interface)).</p>
</div>
</div>
<div class="sect3">
<h4 id="_creating_more_edit_server_tests">12.7.6. Creating More Edit Server Tests</h4>
<div class="paragraph">
<p>You can relatively easy re-create a sequence of interactions by using the
sandboxed Emacs in <code>tests/sandboxed_emacs</code>.</p>
</div>
<div class="paragraph">
<p>There are two ways to use it, "make spy" or "make pure". With the
"spy" an intermediate spy is injected between the editor and the edit
server, capturing the interaction to a file.</p>
</div>
<div class="paragraph">
<p>With "pure" you just get the editor setup with <code>c-xref-debug-mode</code> and
<code>c-xref-debug-preserve-tmp-files</code> on. This means that you can do what
ever editor interactions you want and see the communication in the
<code>*Messages*</code> buffer. See [Editor Interface](./Design:-Editor-Interface)
for details.</p>
</div>
<div class="paragraph">
<p>Once you have figure out which part of the <code>*Messages*</code> buffer are
interesting you can copy that out to a file and run
<code>utils/messages2commands.py</code> on it to get a file formatted for input
to <code>server_driver.py</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
the <code>messages2commands</code> script converts all occurrences of the
current directory to CURDIR so it is handy to be in the same directory
as the sources when you run the conversion.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
the <code>messages2commands</code> script removes any <code>-preload</code> so you
need to take care that the positions inside the buffers are not
changed between interactions lest the <code>-olcursor</code> and <code>-olmark</code> will
be wrong. (You can just undo the change after a refactoring or
rename). Of course this also applies if you want to mimic a sequence
of refactorings, like the <code>jexercise</code> move method example. Sources will
then change so the next refactoring works from content of buffers, so you
have to handle this specifically.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>-preload</code> is the mechanism where the editor can send modified
buffers to <code>c-xref</code> so thay you don&#8217;t have to save between
refactorings, which is particularly important in the case of extract
since the extraction creates a default name which the editor then does
a rename of.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_utilities">12.8. Utilities</h3>
<div class="sect3">
<h4 id="_covers">12.8.1. Covers</h4>
<div class="paragraph">
<p><code>utils/covers.py</code> is a Python script that, in some enviroments, can list which test cases execute a particular line.</p>
</div>
<div class="paragraph">
<p>This is handy when you want to debug or step through a particular part of the code.
Find a test that covers that particular line and run it using the debugger (usually <code>make debug</code> in the test directory).</p>
</div>
<div class="paragraph">
<p>Synopsis:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>covers.py &lt;file&gt; &lt;line&gt;</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_sandboxed">12.8.2. Sandboxed</h4>
<div class="paragraph">
<p><code>utils/sandboxed</code> starts a sandboxed Emacs that uses the current elisp code and the <code>c-xref</code> from src.
This allows you to run a test changes without having to polute your own setup.</p>
</div>
<div class="paragraph">
<p>This actually runs the <code>tests/sandboxed_emacs</code> pure version, which also sets up a completely isolated Emacs environment with its own packages loaded, configuration etc.
See below.</p>
</div>
<div class="paragraph">
<p>Synopsis:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>sandboxed</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_debugging_the_protocol">12.9. Debugging the protocol</h3>
<div class="paragraph">
<p>There is a "pipe spy" in <code>tests/sandboxed_emacs</code>. You can build the
spy using</p>
</div>
<div class="literalblock">
<div class="content">
<pre>make spy</pre>
</div>
</div>
<div class="paragraph">
<p>and then start a sandboxed Emacs which invokes the spy using</p>
</div>
<div class="literalblock">
<div class="content">
<pre>make</pre>
</div>
</div>
<div class="paragraph">
<p>This Emacs will be sandboxed to use its own .emacs-files and have HOME
set to this directory.</p>
</div>
<div class="paragraph">
<p>The spy will log the communication between Emacs and the <strong>real</strong>
<code>c-xref</code> (<code>src/c-xref</code>) in log files in <code>/tmp</code>.</p>
</div>
<div class="paragraph">
<p>NOTE that Emacs will invoke several instanced of what it believes is
the real <code>c-xref</code> so there will be several log files to inspect.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_deployment">13. Deployment</h2>
<div class="sectionbody">
<div class="paragraph">
<p>TBD.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_decision_log">14. Decision Log</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter provides a historical record of significant design and architectural decisions made during the evolution of c-xrefactory.</p>
</div>
<div class="sect2">
<h3 id="_overview">14.1. Overview</h3>
<div class="paragraph">
<p>The decision log documents choices that have shaped the architecture, implementation, and direction of c-xrefactory. Most decisions from the original 1990s development are lost to history, but as they can be deduced from the codebase and commit history, they are being retroactively documented.</p>
</div>
<div class="paragraph">
<p>All architectural decisions are recorded using the <a href="https://adr.github.io/">Architecture Decision Record (ADR)</a> format and stored in the <code>adr/</code> directory. These ADRs are automatically integrated into the Structurizr documentation system.</p>
</div>
</div>
<div class="sect2">
<h3 id="_viewing_decision_records">14.2. Viewing Decision Records</h3>
<div class="paragraph">
<p>The ADRs can be accessed in several ways:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Via Structurizr</strong>: When viewing the <a href="https://structurizr.com/">Structurizr documentation</a>, navigate to the "Decisions" section to see all ADRs with cross-references and visualizations.</p>
</li>
<li>
<p><strong>Directly in the repository</strong>: Browse the <a href="../../adr/">adr/</a> directory for markdown files containing individual decision records.</p>
</li>
<li>
<p><strong>Command line</strong>: Use <code>ls doc/adr/*.md</code> from the project root to list all decisions.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_decision_categories">14.3. Decision Categories</h3>
<div class="paragraph">
<p>Current ADRs cover several categories:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Simplification decisions</strong>: Removing unused features (Java support, HTML generation, etc.)</p>
</li>
<li>
<p><strong>Tooling decisions</strong>: Choice of ADR format, documentation system</p>
</li>
<li>
<p><strong>Configuration decisions</strong>: Automatic config file discovery</p>
</li>
<li>
<p><strong>Format decisions</strong>: Reference data storage format</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For the complete list of decisions and their rationale, see the <a href="../../adr/">ADR directory</a> or the Decisions section in the Structurizr documentation.</p>
</div>
</div>
<div class="sect2">
<h3 id="_creating_new_adrs">14.4. Creating New ADRs</h3>
<div class="paragraph">
<p>When making significant architectural decisions:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Copy the template from <code>adr/templates/</code></p>
</li>
<li>
<p>Number it sequentially (e.g., <code>0012-description.md</code>)</p>
</li>
<li>
<p>Fill in the context, decision, and consequences</p>
</li>
<li>
<p>Commit it alongside the implementation</p>
</li>
<li>
<p>Reference it in commit messages and pull requests</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>See <a href="decisions#7">ADR-0007</a> for details on the ADR format and process.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_roadmap">15. Roadmap</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter outlines the development roadmap for c-xrefactory, tracking completed work, current priorities, and future architectural goals.</p>
</div>
<div class="sect2">
<h3 id="_guiding_principles">15.1. Guiding Principles</h3>
<div class="paragraph">
<p>The roadmap is guided by these principles:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Incremental improvement</strong>: Each step should provide immediate value while moving toward long-term goals</p>
</li>
<li>
<p><strong>Test-driven modernization</strong>: Maintain 85%+ test coverage to enable confident refactoring</p>
</li>
<li>
<p><strong>Backward compatibility</strong>: Preserve existing Emacs workflows while enabling modern IDE integration</p>
</li>
<li>
<p><strong>Architectural simplification</strong>: Replace artificial mode distinctions with unified, smart on-demand behavior</p>
</li>
<li>
<p><strong>Legacy code respect</strong>: Work with the existing 1990s codebase thoughtfully, not against it</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_recent_accomplishments_2025_q1">15.2. Recent Accomplishments (2025 Q1)</h3>
<div class="sect3">
<h4 id="_c_preprocessor_compliance_fixes">15.2.1. C Preprocessor Compliance Fixes</h4>
<div class="paragraph">
<p><strong>Problem</strong>: c-xrefactory was incorrectly expanding function-like macros during <code><mark></code> token pasting, violating C99 6.10.3.3 which mandates that operands of <code></mark></code> should NOT be macro-expanded before concatenation.</p>
</div>
<div class="paragraph">
<p><strong>Impact</strong>: Caused SIGSEGV in <code>test_ffmpeg</code> when processing complex standard library macros like <code>INT64_MAX</code> which expands to <code>(<em>INT64_C(9223372036854775807))</code> where <code></em>INT64_C(c)</code> is defined as <code>c ## L</code>.</p>
</div>
<div class="paragraph">
<p><strong>Fix</strong>: Removed macro expansion logic from <code>collate()</code> function in <code>src/yylex.c:1749-1797</code>. Now matches GCC behavior exactly.</p>
</div>
<div class="paragraph">
<p><strong>Test Updates</strong>: Updated 5 test cases to match correct GCC preprocessor behavior:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>test_collate_empty</code></p>
</li>
<li>
<p><code>test_token_pasting_with_expansion</code></p>
</li>
<li>
<p><code>test_token_pasting_with_expansion_lhs</code></p>
</li>
<li>
<p><code>test_token_pasting_with_expansion_rhs</code></p>
</li>
<li>
<p><code>test_token_pasting_with_illegal_expansion</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_memory_scaling_improvements">15.2.2. Memory Scaling Improvements</h4>
<div class="paragraph">
<p><strong>Problem</strong>: Large projects like ffmpeg were hitting the 30MB <code>stackMemory</code> limit during symbol table construction.</p>
</div>
<div class="paragraph">
<p><strong>Root Cause</strong>: Stack memory is a persistent arena allocator that accumulates symbol tables across all parsed files. Growth is expected and normal for large projects.</p>
</div>
<div class="paragraph">
<p><strong>Fix</strong>: Increased <code>SIZE_stackMemory</code> from 30MB to 100MB in <code>src/constants.h:19</code>.</p>
</div>
<div class="paragraph">
<p><strong>Diagnostic Additions</strong>: Added nesting level and stack index tracking in <code>src/xref.c</code> to monitor memory usage patterns and detect unbalanced block nesting.</p>
</div>
</div>
<div class="sect3">
<h4 id="_caching_system_removal">15.2.3. Caching System Removal</h4>
<div class="paragraph">
<p><strong>Decision</strong>: Removed the complex lexem stream caching mechanism to enable architectural refactoring.</p>
</div>
<div class="paragraph">
<p><strong>Impact</strong>: Performance regression for large multi-file parsing (6.4 slowdown on test_ffmpeg/test_systemd), but enables critical modernization work.</p>
</div>
<div class="paragraph">
<p><strong>Rationale</strong>: The ~300 lines of cache code were deeply intertwined with parsing and memory management, blocking refactoring efforts. Removal provides clearer code structure at the cost of temporary performance regression.</p>
</div>
<div class="paragraph">
<p><strong>See</strong>: <a href="../adr/0012-remove-lexem-stream-caching.md">ADR-0012: Remove Lexem Stream Caching</a> for detailed rationale, trade-offs, and future optimization strategies.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_short_term_goals">15.3. Short-term Goals</h3>
<div class="sect3">
<h4 id="_test_coverage_expansion">15.3.1. Test Coverage Expansion</h4>
<div class="paragraph">
<p><strong>Current Status</strong>: <strong>85%+ overall coverage achieved</strong> (January 2025)</p>
</div>
<div class="paragraph">
<p><strong>Priority</strong>: MEDIUM (maintenance mode)</p>
</div>
<div class="paragraph">
<p><strong>Ongoing Work</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Maintain 85%+ overall coverage as new features are added</p>
</li>
<li>
<p>Add focused tests for LSP integration points as they&#8217;re implemented</p>
</li>
<li>
<p>Systematic testing of error handling paths in new code</p>
</li>
<li>
<p>Monitor coverage regressions during refactoring</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_lsp_feature_completeness">15.3.2. LSP Feature Completeness</h4>
<div class="paragraph">
<p><strong>Current Status</strong>: Basic LSP communication works, single-file <code>textDocument/definition</code> implemented</p>
</div>
<div class="paragraph">
<p><strong>Priority</strong>: HIGH</p>
</div>
<div class="paragraph">
<p><strong>Completed Work</strong>:
*  <code>textDocument/definition</code> for <strong>single-file lookups</strong> (January 2025)
*  Clean parser API in <code>parsing.h/c</code> enabling operation-based control
*  Reference database integration working for in-memory queries</p>
</div>
<div class="paragraph">
<p><strong>Remaining Goals</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Multi-file definition lookup</strong> - Requires symbol type persistence and include graph</p>
</li>
<li>
<p><code>textDocument/references</code> using reference database</p>
</li>
<li>
<p><code>textDocument/hover</code> with symbol information</p>
</li>
<li>
<p><code>textDocument/completion</code> for basic completion</p>
</li>
<li>
<p>Cross-file symbol resolution</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Approach</strong>:
* Single-file done via clean API (no <code>.cx</code> files needed)
* Multi-file requires enhancements: see <a href="#clean-parser-api">Clean Parser API and Multi-File Definition Support</a> for investigation
* Leverage existing reference database (<code>refTab</code>) and symbol tables
* Reuse parser infrastructure via new clean ParserOperation API</p>
</div>
</div>
<div class="sect3">
<h4 id="_documentation_completeness">15.3.3. Documentation Completeness</h4>
<div class="paragraph">
<p><strong>Current Status</strong>: Architecture documentation mostly complete</p>
</div>
<div class="paragraph">
<p><strong>Priority</strong>: MEDIUM</p>
</div>
<div class="paragraph">
<p><strong>Goals</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Complete Structurizr C4 model with all major components</p>
</li>
<li>
<p>Document memory management strategies across all arenas</p>
</li>
<li>
<p>Create user guide for LSP integration</p>
</li>
<li>
<p>Document LSP vs Emacs feature parity matrix</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_medium_term_goals_6_12_months">15.4. Medium-term Goals (6-12 Months)</h3>
<div class="paragraph">
<p>These goals are detailed in <a href="16-major-codebase-improvements.html">Chapter 16: Major Codebase Improvements</a>. The roadmap proposes a priority ordering:</p>
</div>
<div class="sect3">
<h4 id="_1_lexemstream_api_improvements">15.4.1. 1. LexemStream API Improvements</h4>
<div class="paragraph">
<p><strong>Reference</strong>: <a href="16-major-codebase-improvements.html">Major Codebase Improvements - LexemStream API Improvements</a></p>
</div>
<div class="paragraph">
<p><strong>Status</strong>: <strong>PARTIALLY COMPLETE</strong> (~40% done as of November 2025)</p>
</div>
<div class="paragraph">
<p><strong>Priority</strong>: HIGH (Foundation for other refactorings)</p>
</div>
<div class="paragraph">
<p><strong>Rationale</strong>: The macro expansion code suffers from pointer parameter proliferation (6+ parameters per function). Adding a manipulation API to <code>LexemStream</code> (similar to <code>LexemBuffer</code>) will simplify buffer management and reduce error-prone pointer arithmetic.</p>
</div>
<div class="paragraph">
<p><strong>Completed work</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p> Basic API functions created (<code>lexemStreamHasMore</code>, <code>copyNextLexemFromStreamToStream</code>)</p>
</li>
<li>
<p> <code>copyRemainingLexems()</code> refactored to use API</p>
</li>
<li>
<p> <code>replaceMacroArguments()</code> refactored to use LexemStreams</p>
</li>
<li>
<p> <code>expandMacroArgument()</code> now uses LexemStream parameter</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Remaining work</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p> Extend LexemStream structure with ownership fields (<code>allocatedSize</code>, <code>ownsBuffer</code>)</p>
</li>
<li>
<p> Create full API (creation, capacity management, cleanup functions)</p>
</li>
<li>
<p> Refactor <code>collate()</code> - still has 5 pointer parameters</p>
</li>
<li>
<p> Migrate remaining helper functions</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Impact</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Reduces <code>collate()</code> from 5-6 parameters to 3-4</p>
</li>
<li>
<p>Centralizes buffer management logic</p>
</li>
<li>
<p>Enables clearer ownership semantics</p>
</li>
<li>
<p>Foundation for macro module extraction</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Remaining Effort</strong>: Smaller effort, can be completed independently</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Extend structure and create full API</p>
</li>
<li>
<p>Refactor <code>collate()</code> and helper functions</p>
</li>
<li>
<p>Testing, cleanup, and documentation</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_2_extract_macro_expansion_module">15.4.2. 2. Extract Macro Expansion Module</h4>
<div class="paragraph">
<p><strong>Reference</strong>: <a href="16-major-codebase-improvements.html#macro-expansion-module">Major Codebase Improvements - Extract Macro Expansion Module</a></p>
</div>
<div class="paragraph">
<p><strong>Priority</strong>: MEDIUM (Depends on LexemStream API)</p>
</div>
<div class="paragraph">
<p><strong>Rationale</strong>: <code>yylex.c</code> is 2353 lines combining lexing, file management, preprocessor directives, and macro expansion (~800 lines). Extracting macro expansion improves modularity and testability.</p>
</div>
<div class="paragraph">
<p><strong>Impact</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Reduces yylex.c by 34% (~800 lines)</p>
</li>
<li>
<p>Enables independent testing of macro expansion</p>
</li>
<li>
<p>Clearer separation: lexing vs. preprocessing</p>
</li>
<li>
<p>Facilitates future C++ macro support</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Effort</strong>: Larger refactoring, depends on LexemStream API completion</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Create module structure and move memory management</p>
</li>
<li>
<p>Migrate token processing and expansion logic</p>
</li>
<li>
<p>Integration, testing, and documentation</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_3_header_re_parsing_optimization">15.4.3. 3. Header Re-parsing Optimization</h4>
<div class="paragraph">
<p><strong>Priority</strong>: MEDIUM (Addresses caching removal performance regression)</p>
</div>
<div class="paragraph">
<p><strong>Problem</strong>: After removing the lexem stream cache, each source file re-parses all its included headers. For projects like ffmpeg with 2616 files including ~30-50 common headers each, this creates 78,000-130,000 redundant parsing operations.</p>
</div>
<div class="paragraph">
<p><strong>Proposed Solutions</strong> (in order of implementation):</p>
</div>
<div class="paragraph">
<p><strong>Phase 1: Incremental <code>-create</code> Mode</strong></p>
</div>
<div class="paragraph">
<p>Make <code>-create</code> operations incremental by default:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">c-xref -create
   Check .cx database for each file
   Only parse files that are:
     - Not in database, OR
     - Modified since last parse (mtime check)
   Significantly faster for iterative development</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Impact</strong>:
* Second and subsequent <code>-create</code> runs become near-instant if no files changed
* Leverages existing file modification tracking (<code>updateFileModificationTracking()</code>)
* No architectural changes needed - just skip parsing if DB is current
* Remains fully compatible with existing workflows</p>
</div>
<div class="paragraph">
<p><strong>Effort</strong>: Smaller effort, mostly configuration changes</p>
</div>
<div class="paragraph">
<p><strong>Phase 2: Preprocessor Dependency Caching</strong></p>
</div>
<div class="paragraph">
<p>Cache the <strong>include graph</strong> (which files include which headers) separately from parse results:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">// Lightweight structure - much smaller than full parse cache
typedef struct {
    int fileNumber;
    int includeCount;
    int includedFiles[]; // Array of file numbers
    time_t lastChecked;
} IncludeDependencyCache;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Benefits</strong>:
* Fast closure computation without re-preprocessing
* Track which files need reparsing when a header changes
* Much simpler than full lexem stream caching
* ~1KB per source file vs. ~100KB+ for full token cache</p>
</div>
<div class="paragraph">
<p><strong>Effort</strong>: Medium effort, moderate complexity but straightforward scope</p>
</div>
<div class="paragraph">
<p><strong>Phase 3: Selective Header Caching</strong> (Future optimization)</p>
</div>
<div class="paragraph">
<p>After architecture is clean, consider lightweight header caching:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cache <strong>only system headers</strong> (unlikely to change): <code>&lt;stdio.h&gt;</code>, <code>&lt;stdlib.h&gt;</code>, etc.</p>
</li>
<li>
<p>Project headers always re-parsed (change frequently during development)</p>
</li>
<li>
<p>Cache key: (header path, mtime, compiler flags)  tokenized stream</p>
</li>
<li>
<p>Much simpler than removed cache: no cache points, no parser state snapshots</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Design Constraint</strong>: Any future caching must be <strong>optional and transparent</strong>:
* Must work without cache (on-demand parsing as fallback)
* Cache is pure optimization, not architectural requirement
* Clear separation between parsing logic and caching logic</p>
</div>
<div class="paragraph">
<p><strong>Effort</strong>: Larger effort, deferred to after unified database architecture is complete</p>
</div>
</div>
<div class="sect3">
<h4 id="_4_clean_persistence_store_abstraction">15.4.4. 4. Clean Persistence Store Abstraction</h4>
<div class="paragraph">
<p><strong>Reference</strong>: <a href="16-major-codebase-improvements.html#clean-persistence-store">Major Codebase Improvements - Clean Persistence Store Abstraction</a></p>
</div>
<div class="paragraph">
<p><strong>Priority</strong>: HIGH (Foundation for Unified Symbol Database)</p>
</div>
<div class="paragraph">
<p><strong>Rationale</strong>: The <code>cxfile</code> module currently mixes persistence (reading/writing .cx files), search operations, and menu creation logic. This tight coupling prevents architectural improvements like LSP integration and alternative storage backends.</p>
</div>
<div class="paragraph">
<p><strong>Key Problem</strong>: Code conflates two distinct concepts:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Reference Database</strong> (in-memory <code>referenceableItemTable</code> - the source of truth)</p>
</li>
<li>
<p><strong>Persistence Store</strong> (.cx files on disk - durable cache)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Currently <code>.cx</code> files are sometimes treated as authoritative, when they should be just a cache.</p>
</div>
<div class="paragraph">
<p><strong>Impact</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Creates two clean layers: smart in-memory database vs. dumb durable storage</p>
</li>
<li>
<p>Enables testing without .cx files (mock persistence layer)</p>
</li>
<li>
<p>Foundation for LSP <code>textDocument/didChange</code> integration</p>
</li>
<li>
<p>Allows future storage backend alternatives (SQLite, etc.)</p>
</li>
<li>
<p>Removes ~200 lines of mixed-responsibility code</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Effort</strong>: Medium effort, requires careful abstraction layer design</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Create <code>persistence_store.h</code> and <code>reference_database.h</code> facades</p>
</li>
<li>
<p>Extract search/unused-detection logic to proper modules</p>
</li>
<li>
<p>Hide implementation details (<code>cxFileHashNumberForSymbol</code> becomes static)</p>
</li>
<li>
<p>Testing, documentation, and cleanup</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_5_unified_symbol_database_architecture">15.4.5. 5. Unified Symbol Database Architecture</h4>
<div class="paragraph">
<p><strong>Reference</strong>:
* <a href="16-major-codebase-improvements.html#unified-symbol-database">Major Codebase Improvements - Unified Symbol Database Architecture</a>
* <a href="../adr/0014-adopt-on-demand-parsing-architecture.md">ADR-0014: Adopt On-Demand Parsing Architecture</a></p>
</div>
<div class="paragraph">
<p><strong>Priority</strong>: HIGH (Enables true on-demand LSP)</p>
</div>
<div class="paragraph">
<p><strong>Dependencies</strong>: Clean Persistence Store Abstraction (item 4 above)</p>
</div>
<div class="paragraph">
<p><strong>Rationale</strong>: Transition from batch-mode (mandatory <code>-create</code>) to on-demand parsing where operations work immediately. Builds on the clean persistence layer to add smart invalidation, dependency tracking, and unified client interface.</p>
</div>
<div class="paragraph">
<p><strong>Key Benefits</strong>:
* Zero cold start - no upfront <code>-create</code> required
* Always up-to-date - automatic modification tracking
* LSP-native - perfect fit for language server architecture
* Single code path for Emacs and LSP clients
* Smart logic lives in in-memory layer, persistence is just durable cache</p>
</div>
<div class="paragraph">
<p><strong>Implementation Plan</strong> (see <a href="../adr/0014-adopt-on-demand-parsing-architecture.md">ADR-0014</a> for architecture details):
* Phase 1: Incremental <code>-create</code> (foundation)
* Phase 2: On-demand goto-definition proof-of-concept (medium effort)
* Phase 3: Extend to all refactorings (larger effort)
* Phase 4: Deprecate mandatory <code>-create</code> (smaller cleanup)</p>
</div>
<div class="paragraph">
<p><strong>Effort</strong>: Larger foundational work, enables all on-demand features</p>
</div>
<div class="paragraph">
<p><strong>Accepted Trade-offs</strong>:
* First operation on huge projects may have latency (1-5s)
* Limited detection of archaic <code>extern</code> in .c files (see <a href="../adr/0013-limited-extern-detection-in-c-files.md">ADR-0013</a>)
* These trade-offs enable modern, responsive IDE integration</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_long_term_vision">15.5. Long-term Vision</h3>
<div class="sect3">
<h4 id="_new_refactoring_features">15.5.1. New Refactoring Features</h4>
<div class="sect4">
<h5 id="_extract_function_from_expression">Extract Function from Expression</h5>
<div class="paragraph">
<p><strong>Current Limitation</strong>: Extract function only works on statement-level code blocks. Attempting to extract an expression (e.g., a complex boolean condition inside an <code>if</code> statement) fails because the system cannot detect expression context.</p>
</div>
<div class="paragraph">
<p><strong>Vision</strong>: Enable extraction of arbitrary expressions as separate functions with appropriate return types.</p>
</div>
<div class="paragraph">
<p><strong>Value</strong>: Removes artificial restriction, makes refactoring tool more complete and less surprising to users.</p>
</div>
<div class="paragraph">
<p><strong>Examples</strong>:</p>
</div>
<div class="paragraph">
<p><strong>Boolean Predicate Extraction:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">// Before:
if (functionSignature[i] == ' ' || functionSignature[i] == '\t' ||
    functionSignature[i] == '\n')

// After extraction:
static bool isWhitespace(char c) {
    return c == ' ' || c == '\t' || c == '\n';
}

if (isWhitespace(functionSignature[i]))</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Arithmetic Expression Extraction:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">// Before:
for (int i = 0; i &lt; sizeof(dispatch)/sizeof(dispatch[0]); i++)

// After extraction:
static size_t dispatchTableSize(void) {
    return sizeof(dispatch)/sizeof(dispatch[0]);
}

for (int i = 0; i &lt; dispatchTableSize(); i++)</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Technical Approach</strong>:</p>
</div>
<div class="paragraph">
<p>The investigation (documented in agent task a16ff53) identified the core blocker: the parser cannot currently detect whether block markers are placed within an expression context versus statement context.</p>
</div>
<div class="paragraph">
<p><strong>Recommended Implementation Strategy:</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Parsing Context Stack</strong></p>
<div class="ulist">
<ul>
<li>
<p>Add <code>ParsingContext</code> enum tracking current grammar production</p>
</li>
<li>
<p>Implement context stack with push/pop operations</p>
</li>
<li>
<p>Modify grammar rules to track context (<code>CONTEXT_IF_CONDITION</code>, <code>CONTEXT_WHILE_CONDITION</code>, <code>CONTEXT_RETURN_EXPR</code>, etc.)</p>
</li>
<li>
<p>Capture context when block markers are encountered</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Expression Type Inference</strong></p>
<div class="ulist">
<ul>
<li>
<p>Detect expression type from operators and operands</p>
</li>
<li>
<p>Infer return type (bool, int, size_t, etc.)</p>
</li>
<li>
<p>Handle type promotions and casts</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Modified Extraction Logic</strong></p>
<div class="ulist">
<ul>
<li>
<p>Simplify variable classification for expressions (all inputs, no outputs)</p>
</li>
<li>
<p>Generate appropriate return statement</p>
</li>
<li>
<p>Handle call-site substitution without assignment</p>
</li>
<li>
<p>Extract source text and substitute parameter names</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Testing and Refinement</strong></p>
<div class="ulist">
<ul>
<li>
<p>Test with various expression contexts</p>
</li>
<li>
<p>Handle edge cases (nested expressions, macro arguments, etc.)</p>
</li>
<li>
<p>Validate type inference accuracy</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Alternative Approach</strong>: Add user dialog to explicitly mark extraction as expression-based rather than auto-detecting, which would be simpler but provide less seamless UX.</p>
</div>
<div class="paragraph">
<p><strong>Current Code State</strong>: The extraction infrastructure already has commented placeholders (<code>isInExpression</code> boolean with TODO comments saying "how can we know this&#8230;&#8203;?"), indicating this feature was originally planned but the detection mechanism was never solved.</p>
</div>
<div class="paragraph">
<p><strong>Effort</strong>: Medium effort for full automatic detection, smaller if using dialog-based approach</p>
</div>
<div class="paragraph">
<p><strong>Priority</strong>: MEDIUM-LOW (valuable feature but less critical than LSP enablement)</p>
</div>
<div class="paragraph">
<p><strong>Dependencies</strong>: None - can be developed independently</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_on_demand_incremental_architecture_for_lsp">15.5.2. On-Demand Incremental Architecture for LSP</h4>
<div class="paragraph">
<p><strong>Current Limitation</strong>: Stack memory accumulates symbol tables across all files forever. This works for batch cross-referencing but is incompatible with long-running LSP servers handling file edits.</p>
</div>
<div class="paragraph">
<p><strong>Vision</strong>: Enable true on-demand, per-file parsing suitable for LSP <code>textDocument/didChange</code> events.</p>
</div>
<div class="sect4">
<h5 id="_two_phase_architecture">Two-Phase Architecture</h5>
<div class="paragraph">
<p><strong>Phase 1: Batch Indexing</strong> (Current behavior, optimized)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>For each file in project:
    Parse file  populate refTab  discard stackMemory symbols

Result: refTab contains all references, stackMemory reset between files</pre>
</div>
</div>
<div class="paragraph">
<p><strong>Phase 2: LSP On-Demand</strong> (Future capability)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Load refTab from .cx files (persistent cache)

On textDocument/didChange(file):
    1. Remove old references for file from refTab
    2. Reparse file  update refTab with new references
    3. Reset stackMemory (symbols discarded, only refTab persists)
    4. Navigation uses refTab, not stackMemory symbols!</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_key_architectural_insights">Key Architectural Insights</h5>
<div class="ulist">
<ul>
<li>
<p><strong>Navigation uses refTab, not stackMemory</strong>: This is crucial - symbol lookup queries the reference table, not the ephemeral symbol structures</p>
</li>
<li>
<p><strong>stackMemory can be reset per-file</strong>: As long as refTab is updated first</p>
</li>
<li>
<p><strong>Incremental file updates become possible</strong>: Parse  update refTab  discard symbols</p>
</li>
<li>
<p><strong>Backward compatible</strong>: Batch mode continues to work exactly as before</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_memory_management_strategy">Memory Management Strategy</h5>
<div class="paragraph">
<p>After unified symbol database is complete, investigate:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Per-file stackMemory reset after populating refTab</p>
</li>
<li>
<p>Separation of navigation data (refTab - persistent) from parsing data (stackMemory - ephemeral)</p>
</li>
<li>
<p>Smart arena allocation strategies for long-running servers</p>
</li>
<li>
<p>Background garbage collection for unused symbol data</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Effort</strong>: Large foundational work with significant architectural implications</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_full_lsp_protocol_compliance">15.5.3. Full LSP Protocol Compliance</h4>
<div class="paragraph">
<p><strong>Dependencies</strong>: Unified symbol database, on-demand architecture</p>
</div>
<div class="paragraph">
<p><strong>Goals</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Complete implementation of core LSP features:</p>
<div class="ulist">
<ul>
<li>
<p><code>textDocument/definition</code>  (basic navigation exists)</p>
</li>
<li>
<p><code>textDocument/references</code>  (reference database exists)</p>
</li>
<li>
<p><code>textDocument/hover</code> (symbol information)</p>
</li>
<li>
<p><code>textDocument/completion</code>  (completion system exists)</p>
</li>
<li>
<p><code>textDocument/rename</code>  (refactoring engine exists)</p>
</li>
<li>
<p><code>textDocument/documentSymbol</code> (symbol outline)</p>
</li>
<li>
<p><code>textDocument/formatting</code> (if desired)</p>
</li>
<li>
<p><code>workspace/symbol</code> (project-wide symbol search)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Performance optimization for large projects:</p>
<div class="ulist">
<ul>
<li>
<p>Lazy loading of symbol data</p>
</li>
<li>
<p>Incremental parsing on file changes</p>
</li>
<li>
<p>Background indexing</p>
</li>
<li>
<p>Memory-mapped <code>.cx</code> file access</p>
</li>
</ul>
</div>
</li>
<li>
<p>Multi-workspace support</p>
</li>
<li>
<p>Configuration via LSP initialization options</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Effort</strong>: Large effort building on unified database architecture</p>
</div>
</div>
<div class="sect3">
<h4 id="_modern_ide_integration_showcase">15.5.4. Modern IDE Integration Showcase</h4>
<div class="paragraph">
<p><strong>Dependencies</strong>: Full LSP compliance</p>
</div>
<div class="paragraph">
<p><strong>Goals</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>VS Code Extension</strong>: Official c-xrefactory extension with feature parity to Emacs</p>
</li>
<li>
<p><strong>Vim/Neovim Support</strong>: LSP client configuration and documentation</p>
</li>
<li>
<p><strong>Other IDEs</strong>: Ensure LSP implementation works with CLion, Qt Creator, etc.</p>
</li>
<li>
<p><strong>Feature Demonstrations</strong>: Video tutorials showing refactoring capabilities</p>
</li>
<li>
<p><strong>Benchmark Comparisons</strong>: Performance vs. clangd, ccls for large C codebases</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Marketing</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Emphasize unique C-specific features (macro understanding, Yacc support)</p>
</li>
<li>
<p>Highlight safe refactoring capabilities</p>
</li>
<li>
<p>Target embedded systems and legacy C projects</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_migration_and_compatibility_strategy">15.6. Migration and Compatibility Strategy</h3>
<div class="sect3">
<h4 id="_backward_compatibility_guarantee">15.6.1. Backward Compatibility Guarantee</h4>
<div class="ulist">
<ul>
<li>
<p>Existing Emacs workflows will continue to work unchanged</p>
</li>
<li>
<p><code>.cx</code> file format remains compatible (or auto-migrates transparently)</p>
</li>
<li>
<p>Command-line interface preserved (though some commands may become no-ops)</p>
</li>
<li>
<p>All existing refactoring operations maintain behavior</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_deprecation_path">15.6.2. Deprecation Path</h4>
<div class="paragraph">
<p>When unified symbol database is complete (see <a href="../adr/0014-adopt-on-demand-parsing-architecture.md">ADR-0014</a>):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>-create</code> becomes optional (auto-triggers on first operation if needed)</p>
</li>
<li>
<p><code>-update</code> becomes automatic (modification time checking)</p>
</li>
<li>
<p>Mode flags (<code>FILE_BASED</code>, <code>ON_DEMAND</code>) deprecated internally</p>
</li>
<li>
<p>User-visible options remain for backward compatibility but may have no effect</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Design Principle</strong>: Zero breaking changes - existing workflows continue to work, new capabilities added transparently.</p>
</div>
</div>
<div class="sect3">
<h4 id="_testing_strategy">15.6.3. Testing Strategy</h4>
<div class="paragraph">
<p>Throughout all changes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Zero test regressions</strong> - 140+ test suite must pass</p>
</li>
<li>
<p><strong>Coverage maintenance</strong> - keep 85%+ coverage during refactoring</p>
</li>
<li>
<p><strong>Performance validation</strong> - no &gt;5% regression on large projects</p>
</li>
<li>
<p><strong>Integration testing</strong> - both Emacs and LSP workflows tested</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_success_metrics">15.7. Success Metrics</h3>
<div class="sect3">
<h4 id="_technical_metrics">15.7.1. Technical Metrics</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Test Coverage</strong>: Maintain 85%+</p>
</li>
<li>
<p><strong>Response Time</strong>: LSP <code>textDocument/definition</code> &lt; 100ms for 90th percentile</p>
</li>
<li>
<p><strong>Memory Efficiency</strong>: LSP server &lt; 500MB RAM for 1M LOC project</p>
</li>
<li>
<p><strong>Startup Time</strong>: Zero cold start delay (no mandatory <code>-create</code>)</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_adoption_metrics">15.7.2. Adoption Metrics</h4>
<div class="ulist">
<ul>
<li>
<p><strong>VS Code Extension</strong>: 1000+ downloads in first 6 months</p>
</li>
<li>
<p><strong>GitHub Stars</strong>: 500+ (currently ~150)</p>
</li>
<li>
<p><strong>Issue Response</strong>: &lt;48 hours median time to first response</p>
</li>
<li>
<p><strong>Documentation</strong>: 100% of features documented with examples</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_community_metrics">15.7.3. Community Metrics</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Contributors</strong>: 5+ active contributors beyond maintainer</p>
</li>
<li>
<p><strong>LSP Compatibility</strong>: Works with 3+ major IDEs (VS Code, Vim, CLion)</p>
</li>
<li>
<p><strong>User Satisfaction</strong>: Positive feedback on LSP integration</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_risk_management">15.8. Risk Management</h3>
<div class="sect3">
<h4 id="_technical_risks">15.8.1. Technical Risks</h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Risk</th>
<th class="tableblock halign-left valign-top">Likelihood</th>
<th class="tableblock halign-left valign-top">Mitigation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Breaking existing Emacs users</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Medium</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Maintain strict backward compatibility, extensive testing, staged rollout</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Performance regression</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Medium</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Profile before/after each change, performance test suite, optimization budget</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LSP protocol complexity</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Low</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Use existing battle-tested LSP libraries, focus on core features first</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Memory leaks in long-running server</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Medium</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Careful arena allocator design, memory profiling, leak detection tools</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Difficulty attracting contributors</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">High</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Excellent documentation, beginner-friendly issues, responsive maintainer</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Competing with clangd</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">High</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Focus on unique strengths: macro understanding, Yacc support, safe refactoring</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_mitigation_strategies">15.8.2. Mitigation Strategies</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Incremental delivery</strong>: Each phase provides standalone value</p>
</li>
<li>
<p><strong>Continuous testing</strong>: Never sacrifice test coverage for features</p>
</li>
<li>
<p><strong>User feedback loops</strong>: Early LSP alpha with select users</p>
</li>
<li>
<p><strong>Fallback options</strong>: Keep old code paths during transition</p>
</li>
<li>
<p><strong>Documentation first</strong>: Write the docs before the code</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_next_actions">15.9. Next Actions</h3>
<div class="paragraph">
<p>Priority tasks for immediate action:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Complete LSP handler wiring</strong></p>
<div class="ulist">
<ul>
<li>
<p>Map existing navigation functions to LSP requests</p>
</li>
<li>
<p>Test with real LSP client (VS Code)</p>
</li>
<li>
<p>Document any gaps</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Design LexemStream API</strong></p>
<div class="ulist">
<ul>
<li>
<p>Finalize interface based on proposal</p>
</li>
<li>
<p>Create initial implementation</p>
</li>
<li>
<p>Write unit tests</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Plan unified database refactoring</strong></p>
<div class="ulist">
<ul>
<li>
<p>Detailed design document</p>
</li>
<li>
<p>Identify all affected code paths</p>
</li>
<li>
<p>Prototype dependency-driven scanning</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Establish performance baseline</strong></p>
<div class="ulist">
<ul>
<li>
<p>Measure current Emacs operation speeds</p>
</li>
<li>
<p>Profile memory usage patterns</p>
</li>
<li>
<p>Document acceptable overhead budgets</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_conclusion">15.10. Conclusion</h3>
<div class="paragraph">
<p>The roadmap balances immediate user value (LSP features, bug fixes) with long-term architectural health (unified database, modular design). Each phase builds on previous work, with clear success metrics and risk mitigation strategies.</p>
</div>
<div class="paragraph">
<p>The end goal is a c-xrefactory that is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Zero-configuration</strong>: Works immediately on any C project</p>
</li>
<li>
<p><strong>Modern</strong>: First-class LSP support for all IDEs</p>
</li>
<li>
<p><strong>Powerful</strong>: Unique C-specific features unmatched by competitors</p>
</li>
<li>
<p><strong>Maintainable</strong>: Clean architecture enabling continued evolution</p>
</li>
<li>
<p><strong>Backward compatible</strong>: Existing Emacs users unaffected</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This transformation from a 1990s batch cross-referencer to a modern, on-demand LSP server is achievable through careful incremental refactoring guided by comprehensive tests.</p>
</div>
</div>
<div class="sect2">
<h3 id="_related_architecture_decision_records">15.11. Related Architecture Decision Records</h3>
<div class="paragraph">
<p>Key architectural decisions supporting this roadmap:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="../adr/0012-remove-lexem-stream-caching.md">ADR-0012: Remove Lexem Stream Caching</a> - Documents rationale for accepting 6.4 performance regression to enable refactoring</p>
</li>
<li>
<p><a href="../adr/0013-limited-extern-detection-in-c-files.md">ADR-0013: Limited Extern Detection</a> - Accepted limitation for archaic C patterns</p>
</li>
<li>
<p><a href="../adr/0014-adopt-on-demand-parsing-architecture.md">ADR-0014: On-Demand Parsing</a> - Core architectural shift from batch to on-demand</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See also:
* <a href="16-major-codebase-improvements.html">Chapter 16: Major Codebase Improvements</a> for detailed technical proposals
* <a href="../adr-process.md">ADR Process Guide</a> for complete decision history and ADR conventions</p>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This roadmap is a living document. As priorities shift and new insights emerge, it will be updated to reflect current understanding and goals.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_major_codebase_improvements">16. Major Codebase Improvements</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter documents larger architectural changes and improvements that would significantly enhance code quality, maintainability, and performance but require careful planning and implementation.</p>
</div>
<div class="paragraph">
<p>These are distinct from the user-facing refactorings documented in "Refactoring Recipes" - those are operations users apply to their code, while these are improvements to c-xrefactory&#8217;s own codebase.</p>
</div>
<div class="sect2">
<h3 id="_lexemstream_api_improvements">16.1. LexemStream API Improvements</h3>
<div class="paragraph">
<p><strong>Status</strong>: PARTIALLY COMPLETE (November 2025)</p>
</div>
<div class="sect3">
<h4 id="_problem_statement">16.1.1. Problem Statement</h4>
<div class="paragraph">
<p>The macro expansion and collation code (<code>collate()</code>, <code>replaceMacroArguments()</code>, etc.) in <code>src/yylex.c</code> suffers from <strong>pointer parameter proliferation</strong>, making it difficult to understand and maintain. Functions pass 5-6 separate parameters to track buffer state:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static char *collate(char *buffer, int *bufferSizeP, char **bufferWriteP,
                     char **leftHandLexemP, char **rightHandLexemP,
                     LexemStream *actualArgumentsInput);

static void copyRemainingLexems(char *buffer, int *bufferSize, char **bufferWriteP,
                                char *nextLexemP, char *endOfInputLexems);</code></pre>
</div>
</div>
<div class="paragraph">
<p>This creates several issues:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Hard to track which pointers point into which buffers</p>
</li>
<li>
<p>Manual size/capacity management scattered throughout code</p>
</li>
<li>
<p>Easy to make mistakes with pointer arithmetic</p>
</li>
<li>
<p>Functions have 6+ parameters just for buffer management</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_current_implementation_status_2025_11">16.1.2. Current Implementation Status (2025-11)</h4>
<div class="paragraph">
<p><strong>What&#8217;s been implemented:</strong></p>
</div>
<div class="paragraph">
<p> <strong>Basic API functions</strong> (<code>src/lexemstream.c</code>, <code>src/lexemstream.h</code>):
- <code>lexemStreamHasMore()</code> - Check if stream has more lexems
- <code>copyNextLexemFromStreamToStream()</code> - Copy one lexem between streams
- <code>skipExtraLexemInformationFor()</code> - Skip lexem metadata</p>
</div>
<div class="paragraph">
<p> <strong>Partially refactored functions</strong>:
- <code>copyRemainingLexems()</code> - Now uses <code>LexemStream</code> API (yylex.c:1794)
- <code>replaceMacroArguments()</code> - Refactored to use <code>LexemStream</code> (commit 73239531)
- <code>expandMacroArgument()</code> - Takes <code>LexemStream *argumentInput</code> (yylex.c:1708)
- <code>resolveMacroArgumentAsLeftOperand()</code> - Partially uses API (commit 06e7e17e)</p>
</div>
<div class="paragraph">
<p><strong>What remains to be done:</strong></p>
</div>
<div class="paragraph">
<p> <strong>Extended LexemStream structure</strong> - No ownership fields yet:
- Missing: <code>allocatedSize</code>, <code>ownsBuffer</code> fields
- Structure still lightweight (5 fields only)</p>
</div>
<div class="paragraph">
<p> <strong>Full API not created</strong> - Missing functions:
- Creation: <code>lexInputCreateOwned()</code>, <code>lexInputCreateView()</code>
- Capacity: <code>lexInputEnsureCapacity()</code>, <code>lexInputReallocIfNeeded()</code>
- Writing: <code>lexInputPutLexemCode()</code>, <code>lexInputAppendBytes()</code>
- Cleanup: <code>lexInputFree()</code></p>
</div>
<div class="paragraph">
<p> <strong>Major functions still using old style</strong>:
- <code>collate()</code> - Still has 5 pointer parameters (yylex.c:2022)
- Several helper functions: <code>collate_id_id()</code>, <code>collate_const_const()</code>, etc.</p>
</div>
<div class="paragraph">
<p><strong>Progress estimate</strong>: ~40% complete (basic API exists, some refactoring done, but major work remains)</p>
</div>
</div>
<div class="sect3">
<h4 id="_current_architecture">16.1.3. Current Architecture</h4>
<div class="sect4">
<h5 id="_three_representations_of_lexem_streams">Three representations of lexem streams</h5>
<div class="paragraph">
<p>The codebase currently uses three different ways to represent lexem streams:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><strong>LexemBuffer</strong> (structured, file-oriented)</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Fixed-size embedded array: <code>char lexemStream[LEXEM_BUFFER_SIZE]</code></p>
</li>
<li>
<p>Metadata: <code>begin</code>, <code>read</code>, <code>write</code>, <code>position</code>, <code>fileOffset</code>, <code>backpatchPointer</code></p>
</li>
<li>
<p>Used for lexing from files/editor buffers</p>
</li>
<li>
<p>Full API for manipulation: <code>putLexemCode()</code>, <code>getLexemCode()</code>, etc.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><strong>LexemStream</strong> (lightweight, pointer-based)</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Just 3 pointers + metadata: <code>begin</code>, <code>read</code>, <code>write</code>, <code>macroName</code>, <code>inputType</code></p>
</li>
<li>
<p>Points to external memory (doesn&#8217;t own it)</p>
</li>
<li>
<p>Used for macro expansion pipelines</p>
</li>
<li>
<p><strong>NO manipulation API - just raw pointer access</strong></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><strong>MacroBody</strong> (persistent storage)</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Pointer + length: <code>char *body</code>, <code>int size</code></p>
</li>
<li>
<p>Used for stored macro definitions</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_lexemstream_buffer_sources">LexemStream buffer sources</h5>
<div class="paragraph">
<p>LexemStream can point to 5 different memory sources:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>LexemBuffer.lexemStream</code> - Fixed array in file descriptor</p>
</li>
<li>
<p><code>ppmAlloc()</code> - Preprocessor macro memory (dynamic)</p>
</li>
<li>
<p><code>mbmAlloc()</code> - Macro body memory (dynamic)</p>
</li>
<li>
<p><code>NULL</code> - Empty/missing arguments</p>
</li>
<li>
<p>External buffers from various sources</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_proposed_solution">16.1.4. Proposed Solution</h4>
<div class="sect4">
<h5 id="_add_lexemstream_manipulation_api">Add LexemStream manipulation API</h5>
<div class="paragraph">
<p>Currently, LexemStream has <strong>zero manipulation functions</strong>. All operations are done via raw pointer manipulation. We need to add an API similar to LexemBuffer.</p>
</div>
</div>
<div class="sect4">
<h5 id="_phase_1_extend_lexemstream_structure">Phase 1: Extend LexemStream structure</h5>
<div class="paragraph">
<p>Add optional buffer management fields:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct {
    char *begin;        // Start of buffer
    char *read;         // Current read position
    char *write;        // Current write position (= end for read-only)
    char *macroName;    // Name of macro this input represents
    InputType inputType;
    // NEW fields:
    int allocatedSize;  // Total allocated size (0 if not owned/unknown)
    bool ownsBuffer;    // Whether this LexemStream should manage/free the buffer
} LexemStream;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Alternative considered but rejected: Create separate <code>WritableLexemStream</code> type. Pro: Cleaner separation of read vs write. Con: Yet another type, conversion overhead, more complex API.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_phase_2_create_manipulation_api">Phase 2: Create manipulation API</h5>
<div class="paragraph">
<p>New file: <code>src/lexinput.c</code> and extend <code>src/input.h</code></p>
</div>
<div class="sect5">
<h6 id="_core_buffer_management">Core buffer management</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">// Creation
LexemStream lexInputCreateOwned(int initialSize);     // Allocates managed buffer
LexemStream lexInputCreateView(char *begin, char *end); // Read-only view

// Capacity management
void lexInputEnsureCapacity(LexemStream *input, int additionalBytes);
void lexInputReallocIfNeeded(LexemStream *input, int needed);
int lexInputRemainingCapacity(LexemStream *input);

// Reading (advance read pointer)
LexemCode lexInputGetLexem(LexemStream *input);
LexemCode lexInputPeekLexem(LexemStream *input);  // Don't advance
bool lexInputHasMore(LexemStream *input);          // read &lt; write
void lexInputSkipLexem(LexemStream *input);        // Skip current lexem

// Writing (advance write pointer)
void lexInputPutLexemCode(LexemStream *output, LexemCode lexem);
void lexInputPutLexemPosition(LexemStream *output, Position pos);
void lexInputAppendBytes(LexemStream *dest, char *src, int len);
void lexInputCopyLexem(LexemStream *dest, LexemStream *src); // Copy one lexem from src to dest

// Cleanup
void lexInputFree(LexemStream *input);  // Only frees if ownsBuffer=true</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_phase_3_refactor_functions_to_use_lexemstream_api">Phase 3: Refactor functions to use LexemStream API</h5>
<div class="sect5">
<h6 id="_example_collate_before">Example: collate() before</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static char *collate(char *buffer,              // Destination buffer
                     int *bufferSizeP,          // Destination allocated size
                     char **bufferWriteP,       // Current write position
                     char **leftHandLexemP,     // Left operand read position
                     char **rightHandLexemP,    // Right operand read position
                     LexemStream *actualArgumentsInput)  // Source arguments
{
    // Manual buffer management scattered throughout:
    *bufferSizeP = expandPreprocessorBufferIfOverflow(buffer, *bufferSizeP, *bufferWriteP);

    // Manual pointer arithmetic:
    int lexemLength = nextInputLexemP - lexemStart;
    memcpy(*bufferWriteP, lexemStart, lexemLength);
    *bufferWriteP += lexemLength;

    // Complex state tracking:
    char *lhs = *leftHandLexemP;
    char *endOfLexems = NULL;
    // ... many lines of pointer manipulation
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_example_collate_after">Example: collate() after</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static void collate(LexemStream *output,           // Destination (manages its own buffer)
                    LexemStream *leftOperand,      // Left operand (with read position)
                    LexemStream *rightOperand,     // Right operand (with read position)
                    LexemStream *actualArgumentsInput)
{
    // Clean, high-level operations:
    lexInputEnsureCapacity(output, estimatedSize);

    // Copy operations are explicit and clear:
    lexInputCopyLexem(output, leftOperand);
    lexInputCopyLexem(output, rightOperand);

    // State is encapsulated in LexemStream structures
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_functions_to_refactor_priority_order">Functions to refactor (priority order)</h6>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>collate()</strong> - Most complex, biggest win (yylex.c:1515)</p>
</li>
<li>
<p><strong>copyRemainingLexems()</strong> - Used by collate (yylex.c:1450)</p>
</li>
<li>
<p><strong>resolveMacroArgumentAsLeftOperand()</strong> - Complex pointer tracking (yylex.c:1465)</p>
</li>
<li>
<p><strong>replaceMacroArguments()</strong> - Many buffer operations (yylex.c:1717)</p>
</li>
<li>
<p><strong>expandMacroArgument()</strong> - Buffer management (yylex.c:1362)</p>
</li>
<li>
<p><strong>createMacroBodyAsNewInput()</strong> - Multiple buffers (yylex.c:1780)</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_benefits">16.1.5. Benefits</h4>
<div class="sect4">
<h5 id="_code_clarity">Code clarity</h5>
<div class="ulist">
<ul>
<li>
<p>Functions have 2-3 parameters instead of 6+</p>
</li>
<li>
<p>Clear ownership and boundaries</p>
</li>
<li>
<p>Self-documenting code (LexemStream instead of 3 raw pointers)</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_maintainability">Maintainability</h5>
<div class="ulist">
<ul>
<li>
<p>Centralized buffer management logic</p>
</li>
<li>
<p>Easier to add bounds checking</p>
</li>
<li>
<p>Less error-prone</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_consistency">Consistency</h5>
<div class="ulist">
<ul>
<li>
<p>Similar philosophy to LexemBuffer</p>
</li>
<li>
<p>Uniform API for lexem stream operations</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_implementation_strategy">16.1.6. Implementation Strategy</h4>
<div class="dlist">
<dl>
<dt class="hdlist1">Step 1: Add new fields to LexemStream (backward compatible)</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Initialize <code>allocatedSize = 0</code> and <code>ownsBuffer = false</code> for all existing uses</p>
</li>
<li>
<p>No functional changes yet</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Step 2: Create lexinput.c with basic API</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Implement core functions: create, ensure capacity, append, copy</p>
</li>
<li>
<p>Add unit tests</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Step 3: Refactor one function as proof of concept</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Start with <code>copyRemainingLexems()</code> (simplest)</p>
</li>
<li>
<p>Validate approach works</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Step 4: Refactor remaining functions</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Work through priority list</p>
</li>
<li>
<p>Update call sites incrementally</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Step 5: Cleanup</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Remove old helper functions if no longer needed</p>
</li>
<li>
<p>Update documentation</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_risks_and_mitigation">16.1.7. Risks and Mitigation</h4>
<div class="sect4">
<h5 id="_risk_breaking_existing_code">Risk: Breaking existing code</h5>
<div class="paragraph">
<p><strong>Mitigation:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Make LexemStream changes backward compatible</p>
</li>
<li>
<p>Add new fields with safe defaults</p>
</li>
<li>
<p>Refactor incrementally, one function at a time</p>
</li>
<li>
<p>Run full test suite after each change</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_risk_performance_regression">Risk: Performance regression</h5>
<div class="paragraph">
<p><strong>Mitigation:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Keep buffer operations inline where critical</p>
</li>
<li>
<p>Profile before/after</p>
</li>
<li>
<p>The current code already does realloc, just manually</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_risk_memory_leaks_from_ownsbuffer_confusion">Risk: Memory leaks from ownsBuffer confusion</h5>
<div class="paragraph">
<p><strong>Mitigation:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Clear ownership semantics in documentation</p>
</li>
<li>
<p>Consider using explicit create/destroy pairs</p>
</li>
<li>
<p>Add assertions for debugging</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_notes">16.1.8. Notes</h4>
<div class="sect4">
<h5 id="_why_not_unify_with_lexembuffer">Why not unify with LexemBuffer?</h5>
<div class="paragraph">
<p>LexemBuffer and LexemStream serve different purposes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>LexemBuffer</strong>: Heavy, file-oriented, owns fixed-size array, lots of metadata</p>
</li>
<li>
<p><strong>LexemStream</strong>: Lightweight, flexible views, points to various sources</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Trying to unify them would make both worse. The real issue is LexemStream lacks manipulation functions, not that two types exist.</p>
</div>
</div>
<div class="sect4">
<h5 id="_backward_compatibility">Backward compatibility</h5>
<div class="paragraph">
<p>The proposed changes are designed to be backward compatible:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>New fields default to "not owned, size unknown" (0, false)</p>
</li>
<li>
<p>Existing code that creates LexemStream with <code>makeLexemStream()</code> continues to work</p>
</li>
<li>
<p>Only new code uses the enhanced API</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_open_questions">16.1.9. Open Questions</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Should <code>lexInputEnsureCapacity()</code> use ppmAlloc or mbmAlloc?</p>
<div class="ulist">
<ul>
<li>
<p>Probably depends on context - may need separate functions or a memory source parameter</p>
</li>
</ul>
</div>
</li>
<li>
<p>How to handle the transition from raw pointers to LexemStream?</p>
<div class="ulist">
<ul>
<li>
<p>Some functions receive raw pointers from outside (e.g., from MacroBody.body)</p>
</li>
<li>
<p>May need wrapper functions to create temporary LexemStream views</p>
</li>
</ul>
</div>
</li>
<li>
<p>Should we add debug assertions for bounds checking?</p>
<div class="ulist">
<ul>
<li>
<p>Would help catch errors during development</p>
</li>
<li>
<p>Could be compiled out in production</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_references">16.1.10. References</h4>
<div class="ulist">
<ul>
<li>
<p>Current code: <code>src/yylex.c</code> lines 1362-1823 (macro expansion)</p>
</li>
<li>
<p>LexemBuffer API: <code>src/lexembuffer.h</code> and <code>src/lexembuffer.c</code></p>
</li>
<li>
<p>Current LexemStream: <code>src/input.h</code> and <code>src/input.c</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_related_issues">16.1.11. Related Issues</h4>
<div class="paragraph">
<p>This refactoring addresses the root cause identified in the discussion about replacing the malloc-based macro body memory system (commit e1d506f7). The memory tracking issues stem from the complexity of managing multiple pointer parameters across function boundaries.</p>
</div>
<hr>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
When implementing this refactoring, consider starting with unit tests for the new API functions before refactoring existing code. This will help validate the design and provide safety during migration.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="clean-persistence-store">16.2. Clean Persistence Store Abstraction</h3>
<div class="sect3">
<h4 id="_problem_statement_2">16.2.1. Problem Statement</h4>
<div class="paragraph">
<p>The <code>cxfile</code> module currently mixes multiple responsibilities that should be separated:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Persistence implementation</strong> (reading/writing .cx files)  Correct level</p>
</li>
<li>
<p><strong>Search and filter operations</strong> (matching search strings)  Wrong level</p>
</li>
<li>
<p><strong>Operation-specific loading</strong> (menu creation, macro completion, unused detection)  Too specific</p>
</li>
<li>
<p><strong>Treated as source of truth</strong> (when it should be just a cache)  Architectural confusion</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This mixing creates tight coupling, makes testing difficult, and prevents future architectural improvements (like LSP integration or alternative storage backends).</p>
</div>
</div>
<div class="sect3">
<h4 id="_architectural_confusion_in_memory_vs_persistence">16.2.2. Architectural Confusion: In-Memory vs Persistence</h4>
<div class="paragraph">
<p>The current code conflates two distinct concepts:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><strong>Reference Database</strong> (Smart Layer - Source of Truth)</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><strong>Always in-memory</strong>: The <code>referenceableItemTable</code> hash table</p>
</li>
<li>
<p>Answers queries fast from RAM</p>
</li>
<li>
<p>Decides when to load from persistence</p>
</li>
<li>
<p>Decides when to save to persistence</p>
</li>
<li>
<p>Manages invalidation and staleness</p>
</li>
<li>
<p><strong>This is the actual database</strong></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><strong>Persistence Store</strong> (Dumb Layer - Durable Cache)</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><strong>Always on disk/database</strong>: The <code>.cx</code> files (or future SQLite, etc.)</p>
</li>
<li>
<p>Just knows how to save/load a specific format</p>
</li>
<li>
<p>Has NO in-memory state of its own</p>
</li>
<li>
<p>No business logic, no searching, no filtering</p>
</li>
<li>
<p><strong>This is just the storage mechanism</strong></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The persistence layer is <strong>always about durable storage</strong> that survives restarts. "In-memory persistence" is a contradiction - persistence means surviving across sessions.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_current_architecture_problems">16.2.3. Current Architecture Problems</h4>
<div class="sect4">
<h5 id="_mixed_abstraction_levels">Mixed Abstraction Levels</h5>
<div class="paragraph">
<p>The current <code>cxfile.h</code> public interface exposes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">// Operation-specific scanning (too high-level for storage)
extern void scanReferencesToCreateMenu(char *symbolName);
extern void scanForMacroUsage(char *symbolName);
extern void scanForGlobalUnused(char *cxrefFileName);
extern void scanForSearch(char *cxrefFileName);

// Implementation details leaked (partitioning is internal)
extern int cxFileHashNumberForSymbol(char *symbol);
extern void searchSymbolCheckReference(ReferenceableItem *item, Reference *ref);

// Generic API (already identified as "Abstract API")
extern bool loadFileNumbersFromStore(void);
extern void ensureReferencesAreLoadedFor(char *symbolName);
extern void saveReferencesToStore(bool updating, char *name);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Problems:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Four <code>scan*</code> functions</strong>: Encode specific use cases (menu, macro, unused, search) instead of providing generic operations</p>
</li>
<li>
<p><strong>Implementation details exposed</strong>: <code>cxFileHashNumberForSymbol()</code> is a partitioning optimization that shouldn&#8217;t be public</p>
</li>
<li>
<p><strong>Search logic in storage</strong>: <code>searchSymbolCheckReference()</code> mixes filtering with persistence</p>
</li>
<li>
<p><strong>Side-effect heavy</strong>: All functions mutate global <code>referenceableItemTable</code> implicitly</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_tight_coupling_to_use_cases">Tight Coupling to Use Cases</h5>
<div class="paragraph">
<p>Currently <code>cxfile.c</code> knows about:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Browser menus (<code>scanReferencesToCreateMenu</code>)</p>
</li>
<li>
<p>Macro completion (<code>scanForMacroUsage</code>)</p>
</li>
<li>
<p>Unused symbol detection (<code>scanForGlobalUnused</code>)</p>
</li>
<li>
<p>Symbol search (<code>scanForSearch</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A persistence layer shouldn&#8217;t know about any of these! These are <strong>clients</strong> of storage, not responsibilities of storage.</p>
</div>
</div>
<div class="sect4">
<h5 id="_wrong_source_of_truth">Wrong Source of Truth</h5>
<div class="paragraph">
<p>From the navigation debugging (see Insights chapter), we discovered:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">// In cxref.c - loads FROM DISK directly
scanReferencesToCreateMenu(symbolName);  // Treats .cx files as truth</code></pre>
</div>
</div>
<div class="paragraph">
<p>This bypasses the in-memory <code>referenceableItemTable</code>, treating disk as authoritative. But the <strong>actual truth</strong> is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>referenceableItemTable = Disk state (.cx files) + Preloaded editor buffers</pre>
</div>
</div>
<div class="paragraph">
<p>The disk is just a <strong>cache</strong> of the last saved state, not the current truth.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_proposed_architecture">16.2.4. Proposed Architecture</h4>
<div class="sect4">
<h5 id="_two_layer_design">Two-Layer Design</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">
  Reference Database (Smart Layer)                
  Source of Truth: referenceableItemTable (RAM)   
                                                  
  - Fast in-memory queries                        
  - Knows what's current vs stale                 
  - Handles invalidation/refresh                  
  - Decides when to load/save                     
  - Unified interface for all clients             

                      
        (only when loading/saving needed)
                      

  Persistence Store (Dumb Layer)                  
  Durable Cache: .cx files on disk                
                                                  
  - Just save/load binary format                  
  - No business logic                             
  - No in-memory state                            
  - Can be swapped (SQLite, Protobuf, etc.)       
</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_clean_persistence_store_interface">Clean Persistence Store Interface</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">// persistence_store.h - Pure storage operations
#ifndef PERSISTENCE_STORE_H_INCLUDED
#define PERSISTENCE_STORE_H_INCLUDED

#include "referenceableitem.h"

/* ============================================
 * Store Lifecycle
 * ============================================ */

// Load metadata (file numbers, timestamps)
extern bool persistenceLoadMetadata(void);

// Persist all references to durable storage
extern void persistenceSaveAll(bool updating, char *location);

/* ============================================
 * Reference Loading (into referenceableItemTable)
 * ============================================ */

// Load references for specific symbol into memory table
// Returns true if symbol found in storage
extern bool persistenceLoadSymbol(char *symbolName);

/* ============================================
 * Bulk Scanning
 * ============================================ */

// Scan entire storage, calling visitor for each reference
// Visitor decides what to do with each reference
typedef void (*PersistenceVisitor)(ReferenceableItem *item,
                                    Reference *ref,
                                    void *context);
extern void persistenceScanAll(PersistenceVisitor visitor, void *context);

#endif</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_reference_database_interface">Reference Database Interface</h5>
<div class="paragraph">
<p>This layer provides the "smart" operations that clients actually need:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">// reference_database.h - Smart operations (initially thin wrapper)
#ifndef REFERENCE_DATABASE_H_INCLUDED
#define REFERENCE_DATABASE_H_INCLUDED

#include "referenceableitem.h"
#include "position.h"

// Initialize the in-memory reference database
extern bool refDbInitialize(void);

// Lookup symbol in the in-memory table
// Automatically loads from persistence if not in memory
extern ReferenceableItem* refDbLookupSymbol(char *name);

// Get all references for a symbol
// Ensures data is loaded and current
extern Reference* refDbGetReferences(char *symbolName);

// Mark a file's references as stale (needs reload)
extern void refDbInvalidateFile(int fileNumber);

// Persist the current in-memory state
extern void refDbSave(bool updating, char *location);

#endif</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This interface starts simple but is where the <strong>Unified Symbol Database</strong> refactoring (next section) will add smart on-demand loading, dependency tracking, and invalidation logic.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_migration_strategy">16.2.5. Migration Strategy</h4>
<div class="sect4">
<h5 id="_phase_1_create_clean_boundaries_no_behavior_change">Phase 1: Create Clean Boundaries (No Behavior Change)</h5>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Rename <code>cxfile.h</code>  <code>cxfile_internal.h</code> (implementation detail)</p>
</li>
<li>
<p>Create <code>persistence_store.h</code> with clean interface</p>
</li>
<li>
<p>Create <code>persistence_store.c</code> that delegates to <code>cxfile_*</code> functions</p>
</li>
<li>
<p>Update all callers to use <code>persistence_store.h</code> instead of <code>cxfile.h</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Result: Same behavior, cleaner names, clear intent.</p>
</div>
</div>
<div class="sect4">
<h5 id="_phase_2_extract_operation_logic">Phase 2: Extract Operation Logic</h5>
<div class="paragraph">
<p>Move operation-specific logic OUT of persistence layer:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><strong>Search Logic</strong></dt>
<dd>
<p><code>searchSymbolCheckReference()</code>  new <code>search.c</code> module</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">// Before: In cxfile.c (WRONG LEVEL)
void searchSymbolCheckReference(ReferenceableItem *item, Reference *ref) {
    if (searchStringMatch(...)) {
        reportMatch(item, ref);
    }
}

// After: In search.c (RIGHT LEVEL)
void searchForSymbol(char *pattern) {
    persistenceScanAll(checkSearchMatch, pattern);
}

static void checkSearchMatch(ReferenceableItem *item, Reference *ref, void *ctx) {
    if (searchStringMatch(item-&gt;linkName, (char *)ctx)) {
        reportMatch(item, ref);
    }
}</code></pre>
</div>
</div>
</dd>
<dt class="hdlist1"><strong>Unused Detection</strong></dt>
<dd>
<p>Extract from <code>cxfile.c</code> to <code>refactorings.c</code> or new <code>analysis.c</code></p>
</dd>
<dt class="hdlist1"><strong>Menu Creation</strong></dt>
<dd>
<p>Keep in <code>cxref.c</code> but use clean <code>refDbGetReferences()</code> instead of direct disk scanning</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_phase_3_hide_implementation_details">Phase 3: Hide Implementation Details</h5>
<div class="paragraph">
<p>Make these functions <code>static</code> (internal to cxfile.c):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>cxFileHashNumberForSymbol()</code> - partitioning is implementation detail</p>
</li>
<li>
<p><code>searchSymbolCheckReference()</code> - moved to search module</p>
</li>
<li>
<p>All internal scanning logic</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_phase_4_consolidate_scanning_functions">Phase 4: Consolidate Scanning Functions</h5>
<div class="paragraph">
<p>Replace four specific scanners with generic visitor pattern:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Old (Use-Case Specific)</th>
<th class="tableblock halign-left valign-top">New (Generic)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scanReferencesToCreateMenu(name)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>refDbGetReferences(name)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scanForMacroUsage(name)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>refDbGetReferences(name)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scanForGlobalUnused(location)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>persistenceScanAll(checkUnused, ctx)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scanForSearch(location)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>persistenceScanAll(checkMatch, pattern)</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_benefits_2">16.2.6. Benefits</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><strong>Testability</strong></dt>
<dd>
<p>Can mock <code>persistence_store.h</code> for testing navigation without .cx files</p>
</dd>
<dt class="hdlist1"><strong>Future Storage Backends</strong></dt>
<dd>
<p>Could implement with SQLite, in-memory testing mock, or different binary format</p>
</dd>
<dt class="hdlist1"><strong>Clear Boundaries</strong></dt>
<dd>
<p>Storage vs search vs navigation clearly separated</p>
</dd>
<dt class="hdlist1"><strong>Simpler Interface</strong></dt>
<dd>
<p>4 functions instead of 9, clearer responsibilities</p>
</dd>
<dt class="hdlist1"><strong>Less Coupling</strong></dt>
<dd>
<p>Parsing code doesn&#8217;t call storage directly, goes through reference database</p>
</dd>
<dt class="hdlist1"><strong>LSP Readiness</strong></dt>
<dd>
<p>Reference database layer is where LSP <code>textDocument/didChange</code> integration will live</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_relationship_to_unified_symbol_database">16.2.7. Relationship to Unified Symbol Database</h4>
<div class="paragraph">
<p>This refactoring is the <strong>foundation</strong> for the larger <strong>Unified Symbol Database Architecture</strong> (next section):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Clean persistence layer</strong> enables swapping storage backends without affecting clients</p>
</li>
<li>
<p><strong>Reference database layer</strong> is where smart on-demand loading logic will live</p>
</li>
<li>
<p><strong>Separation of concerns</strong> makes the unified architecture clearer</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Migration path:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>First: Clean up persistence (this refactoring)</p>
</li>
<li>
<p>Then: Add smart on-demand logic to reference database (next refactoring)</p>
</li>
<li>
<p>Finally: Both Emacs and LSP use same unified code path</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_implementation_checklist">16.2.8. Implementation Checklist</h4>
<div class="ulist checklist">
<ul class="checklist">
<li>
<p><i class="fa fa-square-o"></i> Create <code>persistence_store.h</code> with proposed interface</p>
</li>
<li>
<p><i class="fa fa-square-o"></i> Create <code>persistence_store.c</code> delegating to cxfile</p>
</li>
<li>
<p><i class="fa fa-square-o"></i> Rename <code>cxfile.h</code>  <code>cxfile_internal.h</code></p>
</li>
<li>
<p><i class="fa fa-square-o"></i> Create <code>reference_database.h</code> (thin wrapper initially)</p>
</li>
<li>
<p><i class="fa fa-square-o"></i> Create <code>reference_database.c</code> delegating to persistence</p>
</li>
<li>
<p><i class="fa fa-square-o"></i> Update all callers to use new interfaces</p>
</li>
<li>
<p><i class="fa fa-square-o"></i> Move search logic from cxfile to search module</p>
</li>
<li>
<p><i class="fa fa-square-o"></i> Move unused detection logic to appropriate module</p>
</li>
<li>
<p><i class="fa fa-square-o"></i> Make <code>cxFileHashNumberForSymbol</code> static</p>
</li>
<li>
<p><i class="fa fa-square-o"></i> Make <code>searchSymbolCheckReference</code> static or remove</p>
</li>
<li>
<p><i class="fa fa-square-o"></i> Add unit tests for both interfaces</p>
</li>
<li>
<p><i class="fa fa-square-o"></i> Update documentation</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_references_2">16.2.9. References</h4>
<div class="ulist">
<ul>
<li>
<p>Current implementation: <code>src/cxfile.c</code>, <code>src/cxfile.h</code></p>
</li>
<li>
<p>In-memory table: <code>src/reftab.c</code> (referenceableItemTable)</p>
</li>
<li>
<p>Navigation architecture: Chapter 17 (Insights) - Navigation Architecture section</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unified-symbol-database">16.3. Unified Symbol Database Architecture</h3>
<div class="sect3">
<h4 id="_problem_statement_3">16.3.1. Problem Statement</h4>
<div class="paragraph">
<p>The current symbol database has evolved from a batch cross-referencer (like <code>ctags</code>) with artificial distinctions between "file-based" and "on-demand" modes. This creates:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Mode complexity</strong>: Different code paths for Emacs vs LSP clients</p>
</li>
<li>
<p><strong>Cold start problems</strong>: Requires upfront <code>-create</code> operation before use</p>
</li>
<li>
<p><strong>Manual updates</strong>: Users must remember to run <code>-update</code> after changes</p>
</li>
<li>
<p><strong>Inconsistent behavior</strong>: Different modes provide different guarantees</p>
</li>
<li>
<p><strong>Maintenance overhead</strong>: Multiple implementations to maintain and test</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_current_architecture_limitations">16.3.2. Current Architecture Limitations</h4>
<div class="paragraph">
<p>The existing system distinguishes between:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Aspect</th>
<th class="tableblock halign-left valign-top">File-Based Mode</th>
<th class="tableblock halign-left valign-top">On-Demand Mode</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Cold Start</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Requires <code>-create</code> first</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parse file immediately</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Warm Queries</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">O(1) hash lookup</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">O(file_size) parsing</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Memory Usage</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Low (streaming)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">High (in-memory cache)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Incremental Updates</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Smart file tracking</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Per-file invalidation</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Multi-project</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Separate databases</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Workspace-scoped</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_proposed_solution_2">16.3.3. Proposed Solution</h4>
<div class="sect4">
<h5 id="_core_insight_unified_on_demand_architecture">Core Insight: Unified On-Demand Architecture</h5>
<div class="paragraph">
<p>Both Emacs and LSP clients want the same thing: <strong>up-to-date symbol and reference information</strong>. The distinction between "file-based" and "on-demand" modes is artificial complexity. Instead, c-xrefactory should provide a unified interface that:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Always ensures information is current</strong> using existing dependency tracking</p>
</li>
<li>
<p><strong>Scans incrementally</strong> only what&#8217;s needed, when needed</p>
</li>
<li>
<p><strong>Uses <code>.cx</code> files as persistent cache</strong> for optimization</p>
</li>
<li>
<p><strong>Eliminates cold start problems</strong> by avoiding upfront full-project scanning</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_simplified_interface_design">Simplified Interface Design</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct SymbolDatabase SymbolDatabase;

typedef struct {
    // Unified operations for any client (Emacs or LSP)
    Symbol* (*lookupSymbol)(SymbolDatabase* db, const char* name, Position pos);
    ReferenceList* (*getReferences)(SymbolDatabase* db, const char* name, Position pos);
    ReferenceList* (*getOccurrences)(SymbolDatabase* db, const char* name, Position pos);

    // All complexity hidden in implementation:
    // - File modification checking (existing: checkFileModifiedTime)
    // - Include dependency tracking (existing: cachedIncludedFilePass)
    // - Incremental scanning (existing: makeIncludeClosureOfFilesToUpdate)
    // - Persistent caching (existing: .cx file system)
} SymbolDatabaseOperations;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_implementation_strategy_smart_on_demand">Implementation Strategy: Smart On-Demand</h5>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
This refactoring builds on the <strong>Clean Persistence Store</strong> foundation (previous section). The smart logic lives in the <strong>in-memory reference database layer</strong>, while <code>.cx</code> files remain a <strong>durable cache</strong> for persistence.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The implementation leverages <strong>existing sophisticated logic</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">Symbol* lookupSymbol(const char* name, Position pos) {
    // 1. Check if in-memory table has current information
    if (refTableHasCurrent(name, pos)) {
        return lookupInMemoryTable(name, pos);  // Answer from RAM
    }

    // 2. Load from persistence if not in memory
    if (!refTableHasSymbol(name)) {
        persistenceLoadSymbol(name);  // Load .cx into referenceableItemTable
    }

    // 3. Check if loaded data is stale (file modified since load)
    if (refTableDataIsStale(name, pos)) {
        // Use existing dependency tracking to scan minimal set
        FileList* filesToScan = calculateDependencyClosure(pos.file);
        for (FileItem* file : filesToScan) {
            if (checkFileModifiedTime(file-&gt;fileNumber)) {
                parseFileAndUpdateTable(file);  // Reparse into memory
            }
        }
    }

    // 4. Answer from in-memory table (now guaranteed current)
    return lookupInMemoryTable(name, pos);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Architectural Layers:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre>Query  Reference Database (in-memory, smart)  Persistence Store (disk, dumb)
                                                 
        Always answers from RAM                   Only for load/save</pre>
</div>
</div>
<div class="paragraph">
<p><strong>Key Benefits:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>No artificial modes</strong> - same code path for all clients</p>
</li>
<li>
<p><strong>No cold start</strong> - first lookup triggers minimal necessary scanning</p>
</li>
<li>
<p><strong>Incremental by design</strong> - only scans files that need updating</p>
</li>
<li>
<p><strong>In-memory speed</strong> - all queries answered from RAM (referenceableItemTable)</p>
</li>
<li>
<p><strong>Durable cache</strong> - <code>.cx</code> files persist state across sessions</p>
</li>
<li>
<p><strong>Existing logic reuse</strong> - leverages proven dependency tracking system</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_legacy_architecture_recognition">Legacy Architecture Recognition</h5>
<div class="paragraph">
<p>c-xrefactory evolved from a <strong>batch cross-referencer</strong> (like <code>ctags</code>) and was enhanced for real-time use:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Legacy batch workflow:
c-xref -create project.c     # Full scan, build .cx database
c-xref -update modified.c    # Incremental update
c-xref -olcxpush symbol      # Query pre-built database

# Unified approach:
c-xref -server               # Start server, scan on-demand as needed
c-xref -lsp                  # Same logic, different protocol</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The <code>.cx</code> files are a <strong>durable cache</strong> that persists the in-memory <code>referenceableItemTable</code> between sessions. They are an optimization, not the database itself. The actual database is always in RAM.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_implementation_plan">16.3.4. Implementation Plan</h4>
<div class="sect4">
<h5 id="_phase_1_interface_unification">Phase 1: Interface Unification</h5>
<div class="ulist">
<ul>
<li>
<p>Create unified <code>SymbolDatabase</code> interface</p>
</li>
<li>
<p>Wrap existing logic in smart on-demand implementation</p>
</li>
<li>
<p>Replace explicit <code>-create</code>/<code>-update</code> commands with automatic dependency checking</p>
</li>
<li>
<p>Both Emacs and LSP use same code path</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_phase_2_optimization">Phase 2: Optimization</h5>
<div class="ulist">
<ul>
<li>
<p>Enhance existing dependency tracking for finer-grained invalidation</p>
</li>
<li>
<p>Optimize in-memory caching strategies</p>
</li>
<li>
<p>Background <code>.cx</code> file maintenance for long-running sessions</p>
</li>
<li>
<p>Performance tuning for large codebases</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_benefits_3">16.3.5. Benefits</h4>
<div class="sect4">
<h5 id="_architectural_simplification">Architectural Simplification</h5>
<div class="ulist">
<ul>
<li>
<p><strong>Single code path</strong> for both Emacs and LSP clients - eliminates maintenance overhead</p>
</li>
<li>
<p><strong>No mode distinctions</strong> - same smart logic serves all use cases optimally</p>
</li>
<li>
<p><strong>Leverages existing logic</strong> - reuses proven dependency tracking and caching systems</p>
</li>
<li>
<p><strong>Reduced complexity</strong> - eliminates artificial FILE_BASED/ON_DEMAND/HYBRID modes</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_user_experience_improvements">User Experience Improvements</h5>
<div class="ulist">
<ul>
<li>
<p><strong>Zero configuration</strong> - works immediately on any C project without setup</p>
</li>
<li>
<p><strong>No cold start delay</strong> - first symbol lookup triggers minimal necessary scanning</p>
</li>
<li>
<p><strong>Transparent caching</strong> - <code>.cx</code> files automatically maintained as performance optimization</p>
</li>
<li>
<p><strong>Consistent behavior</strong> - same results whether using Emacs or modern IDE with LSP</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_performance_characteristics_2">Performance Characteristics</h5>
<div class="ulist">
<ul>
<li>
<p><strong>Minimal initial cost</strong> - avoids expensive upfront full-project scanning</p>
</li>
<li>
<p><strong>Smart incremental updates</strong> - only rescans files that have actually changed</p>
</li>
<li>
<p><strong>Automatic dependency tracking</strong> - includes files affected by changes get updated</p>
</li>
<li>
<p><strong>Persistent optimization</strong> - analysis results cached across sessions</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_development_benefits">Development Benefits</h5>
<div class="ulist">
<ul>
<li>
<p><strong>Backward compatibility</strong> - existing Emacs workflows continue unchanged</p>
</li>
<li>
<p><strong>Forward compatibility</strong> - natural path to modern LSP integration</p>
</li>
<li>
<p><strong>Reduced maintenance</strong> - single implementation instead of multiple modes</p>
</li>
<li>
<p><strong>Enhanced testability</strong> - unified logic easier to test comprehensively</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_existing_infrastructure">16.3.6. Existing Infrastructure</h4>
<div class="sect4">
<h5 id="_sophisticated_dependency_tracking">Sophisticated Dependency Tracking</h5>
<div class="paragraph">
<p>The unified approach leverages c-xrefactory&#8217;s <strong>existing sophisticated dependency management</strong> that handles include file relationships automatically:</p>
</div>
<div class="paragraph">
<p><strong>File Modification Tracking</strong> (<code>filetable.h</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct fileItem {
    char *name;
    time_t lastModified;        // Last known modification time
    time_t lastInspected;       // Last time we checked
    time_t lastUpdateMtime;     // Last update cycle time
    time_t lastFullUpdateMtime; // Last full update time
    // ... scheduling and state flags
} FileItem;

bool checkFileModifiedTime(int fileNumber);</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Include Dependency Tracking</strong> (<code>yylex.c</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">void pushInclude(FILE *file, EditorBuffer *buffer, char *name, char *prepend) {
    // ... setup include stack
    includeStack.stack[includeStack.pointer++] = currentFile;
    // Track include relationships for dependency analysis
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Automatic Include Closure</strong> (<code>xref.c:81-108</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static void makeIncludeClosureOfFilesToUpdate(void) {
    // If file A includes file B, and B is modified, A gets scheduled for update
    // This uses the reference database to track include relationships
    bool fileAddedFlag = true;
    while (fileAddedFlag) {
        // Iterative closure: keeps adding dependent files until stable
        for (all scheduled files) {
            find_all_files_that_include_this_file();
            schedule_them_for_update();
        }
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
This dependency tracking infrastructure is <strong>already production-ready</strong> and handles the complex cases (transitive dependencies, modification time checking, include stack management). The unified symbol database can leverage this existing logic instead of reimplementing dependency management.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_open_questions_2">16.3.7. Open Questions</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Should we maintain backward compatibility with explicit <code>-create</code>/<code>-update</code> commands?</p>
<div class="ulist">
<ul>
<li>
<p>Probably yes, at least as no-ops or aliases to make transition easier</p>
</li>
</ul>
</div>
</li>
<li>
<p>How to handle very large projects (&gt;1M LOC)?</p>
<div class="ulist">
<ul>
<li>
<p>May need workspace-level configuration for incremental scanning thresholds</p>
</li>
<li>
<p>Consider lazy loading of symbol data</p>
</li>
</ul>
</div>
</li>
<li>
<p>What&#8217;s the migration path for existing users?</p>
<div class="ulist">
<ul>
<li>
<p>Existing <code>.cx</code> files should continue to work</p>
</li>
<li>
<p>Auto-migrate on first run with new version</p>
</li>
<li>
<p>Provide clear documentation on new behavior</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_references_3">16.3.8. References</h4>
<div class="ulist">
<ul>
<li>
<p>Current implementation: <code>src/cxfile.c</code>, <code>src/xref.c</code></p>
</li>
<li>
<p>File tracking: <code>src/filetable.h</code>, <code>src/filetable.c</code></p>
</li>
<li>
<p>Dependency tracking: <code>src/xref.c</code> lines 81-108</p>
</li>
<li>
<p>Current database description: See chapter 08 (Code) - Reference Database section</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="macro-expansion-module">16.4. Extract Macro Expansion Module</h3>
<div class="sect3">
<h4 id="_problem_statement_4">16.4.1. Problem Statement</h4>
<div class="paragraph">
<p>The <code>yylex.c</code> file is <strong>2353 lines</strong> and combines multiple responsibilities:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Lexical analysis and token reading</p>
</li>
<li>
<p>File and buffer management</p>
</li>
<li>
<p>Preprocessor directive processing</p>
</li>
<li>
<p><strong>Macro expansion system</strong> (~800 lines)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The macro expansion code is a substantial, cohesive subsystem that would benefit from extraction into its own module. Currently, it&#8217;s deeply embedded in yylex.c, making both lexing and macro expansion harder to understand and test in isolation.</p>
</div>
</div>
<div class="sect3">
<h4 id="_current_architecture_2">16.4.2. Current Architecture</h4>
<div class="paragraph">
<p>The macro expansion system in <code>yylex.c</code> comprises:</p>
</div>
<div class="sect4">
<h5 id="_core_responsibilities_800_lines">Core Responsibilities (~800 lines)</h5>
<div class="ulist">
<ul>
<li>
<p><strong>Macro call expansion</strong> - Main orchestration (<code>expandMacroCall()</code>)</p>
</li>
<li>
<p><strong>Argument processing</strong> - Collection and recursive expansion</p>
</li>
<li>
<p><strong>Token collation</strong> - <code>##</code> operator implementation</p>
</li>
<li>
<p><strong>Stringification</strong> - <code>#</code> operator implementation</p>
</li>
<li>
<p><strong>Memory management</strong> - Separate arenas for macro bodies (MBM) and arguments (PPM)</p>
</li>
<li>
<p><strong>Cyclic detection</strong> - Preventing infinite macro recursion</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_key_state">Key State</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int macroStackIndex;  // Current macro expansion depth
static LexemStream macroInputStack[MACRO_INPUT_STACK_SIZE];
static Memory macroBodyMemory;      // Long-lived: macro definitions
static Memory macroArgumentsMemory; // Short-lived: expansion temporaries</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_memory_lifetime_separation">Memory Lifetime Separation</h5>
<div class="paragraph">
<p>The system uses <strong>two distinct memory arenas</strong> with different lifetimes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>MBM (Macro Body Memory)</strong>: Persistent storage for macro definitions throughout compilation</p>
</li>
<li>
<p><strong>PPM (PreProcessor Memory)</strong>: Temporary storage for expansion, collation, and argument processing</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This separation is fundamental and should be preserved in any refactoring.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_proposed_solution_3">16.4.3. Proposed Solution</h4>
<div class="paragraph">
<p>Extract macro expansion into a new module: <code>macroexpansion.c/h</code></p>
</div>
<div class="sect4">
<h5 id="_public_interface">Public Interface</h5>
<div class="paragraph">
<p>The new module would expose a minimal, focused API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">// Initialization
void initMacroExpansion(void);
int getMacroBodyMemoryIndex(void);
void setMacroBodyMemoryIndex(int index);

// Core expansion
bool expandMacroCall(Symbol *macroSymbol, Position position);
bool insideMacro(void);
int getMacroStackDepth(void);

// Memory allocation (exposed for macro definition processing)
void *macroBodyAlloc(size_t size);
void *macroBodyRealloc(void *ptr, size_t oldSize, size_t newSize);
void *macroArgumentAlloc(size_t size);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_module_boundaries">Module Boundaries</h5>
<div class="paragraph">
<p><strong>What moves to macroexpansion.c:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Macro call expansion and argument processing</p>
</li>
<li>
<p>Token collation (<code>collate()</code> and helpers)</p>
</li>
<li>
<p>Stringification (<code>macroArgumentsToString()</code>)</p>
</li>
<li>
<p>Cyclic call detection</p>
</li>
<li>
<p>MBM/PPM memory management</p>
</li>
<li>
<p>Buffer expansion utilities (<code>expandPreprocessorBufferIfOverflow()</code>, etc.)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>What remains in yylex.c:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Lexing and file input</p>
</li>
<li>
<p>Preprocessor directive processing (<code>#define</code>, <code>#ifdef</code>, etc.)</p>
</li>
<li>
<p>Include file handling</p>
</li>
<li>
<p>Main <code>yylex()</code> function</p>
</li>
<li>
<p>Macro symbol table operations</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Dependencies:</strong></p>
</div>
<div class="paragraph">
<p>The macro module would depend on:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Lexem stream operations (reading/writing)</p>
</li>
<li>
<p>Symbol lookup (<code>findMacroSymbol()</code>)</p>
</li>
<li>
<p>Cross-referencing (for collation and expansion references)</p>
</li>
<li>
<p>Current input state (via accessor functions)</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_benefits_4">16.4.4. Benefits</h4>
<div class="sect4">
<h5 id="_architectural">Architectural</h5>
<div class="ulist">
<ul>
<li>
<p><strong>Separation of concerns</strong>: Lexing vs. preprocessing clearly separated</p>
</li>
<li>
<p><strong>Reduced file size</strong>: yylex.c drops from 2353  ~1550 lines (34% reduction)</p>
</li>
<li>
<p><strong>Testability</strong>: Macro expansion can be unit tested independently</p>
</li>
<li>
<p><strong>Clearer ownership</strong>: Macro state and memory management centralized</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_maintainability_2">Maintainability</h5>
<div class="ulist">
<ul>
<li>
<p><strong>Focused modules</strong>: Each file has a single, clear purpose</p>
</li>
<li>
<p><strong>Easier reasoning</strong>: Macro behavior isolated from lexer concerns</p>
</li>
<li>
<p><strong>Better documentation</strong>: Module-level documentation for macro system</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_future_flexibility">Future flexibility</h5>
<div class="ulist">
<ul>
<li>
<p>Could support different macro systems (C vs. C++)</p>
</li>
<li>
<p>Easier to add macro debugging/tracing</p>
</li>
<li>
<p>Independent optimization of macro expansion</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_implementation_strategy_2">16.4.5. Implementation Strategy</h4>
<div class="sect4">
<h5 id="_phase_1_preparation_already_complete">Phase 1: Preparation (Already Complete)</h5>
<div class="paragraph">
<p> Create <code>LexemBufferDescriptor</code> type for buffer management<br>
 Refactor buffer expansion functions to use descriptor<br>
 Eliminate return values for size updates</p>
</div>
</div>
<div class="sect4">
<h5 id="_phase_2_create_module_structure">Phase 2: Create Module Structure</h5>
<div class="ulist">
<ul>
<li>
<p>Create <code>macroexpansion.h</code> with public interface</p>
</li>
<li>
<p>Create <code>macroexpansion.c</code> with initial implementations</p>
</li>
<li>
<p>Move <code>LexemBufferDescriptor</code> to appropriate header</p>
</li>
<li>
<p>Create accessor functions for <code>currentInput</code> state</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_phase_3_incremental_function_migration">Phase 3: Incremental Function Migration</h5>
<div class="paragraph">
<p>Move functions in this order (lowest risk first):</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Memory management</strong> - MBM/PPM allocation functions</p>
</li>
<li>
<p><strong>Buffer expansion</strong> - <code>expandPreprocessorBufferIfOverflow()</code>, <code>expandMacroBodyBufferIfOverflow()</code></p>
</li>
<li>
<p><strong>Support utilities</strong> - <code>cyclicCall()</code>, <code>prependMacroInput()</code></p>
</li>
<li>
<p><strong>Token processing</strong> - <code>collate()</code>, <code>resolveMacroArgument()</code>, etc.</p>
</li>
<li>
<p><strong>Core expansion</strong> - <code>expandMacroCall()</code>, <code>createMacroBodyAsNewStream()</code>, etc.</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_phase_4_integration_and_cleanup">Phase 4: Integration and Cleanup</h5>
<div class="ulist">
<ul>
<li>
<p>Update yylex.c to use new interface</p>
</li>
<li>
<p>Run full test suite after each migration step</p>
</li>
<li>
<p>Add focused unit tests for macro expansion</p>
</li>
<li>
<p>Update build system</p>
</li>
<li>
<p>Document the new architecture</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_risks_and_mitigation_2">16.4.6. Risks and Mitigation</h4>
<div class="sect4">
<h5 id="_risk_complex_dependencies">Risk: Complex dependencies</h5>
<div class="paragraph">
<p><strong>Mitigation:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Create clear accessor functions for shared state</p>
</li>
<li>
<p>Use incremental approach - one function group at a time</p>
</li>
<li>
<p>Validate with tests after each step</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_risk_performance_overhead">Risk: Performance overhead</h5>
<div class="paragraph">
<p><strong>Mitigation:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Keep critical functions inline where necessary</p>
</li>
<li>
<p>Profile before/after migration</p>
</li>
<li>
<p>Current code already has abstraction layers</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Assessment:</strong> Low risk - macro operations are complex enough that function call overhead is negligible</p>
</div>
</div>
<div class="sect4">
<h5 id="_risk_breaking_existing_tests">Risk: Breaking existing tests</h5>
<div class="paragraph">
<p><strong>Mitigation:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Run test suite after every migration step</p>
</li>
<li>
<p>Keep interface behavior identical</p>
</li>
<li>
<p>Use compiler to catch interface mismatches</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_success_metrics_2">16.4.7. Success Metrics</h4>
<div class="ulist">
<ul>
<li>
<p>All existing tests pass</p>
</li>
<li>
<p>yylex.c reduced to ~1550 lines</p>
</li>
<li>
<p>New focused tests for macro expansion added</p>
</li>
<li>
<p>No performance regression (&lt; 5% overhead acceptable)</p>
</li>
<li>
<p>Code review confirms improved clarity</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_open_questions_3">16.4.8. Open Questions</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Should <code>findMacroSymbol()</code> move to the macro module or stay in yylex.c?</p>
<div class="ulist">
<ul>
<li>
<p>It&#8217;s used by both lexer (for expansion triggering) and macro module (for nested expansions)</p>
</li>
<li>
<p>Probably belongs in a shared location or as part of symbol table operations</p>
</li>
</ul>
</div>
</li>
<li>
<p>How to handle <code>currentInput</code> global state?</p>
<div class="ulist">
<ul>
<li>
<p>Options: Pass explicitly, use accessor functions, or provide context structure</p>
</li>
<li>
<p>Accessor functions likely cleanest: <code>getCurrentInput()</code>, <code>setCurrentInput()</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>Should we extract preprocessor directives at the same time?</p>
<div class="ulist">
<ul>
<li>
<p>No - keep changes focused</p>
</li>
<li>
<p>Could be a future refactoring after macro extraction proves successful</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_references_4">16.4.9. References</h4>
<div class="ulist">
<ul>
<li>
<p>Current code: <code>src/yylex.c</code> lines 1327-2089 (macro expansion system)</p>
</li>
<li>
<p>Memory management: <code>src/memory.h</code>, <code>src/memory.c</code></p>
</li>
<li>
<p>Symbol operations: <code>src/symbol.h</code></p>
</li>
<li>
<p>Related refactoring: <a href="#_lexemstream_api_improvements">LexemStream API Improvements</a> addresses buffer management patterns</p>
</li>
</ul>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This refactoring is independent of the LexemStream API improvements but would benefit from them being completed first, as they simplify buffer management patterns throughout the macro expansion code.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="move-function-refactoring">16.5. Move Function Between Files</h3>
<div class="sect3">
<h4 id="_problem_statement_5">16.5.1. Problem Statement</h4>
<div class="paragraph">
<p>Moving functions between C source files is a frequent manual refactoring task that requires:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cutting function definition from source file</p>
</li>
<li>
<p>Pasting into target file</p>
</li>
<li>
<p>Changing <code>static</code> to <code>extern</code> (or vice versa)</p>
</li>
<li>
<p>Adding function declaration to appropriate header</p>
</li>
<li>
<p>Updating <code>#include</code> directives in both files</p>
</li>
<li>
<p>Ensuring all dependencies (headers, types, macros) are available in target file</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This is <strong>error-prone</strong> and <strong>tedious</strong>, especially for functions with complex dependencies.</p>
</div>
</div>
<div class="sect3">
<h4 id="_discovery_existing_move_refactorings_in_c_xref_java">16.5.2. Discovery: Existing Move Refactorings in c-xref-java</h4>
<div class="paragraph">
<p>The Java-supporting version at <code>/home/thoni/Utveckling/c-xref-java</code> contains substantial move refactoring infrastructure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">// From c-xref-java/src/refactorings.def
#define AVR_MOVE_STATIC_METHOD 80
#define AVR_MOVE_CLASS 160
#define AVR_MOVE_CLASS_TO_NEW_FILE 170
#define AVR_MOVE_STATIC_FIELD 70
#define AVR_MOVE_FIELD 90</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Key implementations</strong> in <code>c-xref-java/src/refactory.c</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>moveStaticMethod()</code> (line 2974) - Moves static methods between classes</p>
</li>
<li>
<p><code>moveClass()</code> (line 3074+) - Moves entire classes</p>
</li>
<li>
<p><code>moveStaticObjectAndMakeItPublic()</code> (line 2814) - Core move logic</p>
</li>
<li>
<p><code>applyExpandShortNames()</code> (line 2300) - Dependency expansion before move</p>
</li>
<li>
<p><code>reduceNamesAndAddImports()</code> (line 2645) - Import management after move</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_leverageable_code_from_java_version">16.5.3. Leverageable Code from Java Version</h4>
<div class="sect4">
<h5 id="_core_move_logic_directly_reusable">Core Move Logic (Directly Reusable)</h5>
<div class="paragraph">
<p><strong>Text block extraction/movement</strong> is language-agnostic:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">// From refactory.c:2865-2874
size = mend-&gt;offset - mstart-&gt;offset;
moveBlockInEditorBuffer(target, mstart, size, &amp;editorUndo);</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Reference finding and updating</strong> already works for C:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">// From refactory.c:2843-2862
occs = getReferences(point, STANDARD_SELECT_SYMBOLS_MESSAGE, PPCV_BROWSER_TYPE_INFO);
LIST_MERGE_SORT(EditorMarkerList, occs, editorMarkerListBefore);
for (EditorMarkerList *ll = occs; ll != NULL; ll = ll-&gt;next) {
    // Update each call site
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Access modifier changes</strong> map to C visibility:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">// From refactory.c:2868
changeAccessModifier(point, limitIndex, "public");
// C equivalent: change "static"  "extern", add header declaration</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_dependency_management_pattern_needs_c_adaptation">Dependency Management Pattern (Needs C Adaptation)</h5>
<div class="paragraph">
<p><strong>Java approach:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">// 1. Expand short names to fully qualified
applyExpandShortNames(point);
   // Before:  List myList;
   // After:   java.util.List myList;

// 2. Move the code
moveBlockInEditorBuffer(target, mstart, size, &amp;editorUndo);

// 3. Reduce names and add imports
reduceNamesAndAddImports(&amp;regions, INTERACTIVE_NO);
   // Before:  java.util.List myList;
   // After:   List myList; (with "import java.util.List;" added)</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>C equivalent approach:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">// 1. Find required headers by analyzing dependencies
findRequiredHeaders(functionStart, functionEnd, &amp;neededHeaders, &amp;headerCount);
   // Scan function body for:
   // - Function calls  which header declares them?
   // - Type references  which header defines them?
   // - Macro usage  which header defines them?
   // Use symbol database to find declarations

// 2. Move the code (same as Java)
moveBlockInEditorBuffer(target, mstart, size, &amp;editorUndo);

// 3. Add include directives to target file
addRequiredIncludes(targetFile, neededHeaders, headerCount);
   // Insert #include directives at top of target file</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_proposed_implementation">16.5.4. Proposed Implementation</h4>
<div class="paragraph">
<p><strong>Estimation Approach</strong>: We use relative complexity estimates (Story Points) with Phase 1 as the baseline (1). This is more meaningful for hobby/OSS development than calendar time estimates. As phases complete, we can track velocity and refine future estimates.</p>
</div>
<div class="sect4">
<h5 id="_phase_1_basic_move_mvp_immediate_value_completed">Phase 1: Basic Move (MVP - Immediate Value)  COMPLETED</h5>
<div class="paragraph">
<p><strong>Relative complexity</strong>: 1 (baseline for future estimates)</p>
</div>
<div class="paragraph">
<p><strong>Status</strong>: Completed December 2024 / January 2025</p>
</div>
<div class="paragraph">
<p><strong>Implementation</strong>: Handles 80% of common move function use cases with minimal user intervention.</p>
</div>
<div class="paragraph">
<p><strong>What was implemented:</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Parser Integration</strong> (<code>src/c_parser.y</code>, <code>src/yacc_parser.y</code>):</p>
<div class="ulist">
<ul>
<li>
<p>Added semantic actions to capture function boundaries during parsing</p>
</li>
<li>
<p>Uses <code>parsedPositions[IPP_FUNCTION_BEGIN/END]</code> to store function extent</p>
</li>
<li>
<p>Includes closing brace and trailing newline in boundary detection</p>
</li>
<li>
<p>Server operation <code>OLO_GET_FUNCTION_BOUNDS</code> triggers boundary capture</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Function Boundary Detection</strong> (<code>src/refactory.c</code>):</p>
<div class="ulist">
<ul>
<li>
<p><code>getFunctionBoundariesForMoving()</code> uses parser to find exact function extent</p>
</li>
<li>
<p>Handles comments and decorations before/after function</p>
</li>
<li>
<p>Works for both static and non-static functions</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Static Keyword Removal</strong> (<code>src/refactory.c</code>):</p>
<div class="ulist">
<ul>
<li>
<p>Simple string search for "static " from function start to name</p>
</li>
<li>
<p>Only removes static when moving <strong>between files</strong> (not within same file)</p>
</li>
<li>
<p>Automatically removes without user prompting (streamlined UX)</p>
</li>
<li>
<p>Removes 7 characters ("static ") before moving to avoid offset tracking</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>UI Integration</strong> (<code>src/cxref.c</code>):</p>
<div class="ulist">
<ul>
<li>
<p>"Move Function" appears in refactoring menu only on function <strong>definitions</strong> (not call sites)</p>
</li>
<li>
<p>Uses <code>isDefinitionUsage()</code> to filter appropriately</p>
</li>
<li>
<p>Two-step workflow: set target, then invoke move</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Target Validation</strong> (<code>src/refactory.c</code>, <code>src/yylex.c</code>):</p>
<div class="ulist">
<ul>
<li>
<p>Validates target is at global scope (not inside function/struct)</p>
</li>
<li>
<p>Uses <code>parsedInfo.moveTargetAccepted</code> flag from parser</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Tests</strong>:</p>
<div class="ulist">
<ul>
<li>
<p><code>test_move_c_function_to_other_file/</code> - moves between files, removes static</p>
</li>
<li>
<p><code>test_move_c_function_inside_file/</code> - moves within file, keeps static</p>
</li>
<li>
<p>Both tests passing with deterministic output</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>What user manually handles (acceptable for MVP):</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Adding function declaration to header files</p>
</li>
<li>
<p>Adding <code>#include</code> directives for dependencies</p>
</li>
<li>
<p>Moving tightly-coupled static helper functions</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Files modified:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>src/c_parser.y</code> - parser integration for boundary detection</p>
</li>
<li>
<p><code>src/yacc_parser.y</code> - same for yacc files</p>
</li>
<li>
<p><code>src/refactory.c</code> - simplified <code>moveStaticFunctionAndMakeItExtern()</code></p>
</li>
<li>
<p><code>src/cxref.c</code> - UI filter for definitions only</p>
</li>
<li>
<p><code>src/misc.c</code> - added <code>OLO_GET_FUNCTION_BOUNDS</code> to <code>requiresCreatingRefs()</code></p>
</li>
<li>
<p><code>tests/test_move_c_function_*/</code> - enabled and passing</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_phase_2_add_function_declaration_to_header">Phase 2: Add Function Declaration to Header</h5>
<div class="paragraph">
<p><strong>Relative complexity</strong>: ~0.5 Phase 1</p>
</div>
<div class="paragraph">
<p>Add automatic function declaration to target file&#8217;s header:</p>
</div>
<div class="paragraph">
<p><strong>Approach:</strong></p>
</div>
<div class="paragraph">
<p>Following C conventions, when moving a function to <code>target.c</code>, add its declaration to <code>target.h</code> so other files can call it. This is much simpler than analyzing all dependencies.</p>
</div>
<div class="paragraph">
<p><strong>Algorithm:</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Determine target file path (e.g., <code>/path/to/target.c</code>)</p>
</li>
<li>
<p>Derive header path by replacing <code>.c</code> with <code>.h</code> (e.g., <code>/path/to/target.h</code>)</p>
</li>
<li>
<p>If header doesn&#8217;t exist, create it with include guards</p>
</li>
<li>
<p>Find insertion point in header (after includes, before end of guard)</p>
</li>
<li>
<p>Generate function declaration from Symbol: <code>extern void func(int a);</code></p>
</li>
<li>
<p>Insert declaration into header</p>
</li>
<li>
<p>User manually adds any needed <code>#include</code> directives to target file</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Implementation sketch:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">char *getHeaderPathForSourceFile(char *sourcePath) {
    // "/path/to/target.c" -&gt; "/path/to/target.h"
    char *header = stackMemoryAlloc(strlen(sourcePath) + 1);
    strcpy(header, sourcePath);
    char *ext = strrchr(header, '.');
    if (ext &amp;&amp; strcmp(ext, ".c") == 0) {
        strcpy(ext, ".h");
    }
    return header;
}

void createHeaderIfNeeded(char *headerPath) {
    if (!fileExists(headerPath)) {
        // Create header with include guards
        // "#ifndef TARGET_H\n#define TARGET_H\n\n#endif\n"
        char *guardName = makeIncludeGuardName(headerPath);
        // Write to file or EditorBuffer
    }
}

char *generateFunctionSignature(Symbol *function) {
    // Reconstruct function signature from Symbol
    // Example: "extern void func(int a, char *b)"
    // Need to walk function-&gt;typeModifier to build type string
    // This is the trickiest part
}

void addFunctionDeclarationToHeader(Symbol *function, char *headerPath) {
    // 1. Open or load header into EditorBuffer
    // 2. Find insertion point (before final #endif)
    // 3. Generate signature: "extern void func(int a);\n"
    // 4. Insert declaration
}

// In moveFunction() after moving the function block:
if (movingBetweenFiles) {
    char *headerPath = getHeaderPathForSourceFile(targetFilePath);
    createHeaderIfNeeded(headerPath);
    addFunctionDeclarationToHeader(parsedInfo.function, headerPath);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Required infrastructure</strong> (already exists):
- <code>Symbol</code> with function information (symbol.h)
- <code>Symbol.typeModifier</code> - contains return type and parameter information
- <code>EditorBuffer</code> manipulation for header file editing
- File path utilities</p>
</div>
<div class="paragraph">
<p><strong>Challenges:</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Generating function signature</strong>: Need to reconstruct <code>void func(int a, char *b)</code> from Symbol&#8217;s type information</p>
<div class="ulist">
<ul>
<li>
<p>Walk <code>typeModifier</code> chain to build type string</p>
</li>
<li>
<p>Handle pointers, arrays, function pointers correctly</p>
</li>
<li>
<p>Parameter names might not be available (use <code>arg1</code>, <code>arg2</code>, etc.)</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Finding insertion point in header</strong>: Where to add the declaration?</p>
<div class="ulist">
<ul>
<li>
<p>After <code>#include</code> directives</p>
</li>
<li>
<p>Before final <code>#endif</code> of include guard</p>
</li>
<li>
<p>After existing declarations (maintain some order)</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Creating header file</strong>: If <code>target.h</code> doesn&#8217;t exist</p>
<div class="ulist">
<ul>
<li>
<p>Generate include guard name from filename (<code>TARGET_H</code>)</p>
</li>
<li>
<p>Create basic header structure</p>
</li>
<li>
<p>Or warn user and skip?</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Header guard formats</strong>: Different styles exist</p>
<div class="ulist">
<ul>
<li>
<p><code>#ifndef HEADER_H</code> / <code>#define HEADER_H</code> / <code>#endif</code></p>
</li>
<li>
<p><code>#pragma once</code></p>
</li>
<li>
<p>Need to detect and handle both</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Value:</strong>
- Automatically makes moved function callable from other files
- Follows C convention of declarations in <code>.h</code>, definitions in <code>.c</code>
- Much simpler than full dependency analysis
- User still controls <code>#include</code> directives (maintains flexibility)</p>
</div>
<div class="paragraph">
<p><strong>New code required</strong>: ~150 lines
- Header path derivation: ~20 lines
- Signature generation from Symbol: ~60 lines (complex type reconstruction)
- Header file manipulation: ~50 lines
- Include guard detection/creation: ~20 lines</p>
</div>
<div class="paragraph">
<p><strong>Success Criteria</strong>:
1.  When moving function to <code>target.c</code>, declaration is added to <code>target.h</code>
2.  Function signature is correctly generated (return type, name, parameters)
3.  Declaration is inserted at appropriate location in header
4.  If header doesn&#8217;t exist, either create it or warn user
5.  Duplicate declarations are avoided (check if already present)
6.  Works with both <code>#ifndef</code> guards and <code>#pragma once</code>
7.  No regression in Phase 1 functionality</p>
</div>
<div class="paragraph">
<p><strong>Acceptable limitations</strong> (defer to Phase 3/4):
- User manually adds <code>#include</code> directives to target <code>.c</code> file
- May not preserve exact parameter names if not in Symbol
- Basic include guard format if creating new header
- Doesn&#8217;t remove declaration from old header (user handles manually)</p>
</div>
</div>
<div class="sect4">
<h5 id="_phase_3_static_helper_functions">Phase 3: Static Helper Functions</h5>
<div class="paragraph">
<p><strong>Relative complexity</strong>: 1-1.5 Phase 1</p>
</div>
<div class="paragraph">
<p>Detect and optionally move tightly-coupled static helpers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static void detectStaticHelpers(EditorMarker *functionStart,
                                 EditorMarker *functionEnd,
                                 Symbol ***helpersOut, int *countOut) {
    SymbolList *helpers = NULL;

    // Find all function calls within the moved function
    parseRegion(functionStart, functionEnd);
    for (Symbol *calledFunc = calledFunctions; calledFunc != NULL;
         calledFunc = calledFunc-&gt;next) {
        // Is it static in the same file?
        if (calledFunc-&gt;storage == StorageStatic &amp;&amp;
            calledFunc-&gt;pos.file == functionStart-&gt;buffer-&gt;fileNumber) {
            // Add to helpers list
            addSymbol(&amp;helpers, calledFunc);
        }
    }

    *countOut = countList(helpers);
    *helpersOut = listToArray(helpers);
}

// In moveFunction():
if (staticHelperCount &gt; 0) {
    if (promptUser("Move %d static helper function(s) too?", staticHelperCount)) {
        for (int i = 0; i &lt; staticHelperCount; i++) {
            moveFunction(staticHelpers[i]-&gt;pos, target);
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Value:</strong>
- Prevents broken builds from missing static helpers
- Maintains logical cohesion
- Reduces manual follow-up work</p>
</div>
</div>
<div class="sect4">
<h5 id="_phase_4_polish">Phase 4: Polish</h5>
<div class="paragraph">
<p><strong>Scope</strong>: Smaller effort, quality-of-life improvements</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Preview dialog showing what will be moved</p>
</li>
<li>
<p>Better insertion point heuristics (group with related functions)</p>
</li>
<li>
<p>Handle comments and documentation</p>
</li>
<li>
<p>Update existing callers if needed</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_code_locations">16.5.5. Code Locations</h4>
<div class="sect4">
<h5 id="_in_c_xref_java_leverage_these">In c-xref-java (Leverage These)</h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 50%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Function</th>
<th class="tableblock halign-left valign-top">Purpose</th>
<th class="tableblock halign-left valign-top">Line</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>moveStaticObjectAndMakeItPublic</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Core move logic with reference updating</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2814</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>getMethodLimitsForMoving</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Find function boundaries using parser</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2908</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>applyExpandShortNames</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pattern for dependency analysis (adapt for C)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2300</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>reduceNamesAndAddImports</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pattern for import management (adapt for C)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2645</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>moveBlockInEditorBuffer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Language-agnostic text movement</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Used at 2867</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>getReferences</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Find all call sites (already works for C)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Used at 2843</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>changeAccessModifier</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Change visibility (adapt for static/extern)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Used at 2868</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="_in_c_xrefactory_already_available">In c-xrefactory (Already Available)</h5>
<div class="ulist">
<ul>
<li>
<p><code>EditorMarker</code> position tracking - <code>src/editor.h</code></p>
</li>
<li>
<p><code>EditorBuffer</code> text manipulation - <code>src/editorbuffer.h</code></p>
</li>
<li>
<p>Undo/redo infrastructure - <code>src/editor.c</code></p>
</li>
<li>
<p>Symbol database lookups - <code>src/reftab.c</code></p>
</li>
<li>
<p>Reference tracking - <code>src/reference.c</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_implementation_summary">16.5.6. Implementation Summary</h4>
<div class="paragraph">
<p>||===
||Phase |Value
|
||Phase 1: Basic Move
||<strong>High</strong> - Eliminates manual cut/paste, handles 80% of cases
|
||Phase 2: Include Management
||<strong>High</strong> - Prevents build breakage, major time saver
|
||Phase 3: Static Helpers
||<strong>Medium</strong> - Nice to have, improves completeness
|
||Phase 4: Polish
||<strong>Low</strong> - Quality of life improvements
||===</p>
</div>
<div class="paragraph">
<p><strong>Phases 1-2 provide most value</strong>, independently testable
<strong>Leverages existing Java refactoring code</strong>, reduces complexity significantly</p>
</div>
</div>
<div class="sect3">
<h4 id="_benefits_5">16.5.7. Benefits</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><strong>Developer Productivity</strong></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Frequent manual refactoring becomes automated</p>
</li>
<li>
<p>Reduces errors from missed dependencies</p>
</li>
<li>
<p>Maintains code quality during reorganization</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><strong>Code Quality</strong></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Correct header management (no missing includes)</p>
</li>
<li>
<p>Proper visibility (static vs extern)</p>
</li>
<li>
<p>Preserves all references and call sites</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><strong>Showcase for c-xrefactory</strong></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Demonstrates unique C-specific refactoring capabilities</p>
</li>
<li>
<p>Differentiates from generic LSP servers</p>
</li>
<li>
<p>Builds on existing Java refactoring experience</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_risks_and_mitigation_3">16.5.8. Risks and Mitigation</h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Risk</th>
<th class="tableblock halign-left valign-top">Likelihood</th>
<th class="tableblock halign-left valign-top">Mitigation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Complex header dependencies</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Medium</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Start with simple cases in Phase 1, iterate in Phase 2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parser limitations finding function boundaries</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Low</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Already works for extract function refactoring</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Missing static helper detection</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Medium</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Make it optional, user can manually move helpers</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Breaking builds with incorrect includes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Medium</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Generate preview, allow user to review before applying</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_success_metrics_3">16.5.9. Success Metrics</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Phase 1 MVP</strong>: Successfully moves function 90% of cases without build errors</p>
</li>
<li>
<p><strong>Phase 2</strong>: Correctly identifies and adds required headers 80% of time</p>
</li>
<li>
<p><strong>Phase 3</strong>: Detects static helpers with &gt;95% accuracy</p>
</li>
<li>
<p><strong>User adoption</strong>: Refactoring used frequently by active c-xrefactory users</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_alternatives_considered">16.5.10. Alternatives Considered</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><strong>Manual refactoring with editor macros</strong></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Fragile, error-prone</p>
</li>
<li>
<p>No understanding of code structure</p>
</li>
<li>
<p>Can&#8217;t handle dependencies</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><strong>Use generic LSP move/rename</strong></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>LSP has no "move function" operation</p>
</li>
<li>
<p>Would need custom extension</p>
</li>
<li>
<p>Doesn&#8217;t understand C header dependencies</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><strong>Wait for Clangd to implement</strong></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Clangd has no move function refactoring</p>
</li>
<li>
<p>C++-focused, may not handle C idioms well</p>
</li>
<li>
<p>We have opportunity to do it first and better</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_references_5">16.5.11. References</h4>
<div class="ulist">
<ul>
<li>
<p>Java implementation: <code>/home/thoni/Utveckling/c-xref-java/src/refactory.c</code></p>
</li>
<li>
<p>Current extract function: <code>src/extract.c</code> (proves function boundary detection works)</p>
</li>
<li>
<p>Editor infrastructure: <code>src/editor.c</code>, <code>src/editorbuffer.c</code></p>
</li>
<li>
<p>Symbol database: <code>src/reftab.c</code>, <code>src/referenceableitemtable.c</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_next_steps">16.5.12. Next Steps</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>After persistence store cleanup</strong>: Take a break from architectural work</p>
</li>
<li>
<p><strong>Implement Phase 1 MVP</strong>: Smaller effort, high value</p>
</li>
<li>
<p><strong>Gather usage feedback</strong>: Identify most common dependency patterns</p>
</li>
<li>
<p><strong>Implement Phase 2</strong>: Based on real-world usage patterns</p>
</li>
<li>
<p><strong>Document and showcase</strong>: Blog post, video demonstration</p>
</li>
</ol>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Even Phase 1 MVP provides significant value by eliminating manual text manipulation. The developer who does this refactoring "very often" confirms the high ROI potential.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="clean-parser-api">16.6. Clean Parser API and Multi-File Definition Support</h3>
<div class="sect3">
<h4 id="_current_state_recent_lsp_definition_finding_success">16.6.1. Current State: Recent LSP Definition Finding Success</h4>
<div class="paragraph">
<p>The recent implementation of <code>textDocument/definition</code> for LSP created a <strong>clean, operation-based parser API</strong> in <code>parsing.h/c</code> that successfully decouples high-level operations from low-level parsing details. This API discovery presents an opportunity to gradually modernize legacy parsing infrastructure.</p>
</div>
<div class="paragraph">
<p><strong>What works</strong>:
* Single-file definition lookup via clean <code>parsing.h</code> interface
* Operation-based configuration (ParserOperation enum)
* No reliance on <code>.cx</code> files for immediate queries</p>
</div>
<div class="paragraph">
<p><strong>What doesn&#8217;t work yet</strong>:
* Multi-file definitions (symbol defined in different file than reference)
* Cross-file type resolution
* Include graph persistence</p>
</div>
</div>
<div class="sect3">
<h4 id="_problem_statement_6">16.6.2. Problem Statement</h4>
<div class="paragraph">
<p>The LSP definition finding currently fails when a symbol&#8217;s <strong>definition is in a different file</strong> from the reference. This requires:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Symbol type information</strong> - Current reference database only stores name and position, not types needed for resolution</p>
</li>
<li>
<p><strong>Include graph</strong> - Don&#8217;t know which files include which headers to find definition files</p>
</li>
<li>
<p><strong>Multi-file parsing</strong> - Ability to efficiently reparse relevant files without loading entire project</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>More broadly, the legacy codebase still relies on <strong>magic string command routing</strong> to drive parsing behavior:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">// Scattered throughout codebase (cxref.c, refactory.c, server.c, etc.)
parseBufferUsingServer(project, point, mark, "-olcxpush", NULL);
parseBufferUsingServer(project, point, mark, "-olcxmovetarget", NULL);
parseBufferUsingServer(project, point, mark, "-olcxmodemenu", NULL);
// ... 20+ more magic strings, each with unclear semantics</code></pre>
</div>
</div>
<div class="paragraph">
<p>This makes the codebase fragile, hard to understand, and difficult to extend with new operations.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_parser_api_innovation">16.6.3. The Parser API Innovation</h4>
<div class="paragraph">
<p>The new <code>parsing.h</code> interface provides operation-based configuration (see <code>src/parsing.h</code> for details):</p>
</div>
<div class="paragraph">
<p><strong>Key innovations</strong>:
* Enum-based operations - Discoverable list (IDE autocomplete shows all options)
* Configuration struct - Single point of setup, no scattered global flags
* Operation predicates - Self-documenting behavior (<code>needsReferenceAtCursor</code>, <code>allowsDuplicateReferences</code>)
* Type-safe - Compile-time checking replaces runtime magic string matching</p>
</div>
</div>
<div class="sect3">
<h4 id="_benefits_of_backporting_this_api">16.6.4. Benefits of Backporting This API</h4>
<div class="sect4">
<h5 id="_code_clarity_and_safety">Code Clarity and Safety</h5>
<div class="paragraph">
<p>Replace magic strings with discoverable enums:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">/* Before: What does this do? Need to search for documentation */
parseBufferUsingServer(options.project, target, NULL, "-olcxmovetarget", NULL);

/* After: Type-safe and self-documenting via ParserOperation enum */
parsingConfig.operation = PARSE_TO_VALIDATE_MOVE_TARGET;
parsingConfig.positionOfSelectedReference = makePositionFromMarker(target);
parseCurrentInputFile(LANG_C);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Replace scattered global flags with structured configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">/* Before: Scattered throughout, unclear semantics */
options.olcxPushButton = 1;
options.olcxRenameOption = 1;
s_noParametersToExpand = 0;
originalFileNumber = someValue;

/* After: All configuration in one place, clear purpose */
parsingConfig.operation = PARSE_TO_COMPLETE;
parsingConfig.targetParameterIndex = 5;
parsingConfig.extractMode = EXTRACT_VARIABLE;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_foundation_for_multi_file_definition_lookup">Foundation for Multi-File Definition Lookup</h5>
<div class="paragraph">
<p>The clean API makes it easier to implement required enhancements:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">/* New operation for multi-file definition lookup */
typedef enum {
    /* ... existing operations ... */
    PARSE_TO_RESOLVE_DEFINITION,  /* NEW: Find definition across files */
} ParserOperation;

/* Simpler to add new parsing modes when API is clean */
parsingConfig.operation = PARSE_TO_RESOLVE_DEFINITION;
parsingConfig.symbolName = "findReferenceableAt";
parsingConfig.startFile = fileNumber;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_easier_feature_development">Easier Feature Development</h5>
<div class="paragraph">
<p>Adding new operations becomes straightforward:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Add to <code>ParserOperation</code> enum</p>
</li>
<li>
<p>Implement predicate functions if needed</p>
</li>
<li>
<p>Add semantic actions in grammar</p>
</li>
<li>
<p>Done - no magic strings to maintain</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_implementation_plan_three_non_blocking_phases">16.6.5. Implementation Plan: Three Non-Blocking Phases</h4>
<div class="sect4">
<h5 id="_phase_1_expose_new_api_alongside_legacy_code">Phase 1: Expose New API Alongside Legacy Code</h5>
<div class="paragraph">
<p><strong>Scope</strong>: Purely additive - new API works alongside legacy code
<strong>Risk</strong>: LOW (no changes to existing code paths)
<strong>Value</strong>: Proof of concept, enables gradual migration</p>
</div>
<div class="paragraph">
<p><strong>Approach</strong>:
1. <code>parseWithConfig()</code> becomes primary entry point
2. <code>parseBufferUsingServer()</code> internally bridges legacy magic strings to new <code>ParsingConfig</code>
3. Both code paths work identically (verified with tests)
4. No changes needed to existing functionality</p>
</div>
<div class="paragraph">
<p><strong>Benefit</strong>: Can merge this without affecting legacy code at all</p>
</div>
</div>
<div class="sect4">
<h5 id="_phase_2_migrate_high_value_callsites">Phase 2: Migrate High-Value Callsites</h5>
<div class="paragraph">
<p><strong>Scope</strong>: Refactor 50%+ of parsing infrastructure
<strong>Risk</strong>: MEDIUM (refactoring, but with tests)
<strong>Value</strong>: Significant improvement to codebase clarity</p>
</div>
<div class="paragraph">
<p><strong>Priority callsites</strong>:
1. LSP handlers - Already partially using new API
2. Definition finding - Multi-file lookup
3. Extract refactoring - Complex logic, multiple operations
4. Move function - Multiple parsing passes</p>
</div>
<div class="paragraph">
<p><strong>Benefit</strong>: 50%+ of parsing infrastructure modernized, multi-file definitions enabled</p>
</div>
</div>
<div class="sect4">
<h5 id="_phase_3_complete_legacy_code_cleanup">Phase 3: Complete Legacy Code Cleanup</h5>
<div class="paragraph">
<p><strong>Scope</strong>: Remove all magic string command routing, consolidate parsing
<strong>Risk</strong>: MEDIUM (larger refactoring)
<strong>Value</strong>: Long-term maintainability and extensibility</p>
</div>
<div class="paragraph">
<p><strong>Scope</strong>:
* Remove all magic string command routing
* Consolidate parsing entry points
* Eliminate scattered global flags
* Document parser behavior in code</p>
</div>
<div class="paragraph">
<p><strong>Benefit</strong>: Codebase future-proof for new operations</p>
</div>
<div class="paragraph">
<p><strong>Important</strong>: Phase 3 is <strong>optional</strong> - Phases 1-2 already provide most value</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_multi_file_definition_requirements">16.6.6. Multi-File Definition: Requirements</h4>
<div class="sect4">
<h5 id="_1_symbol_type_information_persistence">1. Symbol Type Information Persistence</h5>
<div class="paragraph">
<p><strong>Current</strong>: ReferenceableItemTable only stores name, position, kind
<strong>Needed</strong>: Minimal type info for cross-file resolution</p>
</div>
<div class="paragraph">
<p><strong>Lightweight approach</strong> (preferred over full type serialization):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">/* Extend ReferenceableItem with minimal type data */
struct ReferenceableItem {
    /* ... existing fields ... */
    char *returnType;      /* For functions: return type string */
    int   parameterCount;  /* For functions: number of parameters */
    bool  isDefinition;    /* True if this is the function/variable definition */
};</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Scope</strong>: Extend ReferenceableItem, careful memory management</p>
</div>
</div>
<div class="sect4">
<h5 id="_2_include_graph_construction">2. Include Graph Construction</h5>
<div class="paragraph">
<p><strong>Current</strong>: Include relationships processed during lexing, not persisted
<strong>Needed</strong>: Map of which files include which headers</p>
</div>
<div class="paragraph">
<p><strong>Lightweight approach</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct {
    int   sourceFile;         /* File with #include directive */
    int   includedFile;       /* File being included */
    bool  isSystemInclude;    /* &lt;&gt; vs \"\" */
} IncludeEdge;

/* Stored in file's metadata, retrievable by file number */
int getIncludedFileCount(int fileNumber);
int getIncludedFile(int fileNumber, int index);
int *getIncludingFiles(int fileNumber);  /* Files that include this one */</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Scope</strong>: Moderate effort, moderate complexity</p>
</div>
</div>
<div class="sect4">
<h5 id="_3_incremental_multi_file_parsing">3. Incremental Multi-File Parsing</h5>
<div class="paragraph">
<p><strong>Current</strong>: Full project parse or single-file parse
<strong>Needed</strong>: Efficient "parse files needed for definition lookup" operation</p>
</div>
<div class="paragraph">
<p><strong>Approach</strong>:
1. Use include graph to find "definition file candidates"
2. Parse only those files (typically 1-5 for most projects)
3. Store symbols in special "definition lookup" arena
4. Return to in-memory reference table when done</p>
</div>
<div class="paragraph">
<p><strong>Scope</strong>: Parse relevant files, update reference table</p>
</div>
<div class="paragraph">
<p><strong>Total for full multi-file support</strong>: Larger foundational work combining above three components</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_code_locations_2">16.6.7. Code Locations</h4>
<div class="paragraph">
<p><strong>New Parser API</strong>:
* <code>src/parsing.h</code> - Public interface (167 lines)
* <code>src/parsing.c</code> - Implementation with bridges (187 lines)
* Functions: <code>getParserOperation()</code>, <code>needsReferenceAtCursor()</code>, <code>parseToCreateReferences()</code></p>
</div>
<div class="paragraph">
<p><strong>Legacy code currently using magic strings</strong>:
* <code>src/cxref.c</code> - 20+ <code>parseBufferUsingServer()</code> calls
* <code>src/refactory.c</code> - 10+ operations
* <code>src/extract.c</code> - Multiple parsing passes
* <code>src/complete.c</code> - Completion-specific parsing
* <code>src/server.c</code> - Operation dispatch</p>
</div>
<div class="paragraph">
<p><strong>Files for multi-file support</strong>:
* <code>src/reference_database.h/c</code> - Add symbol type info
* <code>src/yylex.c</code> - Build include graph
* <code>src/filetable.h/c</code> - Persist include relationships</p>
</div>
</div>
<div class="sect3">
<h4 id="_success_metrics_4">16.6.8. Success Metrics</h4>
<div class="paragraph">
<p><strong>Phase 1</strong>:
*  New <code>ParsingConfig</code> API works alongside legacy strings
*  No performance regression
*  Both code paths tested and working</p>
</div>
<div class="paragraph">
<p><strong>Phase 2</strong>:
*  50%+ of parsing callsites use new API
*  Multi-file definition lookup works
*  All existing tests still pass</p>
</div>
<div class="paragraph">
<p><strong>Phase 3</strong> (if pursued):
*  All parsing driven by enum operations
*  Magic strings completely removed
*  New developers understand control flow</p>
</div>
</div>
<div class="sect3">
<h4 id="_risks_and_mitigation_4">16.6.9. Risks and Mitigation</h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Risk</th>
<th class="tableblock halign-left valign-top">Likelihood</th>
<th class="tableblock halign-left valign-top">Mitigation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Breaking existing workflows</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Medium</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Phase 1 keeps old API working, extensive testing, clear migration timeline</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Incomplete refactoring</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Medium</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Phase 1-2 provide value even if Phase 3 never completes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Performance regression</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Low</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">New API does same work, just different control flow; profile before/after</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Memory overhead from type info</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Medium</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Use lightweight approach, store only essential fields, consider lazy loading</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_related_work">16.6.10. Related Work</h4>
<div class="paragraph">
<p>This refactoring supports:
* <strong>ADR-0014</strong> (On-Demand Parsing) - Single code path for all operations
* <strong>Unified Symbol Database</strong> (next major refactoring) - Requires clean parsing API
* <strong>LSP Multi-File Support</strong> - Immediately enables cross-file definition lookup</p>
</div>
</div>
<div class="sect3">
<h4 id="_notes_2">16.6.11. Notes</h4>
<div class="paragraph">
<p>The key insight is that we can <strong>backport this gradually without breaking anything</strong>. The bridge pattern (new API calls old code for now) lets us improve incrementally, retiring magic strings and globals one section at a time.</p>
</div>
<div class="paragraph">
<p>Phase 1 proves the approach works with minimal risk. Phases 2-3 build on proven foundation, so failure to complete them doesn&#8217;t harm existing functionality.</p>
</div>
<div class="paragraph">
<p>Multi-file definitions are one motivating use case, but the real long-term benefit is a codebase where parsing behavior is <strong>discoverable and type-safe</strong> instead of driven by magic strings scattered throughout 25-year-old code.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_planned_or_ongoing_features">17. Planned or Ongoing Features</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter documents new, user-facing, features, often refactoring operations, that have been designed but not yet (fully) implemented, or are under architectural investigation.</p>
</div>
<div class="paragraph">
<p>These are distinct from "Major Codebase Improvements" (Chapter 16) which focus on internal architecture and code quality.</p>
</div>
<div class="paragraph">
<p>For user-level specifications of refactoring operations (both existing and proposed), see <a href="19-refactoring-recipes.adoc">Chapter 19: Refactoring Recipes</a>.</p>
</div>
<div class="sect2">
<h3 id="_move_function_between_files">17.1. Move Function Between Files</h3>
<div class="paragraph">
<p><strong>Status</strong>: Phase 1 MVP complete (December 2024), accepts target and removes static keyword.</p>
</div>
<div class="paragraph">
<p><strong>Scope</strong>: Implements the mechanical operation of moving a function definition from one C source file to another while maintaining correct references and visibility.</p>
</div>
<div class="paragraph">
<p>This refactoring pairs with the move function parser API improvements discussed in <a href="16-major-codebase-improvements.adoc#clean-parser-api">Clean Parser API and Multi-File Definition Support</a>.</p>
</div>
<div class="sect3">
<h4 id="_overview_2">17.1.1. Overview</h4>
<div class="paragraph">
<p>Moving a function between files requires:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Identifying the exact function boundaries</p>
</li>
<li>
<p>Determining what declarations are needed in target files</p>
</li>
<li>
<p>Removing <code>static</code> keyword (changing scope to external)</p>
</li>
<li>
<p>Creating or updating header file declarations</p>
</li>
<li>
<p>Managing include directives</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The operation has been implemented in phases, starting with basic move capability and expanding to automatic declaration management.</p>
</div>
</div>
<div class="sect3">
<h4 id="_phase_1_basic_move_complete">17.1.2. Phase 1: Basic Move (COMPLETE)</h4>
<div class="paragraph">
<p><strong>What&#8217;s implemented</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Function boundary detection using parser semantic actions</p>
</li>
<li>
<p>Removal of <code>static</code> keyword when moving between files</p>
</li>
<li>
<p>Proper positioning of function in target file</p>
</li>
<li>
<p>Automatic addition of extern declaration to target file&#8217;s header (non-intelligent placement, no dependency-handling)</p>
</li>
<li>
<p>Availability check: refactoring only appears on function definitions (not call sites)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>What works</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Moves function from source file to different target file</p>
</li>
<li>
<p>Removes <code>static</code> keyword to make function externally callable</p>
</li>
<li>
<p>Adds extern function declaration to target file&#8217;s header automatically</p>
</li>
<li>
<p>Handles comments and decorations around function</p>
</li>
<li>
<p>Works for both C and Yacc files</p>
</li>
<li>
<p>Successfully tested with move_c_function test cases</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>What users must handle manually</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Verify extern declaration placement in header (Phase 1 placement is non-intelligent)</p>
</li>
<li>
<p>Adding <code>#include</code> directives for dependencies</p>
</li>
<li>
<p>Moving tightly-coupled static helper functions</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Value</strong>: Eliminates manual cut/paste, removes 50+ lines of boilerplate per move operation. Declaration automatically added (though placement and dependencies may need manual adjustment).</p>
</div>
</div>
<div class="sect3">
<h4 id="_phase_2_automatic_header_declaration">17.1.3. Phase 2: Automatic Header Declaration</h4>
<div class="paragraph">
<p><strong>Scope</strong>: Generate function declaration in target file&#8217;s header</p>
</div>
<div class="paragraph">
<p><strong>Approach</strong>:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Derive header filename from source: <code>target.c</code>  <code>target.h</code></p>
</li>
<li>
<p>Create header if it doesn&#8217;t exist (with include guards)</p>
</li>
<li>
<p>Insert function declaration at appropriate location</p>
</li>
<li>
<p>User manually adds <code>#include</code> directives</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Challenges</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Reconstructing function signature from Symbol type information</p>
</li>
<li>
<p>Handling various include guard formats (<code>#ifndef</code> vs <code>#pragma once</code>)</p>
</li>
<li>
<p>Finding appropriate insertion point in header</p>
</li>
<li>
<p>Avoiding duplicate declarations</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Value</strong>: Automatically makes moved function callable from other files, follows C convention of declarations in headers.</p>
</div>
</div>
<div class="sect3">
<h4 id="_phase_3_static_helper_function_detection">17.1.4. Phase 3: Static Helper Function Detection</h4>
<div class="paragraph">
<p><strong>Scope</strong>: Identify and optionally move tightly-coupled static functions</p>
</div>
<div class="paragraph">
<p>When moving a function that calls static helper functions in the same file, optionally move those helpers too.</p>
</div>
<div class="paragraph">
<p><strong>Algorithm</strong>:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Parse region containing function to move</p>
</li>
<li>
<p>Find all function calls within that function</p>
</li>
<li>
<p>Check if called functions are static in same file</p>
</li>
<li>
<p>Prompt user to move helpers too</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Value</strong>: Prevents broken builds from missing dependencies, maintains logical cohesion.</p>
</div>
</div>
<div class="sect3">
<h4 id="_phase_4_polish_future">17.1.5. Phase 4: Polish (Future)</h4>
<div class="ulist">
<ul>
<li>
<p>Preview dialog showing what will be moved</p>
</li>
<li>
<p>Better insertion point heuristics</p>
</li>
<li>
<p>Handle embedded documentation (comments, doxygen)</p>
</li>
<li>
<p>Smart handling of related functions</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_design_notes">17.1.6. Design Notes</h4>
<div class="paragraph">
<p>This is more complex than simple text movement because it affects visibility (static vs extern), requires understanding header file conventions, and involves cross-file dependencies.</p>
</div>
<div class="paragraph">
<p><strong>Related work</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Similar functionality exists in c-xref-java version (<code>moveStaticObjectAndMakeItPublic()</code>)</p>
</li>
<li>
<p>Parser infrastructure already proved with extract function refactoring</p>
</li>
<li>
<p>Function boundary detection confirmed working in move function tests</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Dependencies</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Depends on clean parser API for reliable boundary detection</p>
</li>
<li>
<p>Leverages existing reference database for finding all references</p>
</li>
<li>
<p>Uses existing editor buffer manipulation infrastructure</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_references_6">17.1.7. References</h4>
<div class="ulist">
<ul>
<li>
<p>Implementation: <code>src/refactory.c</code> - <code>moveStaticFunctionAndMakeItExtern()</code></p>
</li>
<li>
<p>Parser integration: <code>src/c_parser.y</code>, <code>src/yacc_parser.y</code></p>
</li>
<li>
<p>Tests: <code>tests/test_move_c_function_*/</code></p>
</li>
<li>
<p>Architecture discussion: <a href="16-major-codebase-improvements.adoc#clean-parser-api">Clean Parser API section</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_insights">18. Insights</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter contains notes of all insights, large and small, that I make as I work on this project.
These insights should at some point be moved to some other, more structured, part of this document.
But rather than trying to find a structure where each new finding fits, I&#8217;m making it easy to just dump them here.
We can refactor these into a better and better structure as we go.</p>
</div>
<div class="sect2">
<h3 id="_yacc_semantic_data">18.1. Yacc semantic data</h3>
<div class="paragraph">
<p>As per usual a Yacc grammar requires each non-terminal to have a type.
Those types are named after which types of data they collect and
propagate.  The names always starts with <code>ast_</code> and then comes the
data type.  For example if some non-terminal needs to propagate a
Symbol and a Position that structure would be called
<code>ast_symbolParameterPair</code> ("Pair" being thrown in there for good
measure&#8230;&#8203;).</p>
</div>
<div class="paragraph">
<p>Each of those structures also always carries a begin and end position
for that structure.  That means that any "ast" struct has three
fields, <code>begin</code>, <code>end</code> and the data.  The data are sometimes a struct,
like in this case, but can also be a single value, like an <code>int</code> or a
pointer to a <code>Symbol</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Failed to generate image: Could not load PlantUML. Either require 'asciidoctor-diagram-plantuml' or specify the location of the PlantUML JAR(s) using the 'DIAGRAM_PLANTUML_CLASSPATH' environment variable. Alternatively a PlantUML binary can be provided (plantuml-native in $PATH).

class ast_symbolPositionPair {
Position begin
Position end
}

ast_symbolPositionPair *-- SymbolPositionPair : data

class SymbolPositionPair {
Symbol *symbol
Position position
}</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_navigation_architecture_and_the_preloading_limitation">18.2. Navigation Architecture and the Preloading Limitation</h3>
<div class="paragraph">
<p>Date: 2025-12-22</p>
</div>
<div class="sect3">
<h4 id="_how_symbol_navigation_works">18.2.1. How Symbol Navigation Works</h4>
<div class="paragraph">
<p>Symbol navigation (PUSH/NEXT/PREVIOUS/POP) merges references from <strong>two sources</strong>:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Disk CXrefs Database</strong> - Reflects saved files on disk</p>
</li>
<li>
<p><strong>In-Memory ReferenceableItem Table</strong> - Reflects current server state including preloaded editor buffers</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>When you PUSH on a symbol, the navigation menu creation (function <code>createSelectionMenuForOperation</code>) does:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Load from disk</strong> - Scans CXrefs files for the symbol (via <code>scanReferencesToCreateMenu</code>)</p>
<div class="ulist">
<ul>
<li>
<p>Creates menu items with disk-based line numbers</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Merge from memory</strong> - Maps over the in-memory table (via <code>putOnLineLoadedReferences</code>)</p>
<div class="ulist">
<ul>
<li>
<p>Adds references from parsed/preloaded buffers with current line numbers</p>
</li>
<li>
<p>Duplicate detection prevents the same reference appearing twice</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Build session</strong> - Copies merged references to the navigation session</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This dual-source approach allows navigation without full project parse while providing updated positions for modified files.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_fundamental_limitation">18.2.2. The Fundamental Limitation</h4>
<div class="paragraph">
<p><strong>The Emacs client only preloads the currently active file</strong>, not all modified editor buffers.</p>
</div>
<div class="paragraph">
<p>This creates incorrect navigation after editing non-current files:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">1. PUSH on symbol in common.h  session has refs with disk line numbers
2. NEXT to usage in source1.c (becomes current, gets preloaded)
3. User adds line in source1.c  server knows via preload
4. NEXT to source2.c  source1.c NO LONGER preloaded
   - Server has no knowledge of source1.c modification
   - Session still has old line number from step 1
5. NEXT wraps to source1.c  WRONG LINE
   - Points to line before actual usage</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_why_our_fix_attempt_didnt_work">18.2.3. Why Our Fix Attempt Didn&#8217;t Work</h4>
<div class="paragraph">
<p>We attempted to fix this (commit 8052518a4) by detecting modified files via timestamp comparison and reparsing them in <code>processModifiedFilesForNavigation</code>. <strong>This failed because:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Can only detect modifications in <strong>preloaded</strong> files (current file)</p>
</li>
<li>
<p>Cannot know about changes in non-preloaded modified buffers</p>
</li>
<li>
<p>Client protocol doesn&#8217;t support sending multiple preloaded buffers</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_potential_solutions">18.2.4. Potential Solutions</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Client preloads all modified buffers</strong> - Requires Emacs client changes</p>
</li>
<li>
<p><strong>LSP-style protocol</strong> (did_open/did_change) - Major architectural change</p>
</li>
<li>
<p><strong>Accept the limitation</strong> - Document current behavior</p>
</li>
<li>
<p><strong>Force save before cross-file navigation</strong> - Intrusive UX</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As of 2025-12-22, the limitation remains documented but unfixed. The attempted fix was reverted to preserve the original working architecture.</p>
</div>
</div>
<div class="sect3">
<h4 id="_architectural_invariants">18.2.5. Architectural Invariants</h4>
<div class="paragraph">
<p><strong>MUST be maintained:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Disk CXrefs = State of files on disk (from last tags generation)</p>
</li>
<li>
<p>ReferenceableItem Table = Disk state + preloaded editor buffers</p>
</li>
<li>
<p>Session references = Snapshot at PUSH time</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The table can NEVER reflect non-preloaded modified files because the server doesn&#8217;t receive that information from the client.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_refactoring_recipes">19. Refactoring Recipes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter documents mechanical steps for refactoring operations. Each recipe describes the algorithmic steps that an automated refactoring tool would perform.</p>
</div>
<div class="paragraph">
<p>For detailed discussions of refactoring feature architecture and implementation phases, see <a href="16a-planned-refactorings.adoc">Chapter 16a: Planned Refactoring Features</a>.</p>
</div>
<div class="sect2">
<h3 id="_existing_refactorings">19.1. Existing Refactorings</h3>
<div class="paragraph">
<p>Refactorings that are already implemented and available.</p>
</div>
<div class="sect3">
<h4 id="_rename_symbol">19.1.1. Rename Symbol</h4>
<div class="paragraph">
<p>Implemented. TBD.</p>
</div>
</div>
<div class="sect3">
<h4 id="_extract_function">19.1.2. Extract Function</h4>
<div class="paragraph">
<p>Implemented. TBD.</p>
</div>
</div>
<div class="sect3">
<h4 id="_reorder_parameters">19.1.3. Reorder Parameters</h4>
<div class="paragraph">
<p>Implemented. TBD.</p>
</div>
</div>
<div class="sect3">
<h4 id="_make_function_static">19.1.4. Make Function Static</h4>
<div class="paragraph">
<p><strong>Purpose:</strong> Convert functions that are only used within their compilation unit to <code>static</code> storage class for better encapsulation and compiler optimization.</p>
</div>
<div class="paragraph">
<p><strong>When to use:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Function has external linkage but no external callers</p>
</li>
<li>
<p>Want to make implementation details explicit</p>
</li>
<li>
<p>Enable compiler optimizations and reduce global namespace pollution</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Input:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Non-static function definition</p>
</li>
<li>
<p>All references to that function</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Availability:</strong></p>
</div>
<div class="paragraph">
<p>When cursor is on a non-static function definition where all callers are in the same file.</p>
</div>
<div class="paragraph">
<p><strong>Algorithm:</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Check current storage class</strong> - Skip if already <code>static</code></p>
</li>
<li>
<p><strong>Find definition and all references</strong></p>
<div class="ulist">
<ul>
<li>
<p>Locate function definition (not declarations)</p>
</li>
<li>
<p>Collect all call sites across project</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Verify all references are local</strong></p>
<div class="ulist">
<ul>
<li>
<p>For each reference (excluding definition itself):</p>
<div class="ulist">
<ul>
<li>
<p>Check if in same file as definition</p>
</li>
<li>
<p>If any reference is in different file, abort</p>
</li>
</ul>
</div>
</li>
<li>
<p>Check if declared in header files (public API), abort if yes</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Apply transformation</strong></p>
<div class="ulist">
<ul>
<li>
<p>Find beginning of function definition</p>
</li>
<li>
<p>Insert "static " before return type</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Output:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Function marked as <code>static</code></p>
</li>
<li>
<p>Compiler can optimize more aggressively</p>
</li>
<li>
<p>Clear signal that function is internal</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">// Before - helper function with external linkage
int helperCompare(const void *a, const void *b) {
    return *(int*)a - *(int*)b;
}

void publicSort(int *array, size_t n) {
    qsort(array, n, sizeof(int), helperCompare);
}

// After - explicitly internal
static int helperCompare(const void *a, const void *b) {
    return *(int*)a - *(int*)b;
}

void publicSort(int *array, size_t n) {
    qsort(array, n, sizeof(int), helperCompare);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Benefits:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Better encapsulation and code clarity</p>
</li>
<li>
<p>Enables inlining and other compiler optimizations</p>
</li>
<li>
<p>Smaller symbol tables, no name collisions</p>
</li>
<li>
<p>Safe to refactor (can&#8217;t break external code)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Notes:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Similar to "Unused Symbols" detection but finds LOCAL-ONLY usage instead of NO usage</p>
</li>
<li>
<p>Cannot handle functions used via function pointers passed externally (requires manual verification)</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_suggested_refactorings">19.2. Suggested Refactorings</h3>
<div class="paragraph">
<p>Refactorings that have been proposed, designed, or partially implemented but are not yet available.</p>
</div>
<div class="sect3">
<h4 id="_move_type_to_new_file">19.2.1. Move Type to New File</h4>
<div class="paragraph">
<p><strong>Input:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Type name to move</p>
</li>
<li>
<p>Source file containing type definition</p>
</li>
<li>
<p>Target file (new or existing)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Algorithm:</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Availability</strong></p>
<div class="ulist">
<ul>
<li>
<p>Available when the selected symbol is a type, that symbol is the type to move</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Identify dependencies</strong></p>
<div class="ulist">
<ul>
<li>
<p>Determine what types/macros the definition references/uses</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Create/update target file:</strong></p>
<div class="ulist">
<ul>
<li>
<p>If new file: create with include guards and appropriate includes/forward declarations</p>
</li>
<li>
<p>If existing: open the file and find a suitable insertion location</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Move definition</strong></p>
<div class="ulist">
<ul>
<li>
<p>Copy type definition to target file</p>
</li>
<li>
<p>Add necessary includes and forward declarations</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Replace in source file:</strong></p>
<div class="ulist">
<ul>
<li>
<p>If target is new file: Replace type definition with <code>#include "targetfile.h"</code></p>
</li>
<li>
<p>If target is existing file: Remove type definition, add <code>#include "targetfile.h"</code> if not already present in the source file</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Output:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Type definition moved to target file</p>
</li>
<li>
<p>Source file includes the target file</p>
</li>
<li>
<p>Clean compilation</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Notes:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>For new header files, steps 3-5 are particularly simple: create the new header with the type and replace the definition in source with an include</p>
</li>
<li>
<p>For existing headers, must check if include is already present before adding</p>
</li>
<li>
<p>Forward declarations (e.g., <code>struct foo;</code>) are sufficient for pointer-only dependencies</p>
</li>
<li>
<p>Full type definitions or includes needed for non-pointer members</p>
</li>
</ul>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_introduce_semantic_type_aliases">19.3. Introduce Semantic Type Aliases</h3>
<div class="paragraph">
<p><strong>Purpose:</strong> Make implicit semantic distinctions explicit by introducing type aliases for a single struct used for multiple purposes.</p>
</div>
<div class="paragraph">
<p><strong>When to use:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>A single struct/type is reused for semantically different purposes</p>
</li>
<li>
<p>Different usage contexts use different subsets of fields</p>
</li>
<li>
<p>Want to clarify intent without changing implementation</p>
</li>
<li>
<p>Want to prepare for future type divergence</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Input:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Original type name (e.g., <code>OlcxReferencesStack</code>)</p>
</li>
<li>
<p>List of semantic contexts where type is used (e.g., "browser", "completion", "retrieval")</p>
</li>
<li>
<p>Target file for type aliases (new or existing header)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Algorithm:</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Analyze usage patterns</strong> - Identify distinct semantic contexts where type is used</p>
<div class="ulist">
<ul>
<li>
<p>Group usage sites by purpose/domain</p>
</li>
<li>
<p>Note which fields are used in each context</p>
</li>
<li>
<p>Verify that contexts are truly semantically different</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Create type aliases</strong> - In appropriate header file, define semantic aliases:
<code><code>c
typedef OriginalType SemanticName1;
typedef OriginalType SemanticName2;
// etc.
</code></code></p>
</li>
<li>
<p><strong>Update structure declarations</strong> - Change struct/variable declarations to use semantic types:</p>
<div class="ulist">
<ul>
<li>
<p>Data structure fields</p>
</li>
<li>
<p>Global variables</p>
</li>
<li>
<p>Static variables</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Update function signatures</strong> - Change function parameters to use semantic types:</p>
<div class="ulist">
<ul>
<li>
<p>Functions operating on specific context  specific alias</p>
</li>
<li>
<p>Generic functions operating on any context  generic alias (if created)</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Update call sites</strong> - Verify all usages compile with new types</p>
</li>
<li>
<p><strong>Verify</strong> - Compile to ensure type compatibility</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Output:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Multiple type aliases for same underlying type</p>
</li>
<li>
<p>Declarations and signatures use semantic types</p>
</li>
<li>
<p>Intent clarified through type system</p>
</li>
<li>
<p>Foundation for future divergence</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="paragraph">
<p>Given a "kitchen sink" struct used for three purposes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">// Before - single type for everything
typedef struct OlcxReferencesStack {
    OlcxReferences *top;
    OlcxReferences *root;
} OlcxReferencesStack;

typedef struct SessionData {
    OlcxReferencesStack browserStack;      // Uses: references, symbolsMenu
    OlcxReferencesStack completionsStack;  // Uses: completions
    OlcxReferencesStack retrieverStack;    // Uses: completions
} SessionData;

void pushEmptySession(OlcxReferencesStack *stack);  // Generic</code></pre>
</div>
</div>
<div class="paragraph">
<p>After introducing semantic aliases:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">// After - semantic aliases make intent clear
typedef struct OlcxReferencesStack {
    OlcxReferences *top;
    OlcxReferences *root;
} OlcxReferencesStack;

// Semantic aliases
typedef OlcxReferencesStack ReferencesStack;   // Generic
typedef OlcxReferencesStack BrowserStack;      // For navigation
typedef OlcxReferencesStack CompletionStack;   // For completion
typedef OlcxReferencesStack RetrieverStack;    // For search

typedef struct SessionData {
    BrowserStack    browserStack;
    CompletionStack completionsStack;
    RetrieverStack  retrieverStack;
} SessionData;

void pushEmptySession(ReferencesStack *stack);  // Generic operation</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Benefits:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Intent is immediately clear from type names</p>
</li>
<li>
<p>No runtime or ABI changes (aliases compile to same type)</p>
</li>
<li>
<p>Can add domain-specific operations per type later</p>
</li>
<li>
<p>Enables gradual migration toward separate types if needed</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Notes:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Particularly useful in C where classes/interfaces are unavailable</p>
</li>
<li>
<p>Type aliases are compile-time only - no runtime overhead</p>
</li>
<li>
<p>Can coexist with original type name during migration</p>
</li>
<li>
<p>Common pattern when refactoring legacy C code</p>
</li>
</ul>
</div>
<hr>
<div class="sect3">
<h4 id="_rename_included_file">19.3.1. Rename Included File</h4>
<div class="paragraph">
<p><strong>Purpose:</strong> Rename a file appearing in an include and update all the include directives</p>
</div>
<div class="paragraph">
<p><strong>When to use:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>A (header) file is inappropriately named</p>
</li>
<li>
<p>In the process of renaming a complete C "module" this is one step (until <code>c-xrefactory</code> can do all of that)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Input:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The old and new file names</p>
</li>
<li>
<p>All <code>#include</code> locations for the old file</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Availability</strong></p>
</div>
<div class="paragraph">
<p>When the cursor is on an <code>#include</code> directive. The file it references will be the "source".</p>
</div>
<div class="paragraph">
<p><strong>Algorithm:</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Rename the source file to the destination</strong></p>
</li>
<li>
<p><strong>Update all include locations</strong></p>
<div class="ulist">
<ul>
<li>
<p>This will often include multiple locations</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Output:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>New header file</p>
</li>
<li>
<p>All <code>#include</code> directives updated</p>
</li>
</ul>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_move_function_to_different_file">19.3.2. Move Function to Different File</h4>
<div class="paragraph">
<p>See <a href="16a-planned-refactorings.adoc">Chapter 16a: Planned Refactoring Features</a> for detailed design and implementation status.</p>
</div>
<div class="paragraph">
<p>Proposed refactoring to move a function definition from one C source file to another while automatically managing visibility (static vs extern) and potentially adding necessary declarations and includes.</p>
</div>
<div class="paragraph">
<p><strong>Status</strong>: Phase 1 MVP complete.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_turn_include_guard_into_pragma_once">19.3.3. Turn include guard into pragma once</h4>
<div class="paragraph">
<p>Tentative.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_change_return_type">19.3.4. Change return type</h4>
<div class="paragraph">
<p>Tentative.</p>
</div>
<div class="paragraph">
<p><strong>Purpose:</strong> Convert functions that are only used within their compilation unit to <code>static</code> storage class for better encapsulation and compiler optimization.</p>
</div>
<div class="paragraph">
<p><strong>When to use:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Function has external linkage but no external callers</p>
</li>
<li>
<p>Want to make implementation details explicit</p>
</li>
<li>
<p>Enable compiler optimizations and reduce global namespace pollution</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Input:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Non-static function definition</p>
</li>
<li>
<p>All references to that function</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Availability:</strong></p>
</div>
<div class="paragraph">
<p>When cursor is on a non-static function definition where all callers are in the same file.</p>
</div>
<div class="paragraph">
<p><strong>Algorithm:</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Check current storage class</strong> - Skip if already <code>static</code></p>
</li>
<li>
<p><strong>Find definition and all references</strong></p>
<div class="ulist">
<ul>
<li>
<p>Locate function definition (not declarations)</p>
</li>
<li>
<p>Collect all call sites across project</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Verify all references are local</strong></p>
<div class="ulist">
<ul>
<li>
<p>For each reference (excluding definition itself):</p>
<div class="ulist">
<ul>
<li>
<p>Check if in same file as definition</p>
</li>
<li>
<p>If any reference is in different file, abort</p>
</li>
</ul>
</div>
</li>
<li>
<p>Check if declared in header files (public API), abort if yes</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Apply transformation</strong></p>
<div class="ulist">
<ul>
<li>
<p>Find beginning of function definition</p>
</li>
<li>
<p>Insert "static " before return type</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Output:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Function marked as <code>static</code></p>
</li>
<li>
<p>Compiler can optimize more aggressively</p>
</li>
<li>
<p>Clear signal that function is internal</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">// Before - helper function with external linkage
int helperCompare(const void *a, const void *b) {
    return *(int*)a - *(int*)b;
}

void publicSort(int *array, size_t n) {
    qsort(array, n, sizeof(int), helperCompare);
}

// After - explicitly internal
static int helperCompare(const void *a, const void *b) {
    return *(int*)a - *(int*)b;
}

void publicSort(int *array, size_t n) {
    qsort(array, n, sizeof(int), helperCompare);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Benefits:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Better encapsulation and code clarity</p>
</li>
<li>
<p>Enables inlining and other compiler optimizations</p>
</li>
<li>
<p>Smaller symbol tables, no name collisions</p>
</li>
<li>
<p>Safe to refactor (can&#8217;t break external code)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Notes:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Similar to "Unused Symbols" detection but finds LOCAL-ONLY usage instead of NO usage</p>
</li>
<li>
<p>Cannot handle functions used via function pointers passed externally (requires manual verification)</p>
</li>
<li>
<p>Estimated complexity: ~0.3 Move Function Phase 1</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_archive">20. Archive</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this section you can find some descriptions and saved texts that
described how things were before. They are no longer true, since that
quirk, magic or bad coding is gone. But it is kept here as an archive
for those wanting to do backtracking to original sources.</p>
</div>
<div class="sect2">
<h3 id="_memory_strategies">20.1. Memory strategies</h3>
<div class="paragraph">
<p>There were a multitude of specialized memory allocation functions. In
principle there where two types, static and dynamic. The dynamic could
be exteded using a overflow handler.</p>
</div>
<div class="paragraph">
<p>Also one type had a struct where the actual area was extended beyond
the actual struct. This was very confusing&#8230;&#8203;</p>
</div>
<div class="sect3">
<h4 id="_static_memory_allocation">20.1.1. Static memory allocation</h4>
<div class="paragraph">
<p>Static memory (SM_ prefix) are static areas allocated by the compiler
which is then indexed using a similarly named index variable
(e.g. <code>ftMemory</code> and <code>ftMemoryIndex</code>), something the macros took
advantage of. These are</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ftMemory</code></p>
</li>
<li>
<p><code>ppmMemory</code></p>
</li>
<li>
<p><code>mbMemory</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>One special case of static memory also exist:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>stackMemory</code> - synchronous with program structure and has CodeBlock
markers, so there is a special <code>stackMemoryInit()</code> that initializes
the outermost CodeBlock</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These areas cannot be extended, when it overruns the program stops.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_trivial_prechecks">20.2. Trivial Prechecks</h3>
<div class="paragraph">
<p>The refactorer can call the server using <code>parseBufferUsingServer()</code> and add some extra options (in text form).
One example is <code>setMovingPrecheckStandardEnvironment()</code> where it calls the server with <code>-olcxtrivialprecheck</code>.</p>
</div>
<div class="paragraph">
<p>However <code>parseBufferUsingServer()</code> uses <code>callServer()</code> which never <code>answerEditAction()</code>.</p>
</div>
<div class="paragraph">
<p>In <code>answerEditAction()</code> the call to (unused) <code>olTrivialRefactoringPreCheck()</code> also requires an <code>options.trivialPreCheckCode</code> which is neither send by <code>setMovingPrecheckStandardEnvironment()</code> nor parsed by <code>processOptions()</code>.</p>
</div>
<div class="paragraph">
<p>The only guess I have is that previously all prechecks where handled by the <code>-olcxtrivialprecheck</code> option in calls to the server, and have now moved to their respective refactorings.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This theory should be checked by looking at the original source of the precheck functions and compare that with any possible checks in the corresponding refactoring code.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_caching_system">20.3. Caching System</h3>
<div class="paragraph">
<p><strong>The caching system described below has been archived as it is no longer part of the current architecture.</strong></p>
</div>
<div class="paragraph">
<p>The c-xrefactory included a sophisticated caching system that enabled
incremental parsing by caching parsed input streams, parser state, and
file modification tracking. This optimization allowed for faster
re-analysis when only portions of source files had changed. It also
allowed the system to detect out-of-memory situations, discard, flush
and re-use memory during file processing.</p>
</div>
<div class="sect3">
<h4 id="_core_design_principles">20.3.1. Core Design Principles</h4>
<div class="paragraph">
<p><strong>Cache Point Model</strong>: The system placed strategic snapshots of parser state at external definition boundaries (functions, global variables, etc.). When files were re-processed, the system could validate cache integrity, recover from cache points, and resume parsing only from the first changed definition onward.</p>
</div>
<div class="paragraph">
<p><strong>Separation of Concerns</strong>: Recent refactoring had separated file tracking from cache validation:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>updateFileModificationTracking()</code> - Updated file timestamps without side effects</p>
</li>
<li>
<p><code>isFileModifiedSinceCached()</code> - Pure validation function for cache integrity</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_key_components">20.3.2. Key Components</h4>
<div class="paragraph">
<p><strong>Cache Point Management</strong> (<code>caching.c</code>):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>placeCachePoint(bool)</code> - Placed strategic parser state snapshots</p>
</li>
<li>
<p><code>recoverFromCache()</code> - Restored parser state from cache points</p>
</li>
<li>
<p><code>recoverCachePointZero()</code> - Reset to initial cache state</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>File Modification Tracking</strong>:</p>
</div>
<div class="paragraph">
<p>The <code>FileItem</code> structure maintained multiple timestamp fields for tracking file modification:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">struct FileItem {
    time_t lastModified;    // File's actual modification time
    time_t lastInspected;   // When we last checked the file
    // ... other fields
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Input Stream Caching</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>cacheInput()</code> - Cached tokenized input from lexer</p>
</li>
<li>
<p><code>cachingIsActive()</code> - Checked if caching was currently enabled</p>
</li>
<li>
<p><code>activateCaching()</code> / <code>deactivateCaching()</code> - Controlled caching state</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_parser_integration">20.3.3. Parser Integration</h4>
<div class="paragraph">
<p><strong>C Parser Integration</strong>: Both C and Yacc parsers placed cache points after each <code>external_definition</code>, but only when not processing include files (<code>includeStack.pointer == 0</code>).</p>
</div>
<div class="paragraph">
<p><strong>Parser-Specific Behavior</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>C Parser</strong>: Full caching enabled with regular cache point placement</p>
</li>
<li>
<p><strong>Yacc Parser</strong>: Explicitly deactivated caching via <code>deactivateCaching()</code> but still placed strategic cache points</p>
</li>
<li>
<p><strong>Include Files</strong>: Cache points skipped during include processing</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_system_dependencies">20.3.4. System Dependencies</h4>
<div class="paragraph">
<p>The caching system was deeply integrated throughout the parsing pipeline:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Component</th>
<th class="tableblock halign-left valign-top">Functions Used</th>
<th class="tableblock halign-left valign-top">Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>main.c</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>initCaching()</code>, <code>activateCaching()</code>, <code>recoverCachePointZero()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Lifecycle control</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lexer.c</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cacheInput()</code>, <code>cachingIsActive()</code>, <code>deactivateCaching()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Input processing</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>yylex.c</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>updateFileModificationTracking()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">File tracking</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>filetable.c</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>updateFileModificationTracking()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">File management</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>xref.c</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>recoverFromCache()</code>, recovery functions</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cross-reference coordination</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>c_parser.y</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>placeCachePoint()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">C grammar integration</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>yacc_parser.y</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>deactivateCaching()</code>, <code>placeCachePoint()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yacc grammar integration</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_performance_characteristics_3">20.3.5. Performance Characteristics</h4>
<div class="paragraph">
<p><strong>Cache Hit Scenarios</strong>:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Full Cache Hit</strong>: No file modifications since last parse - parser state recovered from cache point zero with minimal re-processing</p>
</li>
<li>
<p><strong>Partial Cache Hit</strong>: File modified after Nth definition - recovery from cache point N with re-parsing only from point of change onward</p>
</li>
<li>
<p><strong>Cache Miss</strong>: File structure changed or timestamps invalid - full re-parse with new cache points placed</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Optimization Benefits</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Memory usage scales with number of definitions, not file size</p>
</li>
<li>
<p>File modification checking minimizes unnecessary re-reads</p>
</li>
<li>
<p>Input stream caching reduces lexer overhead</p>
</li>
<li>
<p>Strategic cache point placement enables clean recovery at definition boundaries</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_huge_memory">20.4. HUGE Memory</h3>
<div class="paragraph">
<p>Previously a HUGE model was also available (by re-compilation) to
reach file numbers, lines and columns above 22 bits. But if you have
more than 4 million lines (or columns!) you should probably do
something radical before attempting cross referencing and refactoring.</p>
</div>
</div>
<div class="sect2">
<h3 id="_bootstrapping">20.5. Bootstrapping</h3>
<div class="sect3">
<h4 id="_bootstrap_removed">20.5.1. BOOTSTRAP REMOVED!</h4>
<div class="paragraph">
<p>Once the FILL-macros was removed, we could move the enum-generation to
use the actual <code>c-xref</code>. So from now on we build <code>c-xref</code> directly
from the sources in the repo. Changes to any enums will trigger a
re-generation of the enumTxt-files but since the enumTxt-files are
only conversion of enum values to strings any mismatch will not
prevent compilation, and it would even be possible to a manual
update. This is a big improvement over the previous situation!</p>
</div>
</div>
<div class="sect3">
<h4 id="_fills_removed">20.5.2. FILLs REMOVED!</h4>
<div class="paragraph">
<p>As indicated in <a href="#_fill_macros">FILL macros</a> the bootstrapping of FILL-macros has
finally and fully been removed.</p>
</div>
<div class="paragraph">
<p>Gone is also the <code>compiler_defines.h</code>, which was just removed without
any obvious adverse effects.  Maybe that will come back and bite me
when we move to more platforms other than linux and MacOS&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>Left is, at this point, only the <code>enumTxt</code> generation, so most of the
text below is kept for historical reasons.</p>
</div>
</div>
<div class="sect3">
<h4 id="_rationale">20.5.3. Rationale</h4>
<div class="paragraph">
<p><em>c-xref</em> uses a load of structures, and lists of them, that need to be
created and initialized in a lot of places (such as the parsers). To
make this somewhat manageable, <em>c-xref</em> itself parses the strucures
and generates macros that can be used to fill them with one call.</p>
</div>
<div class="paragraph">
<p><em>c-xref</em> is also bootstrapped into reading in a lot of predefined
header files to get system definitions as "preloaded
definitions".</p>
</div>
<div class="paragraph">
<p>Why this pre-loading was necessary, I don&#8217;t exactly know. It
might be an optimization, or an idea that was born early and then just
kept on and on. In any case it creates an extra complexity
building and maintaining and to the structure of <em>c-xref</em>.</p>
</div>
<div class="paragraph">
<p>So this must be removed, see below.</p>
</div>
</div>
<div class="sect3">
<h4 id="_mechanism">20.5.4. Mechanism</h4>
<div class="paragraph">
<p>The bootstrapping uses <em>c-xref</em>'s own capability to parse C-code and
parse those structures and spit out filling macros, and some other
stuff.</p>
</div>
<div class="paragraph">
<p>This is done using options like `-task_regime_generate' which prints a
lot of data structures on the standard output which is then fed into
generated versions of <em>strFill</em>, <em>strTdef</em>(no longer exists) and
<em>enumTxt</em> by the Makefile.</p>
</div>
<div class="paragraph">
<p>The process starts with building a <em>c-xref.bs</em> executable from checked
in sources. This compile uses a BOOTSTRAP define that causes some
header files to include pre-generated versions of the generated files
(currently <em>strFill.bs.h</em> and <em>enumTxt.bs.h</em>) which should work in all
environments.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
if you change the name of a field in a structure that is subject
to FILL-generation you will need to manually update the
<em>strFill.bs.h</em>, but a "make cleaner all" will show you where those are.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>After the <em>c-xref.bs</em> has been built, it is used to generate <em>strFill</em>
and <em>enumTxt</em> which might include specific structures for the current
environment.</p>
</div>
<div class="paragraph">
<p>HOWEVER: if FILL macros are used for structures which are different on
some platforms, say a FILE structure, that FILL macro will have
difference number of arguments, so I&#8217;m not sure how smart this "smart"
generation technique actually is.</p>
</div>
<div class="paragraph">
<p>TODO: Investigate alternative approaches to this generate "regime",
perhaps move to a "class"-oriented structure with initialization
functions for each "class" instead of macros.</p>
</div>
</div>
<div class="sect3">
<h4 id="_compiler_defines">20.5.5. Compiler defines</h4>
<div class="paragraph">
<p>In <em>options.h</em> there are a number of definitions which somehow are
sent to the compiler/preprocessor or used so that standard settings
are the same as if a program will be compiled using the standard
compiler on the platform. At this point I don&#8217;t know exactly how this
conversion from C declarations to compile time definitions is done,
maybe just entered as symbols in one of the many symboltables?</p>
</div>
<div class="paragraph">
<p>Typical examples include "__linux" but also on some platforms things
like "fpos_t=long".</p>
</div>
<div class="paragraph">
<p>I&#8217;ve implemented a mechanism that uses "gcc -E -mD" to print out and
catch all compiler defines in <code>compiler_defines.h</code>. This was necessary
because of such definitions on Darwin which where not in the
"pre-programmed" ones.</p>
</div>
<div class="paragraph">
<p>TODO?: As this is a more general approach it should possibly
completely replace the "programmed" ones in <code>options.c</code>?</p>
</div>
</div>
<div class="sect3">
<h4 id="_enumtxt_generation_removed">20.5.6. EnumTxt generation REMOVED!</h4>
<div class="paragraph">
<p>To be able to print the string values of enums the module generate.c
(called when regime was RegimeGenerate) could also generate string
arrays for all enums. By replacing that with some pre-processor magic
for the few that was actually needed (mostly in log_trace() calls) we
could do away with that whole "generate" functionality too.</p>
</div>
<div class="paragraph">
<p>(Last commit with enum generation intact is <a href="https://github.com/thoni56/c-xrefactory/commit/aafd7b1f813f2c17c684ea87ac87a0be31cdd4c4" class="bare">https://github.com/thoni56/c-xrefactory/commit/aafd7b1f813f2c17c684ea87ac87a0be31cdd4c4</a>.)</p>
</div>
</div>
<div class="sect3">
<h4 id="_enumtxt">20.5.7. enumTxt</h4>
<div class="paragraph">
<p>For some cases the string representing the value of an Enum is needed.
<code>c-xref</code> handles this using the "usual" 'parse code and generate' method.
The module <code>generate.c</code> does this generation too.</p>
</div>
</div>
<div class="sect3">
<h4 id="_include_paths">20.5.8. Include paths</h4>
<div class="paragraph">
<p>Also in <em>options.h</em> some standard-like include paths are added, but
there is a better attempt in <em>getAndProcessGccOptions()</em> which uses
the compiler/preprocessor itself to figure out those paths.</p>
</div>
<div class="paragraph">
<p>TODO?: This is much better and should really be the only way, I think.</p>
</div>
</div>
<div class="sect3">
<h4 id="_problems">20.5.9. Problems</h4>
<div class="paragraph">
<p>Since at bootstrap there must exist FILL-macros with the correct field
names this strategy is an obstacle to cleaning up the code since every
field is referenced in the FILL macros. When a field (in a structure
which <strong>are</strong> filled using the FILL macro) changes name, this will make
initial compilation impossible until the names of that field is also
changed in the <code>strFill.bs.h</code> file.</p>
</div>
<div class="paragraph">
<p>One way to handle this is of course to use <code>c-xrefactory</code> itself and
rename fields. This requires that the project settings also include a
pass with BOOTSTRAP set, which it does.</p>
</div>
</div>
<div class="sect3">
<h4 id="_removing">20.5.10. Removing</h4>
<div class="paragraph">
<p>I&#8217;ve started removing this step. In TODO.org I keep a hierarchical list
of the actions to take (in a Mikado kind of style).</p>
</div>
<div class="paragraph">
<p>The basic strategy is to start with structures that no other structure
depends on. Using the script <code>utils/struct2dot.py</code> you can generate a
DOT graph that shows those dependencies.</p>
</div>
<div class="paragraph">
<p>Removal can be done in a couple of ways</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>If it&#8217;s a very small structure you can replace a call to a <code>FILL_XXX()</code> macro
with a <a href="https://gcc.gnu.org/onlinedocs/gcc/Compound-Literals.html">compound literal</a>.</p>
</li>
<li>
<p>A better approach is usually to replace it with a <code>fillXXX()</code> function, or even
better, with a <code>newXXX()</code>, if it consistently is preceeded with an allocation
(in the same memory!). To see what fields vary you can grep all such calls, make a
CSV-file from that, and compare all rows.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_strtdef_h">20.5.11. strTdef.h</h4>
<div class="paragraph">
<p>The <code>strTdef.h</code> was generated using the option <code>-typedefs</code> as a part
of the old <code>-task_regime_generate</code> strategy and generated typedef
declarations for all types found in the parsed files.</p>
</div>
<div class="paragraph">
<p>I also think that you could actually merge the struct definition with
the typedef so that <em>strTdef.h</em> would not be needed. But it seems that
this design is because the structures in <em>proto.h</em> are not a directed
graph, so loops makes that impossible. Instead the typedefs are
included before the structs:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>#include "strTdef.h"</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>struct someNode {
    S_someOtherNode *this;
    ...</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>struct someOtherNode {
    S_someNode *that;
    ...</pre>
</div>
</div>
<div class="paragraph">
<p>This is now ideomatically solved using the structs themselves:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>struct someNode {
    struct someOtherNode *this;
    ...</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>struct someOtherNode {
    struct someNode *that;
    ...</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_fill_macros">20.6. FILL macros</h3>
<div class="paragraph">
<p><em><strong>The FILL macros are now fully replaced by native functions or some other,</strong></em>
<em><strong>more refactoring-friendly, mechanism. Yeah!</strong></em></p>
</div>
<div class="paragraph">
<p>During bootstrapping a large number of macros named <em>__FILL_xxxx</em> is
created. The intent is that you can fill a complete structure with one
call, somewhat like a constructor, but here it&#8217;s used more generally
every time a complex struct needs to be initialized.</p>
</div>
<div class="paragraph">
<p>There are even <em>_FILLF_xxx</em> macros which allows filling fields in
sub-structures at the same time.</p>
</div>
<div class="paragraph">
<p>This is, in my mind, another catastrophic hack that makes
understanding, and refactoring, <code>c-xrefactory</code> such a pain. Not to
mention the extra bootstrap step.</p>
</div>
<div class="paragraph">
<p>I just discovered the compound literals of C99. And I&#8217;ll experiment
with replacing some of the FILL macros with compound literals assignments
instead.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>FILL_symbolList(memb, pdd, NULL);</pre>
</div>
</div>
<div class="paragraph">
<p>could become (I think):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>memb = (SymbolList){.d = pdd, .next = NULL};</pre>
</div>
</div>
<div class="paragraph">
<p>If successful, it would be much better, since we could probably get
rid of the bootstrap, but primarily it would be more explicit about
which fields are actually necessary to set.</p>
</div>
</div>
<div class="sect2">
<h3 id="_users">20.7. Users</h3>
<div class="paragraph">
<p><strong>The <code>-user</code> option has now been removed, both in the tool and the
  editor adaptors, and with it one instance of a hashlist, the
  <code>olcxTab</code>, which now is a single structure, the <code>sessionData</code>.</strong></p>
</div>
<div class="paragraph">
<p>There is an option called <code>-user</code> which Emacs sets to the frame-id. To
me that indicates that the concept is that for each frame you create
you get a different "user" with the <code>c-xref</code> server that you (Emacs)
created.</p>
</div>
<div class="paragraph">
<p>The jedit adapter seems to do something similar:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>options.add("-user");
Options.add(s.getViewParameter(data.viewId));</pre>
</div>
</div>
<div class="paragraph">
<p>Looking at the sources to find when the function
<code>olcxSetCurrentUser()</code> is called it seems that you could have
different completion, refactorings, etc. going on at the same time in
different frames.</p>
</div>
<div class="paragraph">
<p>Completions etc. requires user interaction so they are not controlled
by the editor in itself only. At first glance though, the editor
(Emacs) seems to block multiple refactorings and referencs maintenance
tasks running at the same time.</p>
</div>
<div class="paragraph">
<p>This leaves just a few use cases for multiple "users", and I think it
adds unnecessary complexity. Going for a more "one user" approach,
like the model in the language server protocol, this could really be
removed.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2026-01-06 21:53:19 UTC
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/highlight.min.js"></script>
<script>
if (!hljs.initHighlighting.called) {
  hljs.initHighlighting.called = true
  ;[].slice.call(document.querySelectorAll('pre.highlight > code[data-lang]')).forEach(function (el) { hljs.highlightBlock(el) })
}
</script>
</body>
</html>