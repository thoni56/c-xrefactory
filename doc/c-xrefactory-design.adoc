:source-highlighter: highlightjs
:icons: font
:numbered:
:toc: left
:pp: ++
:title-page:
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

= C-xrefactory - a C/Yacc/Java refactoring and code browsing tool - Design Documentation
v{VERSION} - Generated {localdate}

WARNING: This document is very much a work in progress.

== Intro

`c-xrefactory` is a project aiming at restoring the sources of an old,
but very useful, project to a state where they can be enhanced and be
the foundation for a highly capable refactoring browser.

It _is_ currently in working condition, so you can use it. For
information about that, see the
https://github.com/thoni56/c-xrefactory/blob/main/README.md[README.md].

=== Caution

As indicated by the
https://github.com/thoni56/c-xrefactory/blob/main/README.md[README.md],
this is a long term restoration project. So anything you find in this
document might be old, incorrect, guesses, temporary holders for
thoughts or theories. Or actually true and useful.

Especially names of variables, functions and modules is prone to
change as understanding of them increases. They might also be
refactored into something entirently different.

As this point this document is just a collection of unstructured
thougths, guesses, historic anecdotes and ideas. For example, the
previously existing, and also unstructured, wiki pages have just been
pasted in here in an attempt to collect everything in a single
document. Perhaps that will make it possible to "refactor" the
information into something actually useful.

The last part of this document is an Archive where completely obsolete
descriptions have been moved for future software archeologists to
find.

=== Background

You will find some background about the project in the
https://github.com/thoni56/c-xrefactory/blob/main/README.md[README.md].

This document tries to collect the knowledge and understanding about
how `c-xrefactory` actually works, plans for making it better, both in
terms of working with the source, its structure and its features.

Hopefully over time this will be the design documentation of
`c-xrefactory`, which, at that time, will be a fairly well structured
and useful piece of software.

=== Goal

Ultimately `c-xrefactory` could become _the_ refactoring browser for C
(but probably not for Java), the one that everybody uses. As suggested
by @tajmone in #39, by switching to a general protocol, we could
possibly plug this in to many editors.

However, to do that we need to refactor out the protocol parts. And to
do that we need a better structure, and to dare to change that, we
need to understand more of the intricacies of this beast, and we need
tests. So the normal legacy code catch 22 applies...

Test coverage is starting to look good, coming up to about 80% at the
time of writing this. But that is mostly "application level"
execution, rather than actual tests.

=== Developing, here be dragons...

First the code is *terrible*, lost of single and double character
variables (`cc`, `ccc`, ..) and lost of administration on local
variables rather than the structures that are actually there. And
there are also a lot of macros. Unfortunately macros are hard to
refactor to functions. (But I'm making progress...)

As there is no general way to refactor a macro to a function, various
techniques must be applied. I wrote https://www.responsive.se/thomas/2020/05/14/refactoring-macros-to-functions/[a blog post]
about one that have been fairly successful.

But actually it's rather fun to be able to make small changes and
see the structure emerge, hone your refactoring and design skills,
and working on a project that started 20 years ago which still is
valuable, to me, and I hope, to others.

There should probably be a whole section on how to contribute and
develop `c-xrefactory` but until then here's a short list of what
you need:

- C development environment (GNU/Clang/Make/...)
- Unittests are written using https://github.com/cgreen-devs/cgreen[`Cgreen`]
- Clean code and refactoring knowledge (to drive the code to a better and cleaner state)

Helpful would be:

- Compiler building knowledge (in the general sense, Yacc, but AST:s and symbol table stuff are heavily used)
- Java knowledge to be able to bring the Java support up to modern versions (probably not going to happen...)

=== Overall Functionality

The _c-xref_ program is actually a mish-mash of a multitude of
features baked into one program. This is the major cause of the mess
that it is source-wise.

It was

- a generator for persistent cross-reference data
- a reference server for editors, serving cross-reference, navigational and completion data over a protocol
- a refactoring server (the worlds first to cross the Refactoring Rubicon)
- [.line-through]#an HTML cross-reference generator (probably the root of the project)#
- [.line-through]#a C macro generator for structure fill (and other) functions#

It is the first three that are unique and constitutes the great value
of this project. The last two have been removed from the source, the
last one because it was a hack and prevented modern, tidy, building,
coding and refactoring. The HTML cross-reference generator has been
superseeded by modern alternatives like Doxygen and is not at the core
of the goal of this project.

One might surmise that it was the HTML-crossreference generator that
was the initial purpose of what the original `Xrefactory` was based
upon. Once that was in place the other followed, and were basically
only bolted on top without much re-architecting the C sources.

What we'd like to do is partition the project into separate parts,
each having a clear usage.

As it happens, the things that `c-xref` can do is also the
[.line-through]#five four# three modes (previously "task regimes") that are
declared in the sources:

  - Xref
  - [.line-through]#HtmlGenerate#
  - Editor Server
  - Refactory
  - [.line-through]#Generate# (was removed when we finally managed to remove the bootstrap step)

=== Building

You should be able build `c-xref` using something like (may have changed over time...)

    cd src
    make
    make unit
    make test

But since the details of the building process are somewhat contrieved
and not so easy to see through, here's the place where that should be
described.

One step in the build process was generating initialization information
for all the things in standard include files, which of course became
very dependent on the system you are running this on. This has now moved
into functions inside `c-xref` itself, like finding DEFINEs and include
paths.

The initial recovered c-xrefactory relied on having a working _c-xref_
for the current system. I don't really know how they managed to do
that for all the various systems they were supporting.

Modern thinking is that you should always be able to build from
source, so this is something that needed change. We also want to
distribute _c-xref_ as an el-get library which requires building from
source and should generate a version specific for the current system.

[.line-through]#The strategy selected, until some better idea comes along, is to try
to build a _c-xref.bs_, if there isn't one already, from the sources in
the repository and then use that to re-generate the definitions and
rebuild a proper _c-xref_. See Bootstrapping.#

We have managed to remove the complete bootstrapping step, so `c-xrefactory`
now builds like any other project.

=== Versions

The current sources are in 1.6.X range. This is the same as the orginal
xrefactory and probably also the proprietary C++ supporting version.

There is an option, "-xrefactory-II", that might indicate that
something was going on. But currently the only difference seems to be
if the edit server protocol output is in the form of non-structured
fprintf:s or using functions in the `ppc`-family (either calling
`ppcGenRecord()` or `fprint`ing using some PPC-symbol). This, and
hinted to in how the emacs-part starts the server and some initial
server option variables in refactory.c, indicates that the
communication from the editor and the refactory server is using
this. It does *not* look like this is a forward to next generation
attempt.

What we should do is investigate if this switch actually is used
anywhere but in the editor server context, and if so, if it can be
made the default and the 'non-xrefactory-II' communication removed.

== Architecture

=== Context

[plantuml, context-diagram, png]
....
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Context.puml

!define SPRITESURL https://raw.githubusercontent.com/plantuml-stdlib/gilbarbara-plantuml-sprites/v1.0/sprites
!include SPRITESURL/emacs.puml

LAYOUT_WITH_LEGEND()

Person_Ext(developer, "Developer", "Edits source code using an editor")
System_Ext(editor, "Editor", "Allows Developer to modify source code and perform refactoring operations", $sprite="emacs")
SystemDb_Ext(sourceCode, "Source Code")
System(cxref, "c-xrefactory", "Analyses source code, receives and processes requests for navigation and refactoring")

Rel(developer, editor, "GUI", "Usual editor/IDE operations")
Rel(cxref, sourceCode, "read/analyze")
Rel(editor, sourceCode, "normal editing operations")
Rel(editor, cxref, "navigation and refactoring requests")
Rel(cxref, editor, "positioning and editing responses")
....


=== Containers


[plantuml, containers-diagram, png]
....
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml

!define SPRITESURL https://raw.githubusercontent.com/plantuml-stdlib/gilbarbara-plantuml-sprites/v1.0/sprites
!include SPRITESURL/emacs.puml
!include SPRITESURL/c.puml

LAYOUT_WITH_LEGEND()

Person_Ext(developer, "Developer", "Edits source code using an editor")
System_Ext(editor, "Editor", "Allows Developer to modify source code and perform refactoring operations", $sprite="emacs")
SystemDb_Ext(sourceCode, "Source Code")
System_Boundary(cxref, "c-xrefactory Browser") {
  Container(editorExtension, "Editor Extension", "Plugin", "Extends the Editor with c-xref operations and interfaces to the c-xrefactory API", $sprite="emacs")
  Container(cxrefCore, "c-xref", "C Language program", "Refactoring Browser core", $sprite="c")
  Container(settingsStore, "settings", "Non-standard format settings file", "Configuration file for project settings")
  ContainerDb(tagsDB, "tagsDB", "Source Code information storage", "Stores all information about the source code in the project which is updated by scanning all or parts of it when required.")
}

Rel(cxrefCore, settingsStore, "read")
Rel(editorExtension, settingsStore, "writes", "new project wizard")
Rel(editorExtension, cxrefCore, "API", "To request information and get commands to modify code")
Rel(developer, editor, "GUI", "Usual editor/IDE operations")
Rel(editor, editorExtension, "Extends", "Editors extension protocol")
Rel(developer, settingsStore, "edit")
Rel(cxrefCore, tagsDB, "read/write")
Rel(cxrefCore, sourceCode, "read/analyze")
Rel(editor, sourceCode, "normal editing operations")
Rel(editorExtension, sourceCode, "extended c-xrefactory operations")
....

=== Components

[plantuml, editor-extension-component, png]
....
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Component.puml

!define SPRITESURL https://raw.githubusercontent.com/plantuml-stdlib/gilbarbara-plantuml-sprites/v1.0/sprites

title
  Emacs Extension Component Diagram
end title

Component(cxref, "c-xref.el")
Component(cxrefactory, "c-xrefactory.el")
....

[plantuml, c-xref-component, png]
....
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Component.puml

!define SPRITESURL https://raw.githubusercontent.com/plantuml-stdlib/gilbarbara-plantuml-sprites/v1.0/sprites

title
  C-xref C program Component Diagram
end title

Component(main, main.c)
Component(cxref, cxref.c)
Component(cxfile, cxfile.c)
....

=== Code

== Data Structures

There is a lot of different data structures used in `c-xrefactory`.
This is a first step towards visualising them.

=== Symbols and References

So, why is there no connection between the symbols and the references?!?

[plantuml, png]
....
class Symbol
Symbol : char *name
Symbol : Position position
Symbol : SymbolBits bits
Symbol -> Symbol :  next

class SymbolList
SymbolList -> SymbolList : next
SymbolList -> Symbol : symbol

class ReferencesItem
ReferencesItem : char *name
ReferencesItem : ReferencesBits bits
ReferencesItem -> Reference : references
ReferencesItem -> ReferencesItem : next

class Reference
Reference : Usage usage
Reference : Position position
Reference -> Reference : next
....


=== Modes

`c-xrefactory` operates in different modes ("regimes" in original
`c-xref` parlance):

- xref - batch mode reference generation
- server - editor server
- refactory - refactory browser

The default mode is "xref". The command line options `-server` and `-refactory`
selects one of the other modes. Branching is done in the final lines in
`main()`.

The code for the modes are intertwined, probably through re-use of
already existing functionality when extending to a refactoring
browser.

One evidence for this is that the refactory module calls the "main
task" as a "sub-task".  This forces some intricate fiddling with the
options data structure, like copying and caching it.  Which I don't
fully understand yet.

TODO?: Strip away the various "regimes" into more separated concerns
and handle options differently.


== Passes

There is a variable in `main()` called `firstPassing` which is set and passed
down through `mainEditServer()` until it is reset in
`mainFileProcessingInitialisations()` after `initCaching()`.

This is probably connected to the fact that `c-xref` allows for passing
over the analyzed source multiple passes in case you compile the
project sources with different C defines. Variables in the `c-xref`
sources indicate this, e.g the loops in `mainEditServerProcessFile()`
and `mainXrefProcessInputFile()` (which are both strangely limited by
setting the maxPass variable to 1 before entering the loop...).

== Parsers

_C-xref_ uses a patched version of Berkley yacc to generate
parsers. There are a number of parsers

- C
- Yacc
- Java
- C expressions

There are also small traces of calls to the C++ parser that existed
but was proprietary.

The patch to byacc is mainly to the skeleton and seems to relate
mostly to handling of errors and adding a recursive parsing feature
that is required for Java. It is not impossible that the change can be
adapted to other versions of yacc, but this has not be tried.

Some changes are also made to be able to accomodate multiple parsers
in the same executable. The Makefile generates the parsers and renames
them as appropriate.

TODO?: Should we just scrap the Java support and focus on C since a)
the Java support is for ancient Java versions and b) there are more
mature Java refactoring support available?


== Reading Files

Here are some speculations about how the complex file reading is structured.

Each file is identified by a filenumber, which is an index into the
file table, and seems to have a `lexBuffer` tied to it so that you can
just continue from where ever you were. That in turn contains a
`CharacterBuffer` (renamed from `charBuf`) that handles the actual
character reading.

And there is also an "editorBuffer"...

The intricate interactions between these are hard to follow as the code
here are littered with short character names which are copies of fields
in the structures, and infested with many macros, probably in an ignorant
attempt at optimizing. ("The root of all evil is premature optimization" and
"Make it work, make it right, make it fast".)

It seems to all start in `initInput()` in `yylex.c` where the only
call to `fillFileDescriptor()` is made. But you might wonder why this
function does some initial reading, this should be pushed down to the
buffers in the file descriptor.

=== Lexing/scanning

Lexing/scanning is performed in two layers, one in `lexer.c` which
seems to be doing the actual lexing into lexems which are put in a
lexembuffer. The higher level "scanning" is performed, as per ususal,
by `yylex.c`. `lexembuffer` defines some functions to put and get
lexems, chars (identifiers and file names?) as well as integers and
positions.

Previously a HUGE model was also available (by re-compilation) to
reach file numbers, lines and columns above 22 bits. But if you have
more than 4 million lines (or columns!) you should probably do
something radical before attempting cross referencing and refactoring.

At this point the put/get lexem functions take a pointer to a pointer
to chars (which presumably is the lexem stream in the lexembuffer)
which it also advances. It would be much better to call them with a
lexemBuffer but there seems to be a few cases where the destination
(often `dd`) is not a lexem stream inside a lexemBuffer.


== Reference Database

`c-xref` creates a database of references for all symbols it encounters. There is limited
support to automatically update these in the edit-compile cycle, you might have to
update manually now and then.

The project settings (or command line options) indicate where the file(s) are created
and one option controls the number of files to be used, `-refnum`.

This file (or files) contains compact, but textual representations of
the cross-reference information. Format is somewhat complex, but here
are somethings that I think I have found out:

- the encoding has one character markers which are listed at the top
  of cxfile.c

- the coding seems to often start with a number and then a character,
  such as '4l' (4 ell) means line 4, 23c mean column 23

- references seems to be optimized to not repeat information if it
  would be a repetition, such as '15l3cr7cr' means that there are two
  references on line 15, one in column 3 the other in column 7

- so there is a notion of "current" for all values which need not be
  repeated

- e.g. references all use 'fsulc' fields, i.e. file, symbol index,
  usage, line and column, but do not repeat a 'fsulc' as long as it is
  the same

- some "fields" have a length indicator before, such as filenames
  ('6:/abc.c') indicated by ':' and version information ('34v file
  format: C-xrefactory 1.6.0 ') indicated by 'v'.

So a line might say

    12205f 1522108169p m1ia 84:/home/...

The line identifies the file with id 12205. The file was last included
in an update of refs at sometime which is identified by 1522108169
(mtime), has not been part of a full update of xrefs, was mentioned on
the command line. (I don't know what the 'a' means...) Finally, the
file name itself is 84 characters long.

TODO: Build a tool to decipher this so that tests can query the
generated data for expected data. This is now partly ongoing in the
'utils' directory.

== Editor Interface

I've been focusing on the Emacs interface since `Jedit` is not so
popular anymore and I'm an Emacs-guy.

Basically Emacs (and probably other editors) starts `c-xref` in
"server-mode" using `-task_regime_server` which connects the editor
with `c-xref` through stdout/stdin. If you have `(setq
c-xref-debug-mode t)` this command is logged in the `\*Messages*` buffer
with the prefix "calling:".

Commands are sent from the editor to the server on its standard input.
They looks very much like normal command line options, and in fact
`c-xref` will parse that input in the same way using the same
code. When the editor sends an `end-of-options` line, the server will
start executing whatever was sent, and return some information in the
file given as an `-o` option when the editor starts the `c-xref`
server process. The file is named and created by the editor and
usually resides in `/tmp`. With `c-xref-debug-mode` on this is logged
as "sending:". If you `(setq c-xref-debug-preserve-tmp-files t)` Emacs
will also not delete the temporary files it creates so that you can
inspect them afterwards.

When the server has finished the command and placed the output in the
output file it sends a `<sync>` reply.

The editor can then pick the result from the output file and do what
it needs to do with it ("dispatching:").

=== Invocations

The editor invokes a new `c-xref` process for the following cases:

- Refactoring
+
Each refactoring operation calls a new instance of `c-xref`.

- Create Project
+
When a `c-xref` function is executed in the editor and there is no
project covering that file, an interactive "create project" session is
started, which is run by a separate `c-xref` process.

=== Buffers

There is some magical editor buffer management happening inside of
`c-xref` which is not clear to me at this point. Basically it looks
like the editor-side tries to keep the server in sync with which
buffers are opened with what file...

At this point I suspect that `-preload <file1> <file2>` means that the
editor has saved a copy `<file1>` in `<file2>` and requests the server
to set up a "buffer" describing that file.

This is essential when doing refactoring since the version of the file
most likely only exists in the editor, so the editor has to tell the
server the current content somehow, this is the `-preload` option.

== Editor Server

When serving an editor the c-xrefactory application is divided into
the server, _c-xref_ and the editor part, at this point only emacs:en
are supported so that's implemented in the env/emacs-packages. (The
jEdit source is now also resurrected, but it is completely untested.)


=== Interaction

The initial invocation of the edit server creates a process with which
communication is over stdin/stdout using a protocol which from the editor
is basically a version of the command line options.

When the editor has delivered all information to the server it sends
'end-of-option' as a command and the edit server processes whatever it
has and responds with '\<sync\>' which means that the editor can fetch
the result in the file it named as the output file using the '-o'
option.

NOTE: As long as the communication between the editor and the server
is open, the same output file will be used. This makes it hard to
catch some interactions, since an editor operation might result in
multiple interactions, and the output file is then re-used.

Setting the emacs variable `c-xref-debug-mode` forces the editor to
copy the content of such an output file to a separate temporary file
before re-using it.

For some interactions the editor starts a completely new and fresh
`c-xref` process, see below. And actually you can't do refactorings
using the server, they have to be separate calls. I have yet to
discover why this design choice was made.

NOTE: There are many things in the sources that handles refactorings
separately, such as r_opt, which is a separate copy of the options
structure used only when refactoring.


=== Protocol

Communication between the editor and the server is performed using
text through standard input/output to/from _c-xref_. The protocol is
defined in src/protocol.tc and must match env/emacs/c-xrefprotocol.el.

The definition of the protocol only caters for the server->editor part,
the editor->server part consists of command lines resembling the command
line options and arguments, and actually is handled by the same code.

The file `protocol.tc` is included in `protocol.h` and `protocol.c`
which generates definitions and declarations for the elements through
using some macros.

There is a similar structure with _c-xrefprotocol.elt_ which
includes _protocol.tc_ to wrap the PROTOCOL_ITEMs into
`defvar`s.

There is also some Makefile trickery that ensures that the C and elisp
impementation are in sync.


=== Invocation of server

The editor fires up a server and keeps talking over the established
channel (elisp function 'c-xref-start-server-process'). This probably
puts extra demands on the memory management in the server, since it
might need to handle multiple information sets and options (as read
from a .cxrefrc-file) for multiple projects simultaneously over a
longer period of time. (E.g. if the user enters the editor starting
with one project and then continues to work on another then new
project options need to be read, and new tag information be generated,
read and cached.)

TODO: Figure out and describe how this works by looking at the
elisp-sources.

FINDINGS:
- c-xref-start-server-process in c-xref.el
- c-xref-send-data-to-running-process in c-xref.el
- c-xref-server-call-refactoring-task in c-xref.el


=== Communication Protocol

The editor server is started using the appropriate command line option
and then it keeps the communication over stdin/stdout open.

The editor part sends command line options to the server, which looks
something like (from the read_xrefs test case):

    -encoding=european -olcxpush -urldirect  "-preload" "<file>" "-olmark=0" "-olcursor=6" "<file>" -xrefrc ".c-xrefrc" -p "<project>"
    end-of-options

In this case the "-olcxpush" is the operative command which results in
the following output

    <goto>
     <position-lc line=1 col=4 len=66>CURDIR/single_int1.c</position-lc>
    </goto>

As we can see from this interaction, the server will handle (all?)
input as a command line and manage the options as if it was a command
line invocation.

This explains the intricate interactions between the main program and
the option handling.

The reason behind this might be that a user of the editor might be
editing files on multiple projects at once, so every
interrogation/operation needs to clearly set the context of that
operation, which is what a user would do with the command line
options.


=== Debugging the protocol

There is a "pipe spy" in `tests/sandboxed_emacs`. You can build the
spy using

    make spy

and then start a sandboxed Emacs which invokes the spy using

    make

This Emacs will be sandboxed to use its own .emacs-files and have HOME
set to this directory.

The spy will log the communication between Emacs and the *real*
`c-xref` (`src/c-xref`) in log files in `/tmp`.

NOTE that Emacs will invoke several instanced of what it believes is
the real `c-xref` so there will be several log files to inspect.


=== OLCX Naming

It seems that all on-line editing server functions have an `olcx`
prefix, "On-Line C-Xrefactory", maybe...



== Refactoring ==

This is of course, the core in why I want to restore this, to get at its refactoring capabilities. So far, much is not understood, but here are some bits and pieces.

=== Editor interface ===

One thing that really confused me in the beginning was that the editor, primarily Emacs, don't use the actual server that it has started for refactoring operations (and perhaps for other things also?). Instead it creates a separate instance with which it talks to about one refactoring.

I've just managed to create the first automatic test for refactorings, `olcx_refactory_rename`. It was created by running the sandboxed emacs to record the communication and thus finding the commands to use.

Based on this learning it seems that a refactoring typically is a single invocation of `c-xref` with appropriate arguments (start & stop markers, the operation, and so on) and the server then answers with a sequence of operations, like

```
<goto>
 <position-off off=3 len=<n>>CURDIR/test_source/single_int1.c</position-off>
</goto>
<precheck len=<n>> single_int_on_line_1_col_4;</precheck>
<replacement>
 <str len=<n>>single_int_on_line_1_col_4</str>  <str len=<n>>single_int_on_line_1_col_44</str>
</replacement>
```

=== Interactions

I haven't investigated the internal flow of such a sequence, but it is starting to look like `c-xref` is internally re-reading the initialization, I'm not at this point sure what this means, I hope it's not internal recursion...


=== Extraction

Each type of refactoring has it's own little "language". E.g. extracting a method/function using `-refactory -rfct-extract-method` will return something like

```
<extraction-dialog type=newFunction_> <str len=20>	newFunction_(str);
</str>
 <str len=39>static void newFunction_(char str[]) {
</str>
 <str len=3>}

</str>
  <int val=2 len=0></int>
</extraction-dialog>
```

So there is much logic in the editor for this. I suspect that the three `<str>` parts are

- what to replace the current region with
- what to place before the current region
- what to place after the current region

If this is correct then all extractions copy the region verbatim and then the server only have to figure out how to "glue" that to a semantically correct call/argument list.

As a side note the editor asks for a new name for the function and then calls the edit server with a rename request (having preloaded the new source file(s) of course).

=== Protocol

Dechiffrering the interaction between an editor and the edit server in
`c-xrefactory` isn't easy. The protocol isn't very clear or
concise. Here I'm starting to collect the important bits of the
invocation, the required and relevant options and the returned
information.

The test cases for various refactoring operations should give you some
more details.

All of these require a `-p` (project) option to know which c-xref
project options to read.

==== General Principles

Refactorings are done using a separate invocation, the edit server
mode cannot handle refactorings. At least that is how the Emacs client
does it (haven't looked at the Jedit version).

I suspect that it once was a single server that did both the symbol
management and the refactoring as there are remnants of a separate
instance of the option structure named "refactoringOptions". Also the
check for the refactoring mode is done using
`options.refactoringRegime == RegimeRefactory` which seems strange.

Anyway, if the refactoring succeeds the suggested edits is as per usual
in the communications buffer.

However, there are a couple of cases where the communcation does not
end there. Possibly because the client needs to communicate some
information back before the refactoring server can finish the job,
like presenting some menu selection.

My guess at this point is that it is the refactoring
server that closes the connection when it is done...

==== Rename

*Invocation:* `-rfct-rename -renameto=NEW_NAME -olcursor=POSITION FILE`

*Semantics:* The symbol under the cursor (at POSITION in FILE) should
be renamed (replaced at all occurrences) by NEW_NAME.

*Result:* sequence of
```
<goto>
 <position-off off=POSITION len=N>FILE</position-off>
</goto>
<precheck len=N>STRING</precheck>
```
followed by sequence of
```
<goto>
 <position-off off=POSITION len=N>FILE</position-off>
</goto>
<replacement>
 <str len=N>ORIGINAL</str>  <str len=N>REPLACEMENT</str>
</replacement>
```

==== Protocol Messages

<goto>{position-off}</goto> -> editor;;
Request the editor to move cursor to the indicated position (file, position).

<precheck len={int}>{string}</precheck> -> editor;;
Requests that the editor verifies that the text under the cursor matches the string.

<replacement>{str}{str}</replacement>;;
Requests that the editor replaces the string under the cursor, which should be 'string1', with 'string2'.

<position-off off={int} len={int}>{absolute path to file}</position-off>;;
Indicates a position in the given file. 'off' is the character position in the file.

== Memory Management

There are multiple levels of memory management.

- Why is this required (possibly because of the long running server
model)?
- Exactly how is this memory allocated?
- Why handle this allocation in disparate spaces?
- Why does not standard malloc()/free() suffice?

There is obviously some caching going on. Don't know of what at this
point. Tag data?

=== Memory "types" ===

Mostly `c-xrefactory` does its own memory management. It uses a number
of different strategies, which has/had its own macros.

=== Static memory allocation

Static memory (SM_ prefix) are static areas allocated by the compiler
which is then indexed using a similarly named index variable
(e.g. `ftMemory` and `ftMemoryIndex`), something the macros took
advantage of. These are

- `ftMemory`
- `ppmMemory`
- `mbMemory`

One special case of static memory also exist:

- `stackMemory` - synchronous with program structure and has CodeBlock
markers, so there is a special `stackMemoryInit()` that initializes
the outermost CodeBlock 

These areas cannot be extended, when it overruns the program stops.

=== Dynamic memory allocation

==== Using the Memory structure

This structure is used for one of the two dynamic memory allocation
schemes, one where overflow handling can be triggered. The structure
contains a function pointer that can be invoked when overflow occurs.

The scary part of this is that it assumes that directly after it,
there is a area of some arbitrary size that can be used for
allocation. `dm_alloc()`, previously a macro, returns pointers into
that area.

(Not all compilers and/or architectures are happy with this, so it is
a priority to do away with this.)

There are two instances of this type of memory:

- `cxMemory` - the crossreference data, which can actually expand using
  the `cxMemoryOverflowHandler()`
  
- `optMemory` - which is part of the options structure that is saved,
  copied and what not, cannot expand as the overflow handler calls
  `fatalError()`.
  
  
`cxMemoryOverflowHandler()` just throws all cxMemory away and
allocates a new area containing a fresh Memory structure as the head
and an empty area to allocate from.

It is strange that `optMemory` is using the Memory structure, it could
easily have been managed as a static area...

==== Using malloc()

There is a second type of dynamic memory, of which there is only one,
the `olcxMemory`. In fact, this is not actually an area, more like a
normal dynamic allocation. Each area is just `malloc()`-ed, but the
size is tallied and when the maximum is reached the
`olcx_memory_alloc()` will do a fatal exit.

This memory allocation is used for temporary areas during refactorings
for example. So `olcx_memory_free()` also exist and is used.


== Configuration

=== Options

There are three possible sources for options.

- Configuration files (~/.c-xrefrc)
- Piped options sent to edit server
- Command line options

Not all options are relevant in all cases.

All options sources uses exactly the same format so that the same code for decoding them can be used.

== Development Practices

=== Setup

TBD.

=== Coding ===

==== Naming ====

_C-xref_ started (probably) as a cross-referencer for the languages
supported (C, Java, C++), orginally had the name "xref" which became
"xrefactory" when refactoring support was added. And when Mari√†n
released a "C only" version in 2009 some of all "xref" references was
changed to "c-xref". So, as most software, there is a history and a
naming legacy to remember.

Here are some of the conventions in naming that are being used:

olcx::
"On-line CX" (Cross-reference)

OLO::
"On-line option" - some kind of options for the server

==== Modules and Include Files ====

The source code for `c-xrefactory` was using a very old C style with a
separate `proto.h` where all prototypes for all externally visible
functions were placed. Definitions are all over the place and it was
hard to see where data is actually declared. This must change into
module-oriented include-strategy.

Of course this will have to change into the modern x.h/x.c externally
visible interface model so that we get clean modules that can be
unittested.

The function prototypes have been now moved out to header files for
each "module". Some of the types have also done that, but this is
still a work in progress.



=== Debugging

TBD. Attachning `gdb`, `server-driver`...

=== Testing

==== Unittests ====

There are very few unittests at this point, only covering single digit
percent of the code. The "units" in this project are unclear and
entangled so creating unittests is hard since it was not build to be
tested, test driven or even clearly modularized.

All unittests use `Cgreen` as the unittest framework. If you are
unfamiliar with it the most important point is that it can mock
functions, so you will find mock implementations of all external
functions for a module in a corresponding `<module>.mock` file.

Many modules are at least under test, meaning there is a
<module>_tests.c in the unittest directory. Often only containing an
empty test.

==== Acceptance Tests

In the `tests` directory you will find tests that exercise the external
behaviour of `c-xref`. Some tests actually do only that, they wouldn't
really count as tests.

Most acceptance tests are hacks at this point, Make-scripts tweaked
until it produces some expected output. But at least they get the
coverage up (working our way up to the mid 60%), and more are added as
bugs are found so they provide increasing confidence when developing.

There are two basic strategies for the tests:

- run a `c-xref` command, catch its output and verify
- run a series of command using the EDIT_SERVER_DRIVER, collect output and results and verify

Some tests do not even test its output and only provide coverage.

Some tests do a very bad job at verifying, either because my
understanding at that time was very low, or because it is hard to
verify the output. E.g. the "test" for generate references are only
grepping the CXrefs files for some strings, not verifying that they
actually point to the correct place.

Hopefully this will change as the code gets into a better state and
the understanding grows.

==== General Setup

Since all(?) `c-xref` operation rely on an options file which must
contain absolute file paths (because the server runs as a separate
process) it must be generated whenever the tests are to be run in a
different location (new clone, test was renamed, ...).

This is performed by using a common template in `tests` and a target
in `tests/Maefile.boilerplate`.

Each test should have a `clean` target that removes any temporary and
generated files, including the `.c-xrefrc` file and generated
references. This way it is easy to ensure that all tests have updated
`.c-xrefrc` files.

==== Edit Server Driver Tests

Since many operations are performed from the editor, and the editor
starts an "edit server" process, many tests need to emulate this
behaviour.

The edit server session is mostly used for navigation. Refactorings
are actually performed as separate invocations of `c-xref`.

In `utils` there is a `server_driver.py` script, which will take as
input a file containing a sequence of commands. You can use this to
start an edit, refactory or tag server session and then feed it with
commands in the same fashion as an editor would do. The script also
handles the communication through the buffer file (see [Editor
Interface](./Design:-Editor-Interface)).

==== Creating More Edit Server Tests

You can relatively easy re-create a sequence of interactions by using the
sandboxed Emacs in `tests/sandboxed_emacs`.

There are two ways to use it, "make spy" or "make pure". With the
"spy" an intermediate spy is injected between the editor and the edit
server, capturing the interaction to a file.

With "pure" you just get the editor setup with `c-xref-debug-mode` and
`c-xref-debug-preserve-tmp-files` on. This means that you can do what
ever editor interactions you want and see the communication in the
`\*Messages*` buffer. See [Editor Interface](./Design:-Editor-Interface)
for details.

Once you have figure out which part of the `\*Messages*` buffer are
interesting you can copy that out to a file and run
`utils/messages2commands.py` on it to get a file formatted for input
to `server_driver.py`.

NOTE: the `messages2commands` script removes any `-preload` so you
need to take care that the positions inside the buffers are not
changed between interactions lest the `-olcursor` and `-olmark` will
be wrong. (You can just undo the change after a refactoring or
rename). Of course this also applies if you want to mimic a sequence
of refactorings, like the `jexercise` move method example. Sources will
then change so the next refactoring works from content of buffers, so you
have to handle this specifically.

NOTE: `-preload` is the mechanism where the editor can send modified
buffers to `c-xref` so thay you don't have to save between
refactorings, which is particularly important in the case of extract
since the extraction creates a default name which the editor then does
a rename of.


=== Utilities

==== Covers

`utils/covers.py` is a Python script that, in some enviroments, can list which test cases execute a particular line.

This is handy when you want to debug or step through a particular part of the code.
Find a test that covers that particular line and run it using the debugger (usually `make debug` in the test directory).

Synopsis:

    covers.py <file> <line>


== Archive

In this section you can find some descriptions and saved texts that
described how things were before. They are no longer true, since that
quirk, magic or bad coding is gone. But it is kept here as an archive
for those wanting to do backtracking to original sources.

=== Bootstrapping

==== BOOTSTRAP REMOVED!

Once the FILL-macros was removed, we could move the enum-generation to
use the actual `c-xref`. So from now on we build `c-xref` directly
from the sources in the repo. Changes to any enums will trigger a
re-generation of the enumTxt-files but since the enumTxt-files are
only conversion of enum values to strings any mismatch will not
prevent compilation, and it would even be possible to a manual
update. This is a big improvement over the previous situation!

==== FILLs REMOVED!

As indicated in <<FILL macros]>> the bootstrapping of FILL-macros has
finally and fully been removed.

Gone is also the `compiler_defines.h`, which was just removed without
any obvious adverse effects.  Maybe that will come back and bite me
when we move to more platforms other than linux and MacOS...

Left is, at this point, only the `enumTxt` generation, so most of the
text below is kept for historical reasons.

==== Rationale

_c-xref_ uses a load of structures, and lists of them, that need to be
created and initialized in a lot of places (such as the parsers). To
make this somewhat manageable, _c-xref_ itself parses the strucures
and generates macros that can be used to fill them with one call.

_c-xref_ is also bootstrapped into reading in a lot of predefined
header files to get system definitions as "preloaded
definitions".

Why this pre-loading was necessary, I don't exactly know. It
might be an optimization, or an idea that was born early and then just
kept on and on. In any case it creates an extra complexity
building and maintaining and to the structure of _c-xref_.

So this must be removed, see below.

==== Mechanism

The bootstrapping uses _c-xref_'s own capability to parse C-code and
parse those structures and spit out filling macros, and some other
stuff.

This is done using options like `-task_regime_generate' which prints a
lot of data structures on the standard output which is then fed into
generated versions of _strFill_, _strTdef_(no longer exists) and
_enumTxt_ by the Makefile.

The process starts with building a _c-xref.bs_ executable from checked
in sources. This compile uses a BOOTSTRAP define that causes some
header files to include pre-generated versions of the generated files
(currently _strFill.bs.h_ and _enumTxt.bs.h_) which should work in all
environments.

NOTE: if you change the name of a field in a structure that is subject
to FILL-generation you will need to manually update the
_strFill.bs.h_, but a "make cleaner all" will show you where those are.

After the _c-xref.bs_ has been built, it is used to generate _strFill_
and _enumTxt_ which might include specific structures for the current
environment.

HOWEVER: if FILL macros are used for structures which are different on
some platforms, say a FILE structure, that FILL macro will have
difference number of arguments, so I'm not sure how smart this "smart"
generation technique actually is.

TODO: Investigate alternative approaches to this generate "regime",
perhaps move to a "class"-oriented structure with initialization
functions for each "class" instead of macros.

==== Compiler defines ====

In _options.h_ there are a number of definitions which somehow are
sent to the compiler/preprocessor or used so that standard settings
are the same as if a program will be compiled using the standard
compiler on the platform. At this point I don't know exactly how this
conversion from C declarations to compile time definitions is done,
maybe just entered as symbols in one of the many symboltables?

Typical examples include "__linux" but also on some platforms things
like "fpos_t=long".

I've implemented a mechanism that uses "gcc -E -mD" to print out and
catch all compiler defines in `compiler_defines.h`. This was necessary
because of such definitions on Darwin which where not in the
"pre-programmed" ones.

TODO?: As this is a more general approach it should possibly
completely replace the "programmed" ones in `options.c`?

==== EnumTxt generation REMOVED! ====

To be able to print the string values of enums the module generate.c
(called when regime was RegimeGenerate) could also generate string
arrays for all enums. By replacing that with some pre-processor magic
for the few that was actually needed (mostly in log_trace() calls) we
could do away with that whole "generate" functionality too.

(Last commit with enum generation intact is https://github.com/thoni56/c-xrefactory/commit/aafd7b1f813f2c17c684ea87ac87a0be31cdd4c4.)

==== enumTxt

For some cases the string representing the value of an Enum is needed.
`c-xref` handles this using the "usual" 'parse code and generate' method.
The module `generate.c` does this generation too.

==== Include paths

Also in _options.h_ some standard-like include paths are added, but
there is a better attempt in _getAndProcessGccOptions()_ which uses
the compiler/preprocessor itself to figure out those paths.

TODO?: This is much better and should really be the only way, I think.

==== Problems

Since at bootstrap there must exist FILL-macros with the correct field
names this strategy is an obstacle to cleaning up the code since every
field is referenced in the FILL macros. When a field (in a structure
which *are* filled using the FILL macro) changes name, this will make
initial compilation impossible until the names of that field is also
changed in the `strFill.bs.h` file.

One way to handle this is of course to use `c-xrefactory` itself and
rename fields. This requires that the project settings also include a
pass with BOOTSTRAP set, which it does.

==== Removing

I've started removing this step. In TODO.org I keep a hierarchical list
of the actions to take (in a Mikado kind of style).

The basic strategy is to start with structures that no other structure
depends on. Using the script `utils/struct2dot.py` you can generate a
DOT graph that shows those dependencies.

Removal can be done in a couple of ways

1. If it's a very small structure you can replace a call to a `FILL_XXX()` macro
with a https://gcc.gnu.org/onlinedocs/gcc/Compound-Literals.html[compound literal].

2. A better approach is usually to replace it with a `fillXXX()` function, or even
better, with a `newXXX()`, if it consistently is preceeded with an allocation
(in the same memory!). To see what fields vary you can grep all such calls, make a
CSV-file from that, and compare all rows.

==== strTdef.h

The `strTdef.h` was generated using the option `-typedefs` as a part
of the old `-task_regime_generate` strategy and generated typedef
declarations for all types found in the parsed files.

I also think that you could actually merge the struct definition with
the typedef so that _strTdef.h_ would not be needed. But it seems that
this design is because the structures in _proto.h_ are not a directed
graph, so loops makes that impossible. Instead the typedefs are
included before the structs:

    #include "strTdef.h"

    struct someNode {
        S_someOtherNode *this;
        ...

    struct someOtherNode {
        S_someNode *that;
        ...

This is now ideomatically solved using the structs themselves:

    struct someNode {
        struct someOtherNode *this;
        ...

    struct someOtherNode {
        struct someNode *that;
        ...

=== FILL macros

_**The FILL macros are now fully replaced by native functions or some other,**_
_**more refactoring-friendly, mechanism. Yeah!**_***

During bootstrapping a large number of macros named ____FILL_xxxx__ is
created. The intent is that you can fill a complete structure with one
call, somewhat like a constructor, but here it's used more generally
every time a complex struct needs to be initialized.

There are even ___FILLF_xxx__ macros which allows filling fields in
sub-structures at the same time.

This is, in my mind, another catastrophic hack that makes
understanding, and refactoring, `c-xrefactory` such a pain. Not to
mention the extra bootstrap step.

I just discovered the compound literals of C99. And I'll experiment
with replacing some of the FILL macros with compound literals assignments
instead.

    FILL_symbolList(memb, pdd, NULL);

could become (I think):

    memb = (SymbolList){.d = pdd, .next = NULL};


If successful, it would be much better, since we could probably get
rid of the bootstrap, but primarily it would be more explicit about
which fields are actually necessary to set.

=== Users

**The `-user` option has now been removed, both in the tool and the
  editor adaptors, and with it one instance of a hashlist, the
  `olcxTab`, which now is a single structure, the `sessionData`.**

There is an option called `-user` which Emacs sets to the frame-id. To
me that indicates that the concept is that for each frame you create
you get a different "user" with the `c-xref` server that you (Emacs)
created.

The jedit adapter seems to do something similar:

    options.add("-user");
    Options.add(s.getViewParameter(data.viewId));

Looking at the sources to find when the function
`olcxSetCurrentUser()` is called it seems that you could have
different completion, refactorings, etc. going on at the same time in
different frames.

Completions etc. requires user interaction so they are not controlled
by the editor in itself only. At first glance though, the editor
(Emacs) seems to block multiple refactorings and tag maintenance tasks
running at the same time.

This leaves just a few use cases for multiple "users", and I think it
adds unnecessary complexity. Going for a more "one user" approach,
like the model in the language server protocol, this could really be
removed.
