== Modules

The current state of `c-xrefactory` is not such that clean modules can
easily be identified and located. This is obviously one important goal
of the continuing refactoring work.

To be able to do that we need to understand the functionality enough
so that clusters of code can be refactored to be more and more clear
in terms of responsibilities and interfaces.

This section makes a stab at identifying some candidated to modules,
as illustrated by the component diagram for `cxrefCore`.

=== Yylex

==== Responsibilities

- Transform source text to sequences of lexems and additional
  information
- Register and apply C pre-processor macros and defines as well as
  defines made as command line options (`-D`)
- Handle include files by pushing and poping read contexts

==== Interface

The `yylex` module has the standard interface required by any
`yacc`-based parser, which is a simple `yylex(void)` function.

=== Parser

=== Xref

=== Server

=== Refactory

=== Cxref

=== Main

=== Memory

==== Responsibilities

The Memory module provides arena-based allocation for performance-critical and request-scoped operations:

* Fast allocation for macro expansion and lexical analysis
* Bulk deallocation for request-scoped cleanup
* Multiple specialized arenas for different data lifetimes
* Overflow detection and optional dynamic resizing

==== Design Rationale

===== Historical Context

In the 1990s when c-xrefactory originated, memory was scarce. The design had to:

1. Minimize allocation overhead (no malloc/free per token)
2. Support large projects despite limited RAM
3. Allow overflow recovery via flushing and reuse
4. Enable efficient bulk cleanup

Most memory arenas use statically allocated areas. Only `cxMemory` supports dynamic resizing to handle out-of-memory situations by discarding, flushing and reusing memory. This forced implementation of a complex caching strategy since overflow could happen mid-file.

===== Modern Benefits

Even with abundant modern memory, arena allocators provide:

* **Performance**: Bump pointer allocation is ~10x faster than malloc
* **Cache locality**: Related data allocated contiguously
* **Automatic cleanup**: Bulk deallocation prevents leaks
* **Request scoping**: Natural fit for parsing/expansion operations

==== Arena Types and Lifetimes

[cols="1,2,1",options="header"]
|===
|Arena |Purpose |Lifetime

|**cxMemory**
|Symbol database, reference tables, cross-reference data
|File or session

|**ppmMemory**
|Preprocessor macro expansion buffers (temporary allocations)
|Per macro expansion

|**macroBodyMemory**
|Macro definition storage
|Session

|**macroArgumentsMemory**
|Macro argument expansion
|Per macro invocation

|**fileTableMemory**
|File metadata and paths
|Session

|**optMemory**
|Command-line and config option strings (with special pointer adjustment)
|Session
|===

==== Key Design Patterns

===== Marker-Based Cleanup

Functions save a marker before temporary allocations:

[source,c]
----
char *marker = ppmAllocc(0);   // Save current index
// ... temporary allocations ...
ppmFreeUntil(marker);          // Bulk cleanup
----

===== Buffer Growth Pattern

Long-lived buffers that may need to grow:

[source,c]
----
// Allocate initial buffer
bufferDesc.buffer = ppmAllocc(initialSize);

// ... use buffer, may need growth ...

// Free temporaries FIRST
ppmFreeUntil(marker);

// NOW buffer can grow (it's at top-of-stack)
expandPreprocessorBufferIfOverflow(&bufferDesc, writePointer);
----

===== Overflow Handling

The `cxMemory` arena supports dynamic resizing:

[source,c]
----
bool cxMemoryOverflowHandler(int n) {
    // Attempt to resize arena
    // Return true if successful
}

memoryInit(&cxMemory, "cxMemory", cxMemoryOverflowHandler, initialSize);
----

When overflow occurs, handler can:

1. Resize the arena (if within limits)
2. Flush old data and reset
3. Signal failure (fatal error)

==== Interface

Key functions (see `memory.h`):

[source,c]
----
// Initialization
void memoryInit(Memory *memory, char *name,
                bool (*overflowHandler)(int n), int size);

// Allocation
void *memoryAlloc(Memory *memory, size_t size);
void *memoryAllocc(Memory *memory, int count, size_t size);

// Reallocation (only for most recent allocation)
void *memoryRealloc(Memory *memory, void *pointer,
                    size_t oldSize, size_t newSize);

// Bulk deallocation
size_t memoryFreeUntil(Memory *memory, void *marker);

// Guards
bool memoryIsAtTop(Memory *memory, void *pointer, size_t size);
----

==== Common Pitfalls

See the "Arena Allocator Lifetime Violations" section in the Development Environment chapter for:

* Attempting to resize buffers not at top-of-stack
* Calling `FreeUntil()` too late
* Mixing arena lifetimes

==== Future Directions

Modern systems have abundant virtual memory. Possible improvements:

1. **Simplify overflow handling** - Allocate larger initial arenas
2. **Separate lifetime management** - Don't mix temporary and long-lived allocations
3. **Consider alternatives** - Linear allocators for some use cases
4. **Add debug modes** - Track allocation patterns and detect violations

The experimental `FlushableMemory` type explores some of these ideas but hasn't replaced current implementation.

=== Cxfile

==== Responsibilities

Read and write the CXref database in "plain" text format.

==== File format

The current file format for the cross-reference data consists of records with the general format

    <number><key>[<value>]

There are two important types of lines, a file information line and a
symbol information line.

The actual keys are documented in `cxfile.c`, but here is an example
file information line:

    32571f  1715027668m 21:/usr/include/ctype.h

First we have two simple value/key pairs. We see "32571f" indicating
that this is file information for file with file number 32571.

Secondly we have "1715027668m". This is the modification time of the
file which is stored to be able to see if that file has been updated
since the reference database was last written.

And the third part is "21:/usr/include/ctype.h", which is of a record
type that is a bit more complex. The number is the length of the
value. The ':' indicates that the record is a filename.

=== c-xref.el

=== c-xrefactory.el