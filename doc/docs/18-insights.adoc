== Insights

This chapter contains notes of all insights, large and small, that I make as I work on this project.
These insights should at some point be moved to some other, more structured, part of this document.
But rather than trying to find a structure where each new finding fits, I'm making it easy to just dump them here.
We can refactor these into a better and better structure as we go.

=== Yacc semantic data

As per usual a Yacc grammar requires each non-terminal to have a type.
Those types are named after which types of data they collect and
propagate.  The names always starts with `ast_` and then comes the
data type.  For example if some non-terminal needs to propagate a
Symbol and a Position that structure would be called
`ast_symbolParameterPair` ("Pair" being thrown in there for good
measure...).

Each of those structures also always carries a begin and end position
for that structure.  That means that any "ast" struct has three
fields, `begin`, `end` and the data.  The data are sometimes a struct,
like in this case, but can also be a single value, like an `int` or a
pointer to a `Symbol`.

[plantuml, ast, png]
....

class ast_symbolPositionPair {
Position begin
Position end
}

ast_symbolPositionPair *-- SymbolPositionPair : data

class SymbolPositionPair {
Symbol *symbol
Position position
}

....


=== Navigation Architecture and the Preloading Limitation

Date: 2025-12-22

==== How Symbol Navigation Works

Symbol navigation (PUSH/NEXT/PREVIOUS/POP) merges references from **two sources**:

1. **Disk CXrefs Database** - Reflects saved files on disk
2. **In-Memory ReferenceableItem Table** - Reflects current server state including preloaded editor buffers

When you PUSH on a symbol, the navigation menu creation (function `createSelectionMenuForOperation`) does:

1. **Load from disk** - Scans CXrefs files for the symbol (via `scanReferencesToCreateMenu`)
   * Creates menu items with disk-based line numbers

2. **Merge from memory** - Maps over the in-memory table (via `putOnLineLoadedReferences`)
   * Adds references from parsed/preloaded buffers with current line numbers
   * Duplicate detection prevents the same reference appearing twice

3. **Build session** - Copies merged references to the navigation session

This dual-source approach allows navigation without full project parse while providing updated positions for modified files.

==== The Fundamental Limitation

**The Emacs client only preloads the currently active file**, not all modified editor buffers.

This creates incorrect navigation after editing non-current files:

```
1. PUSH on symbol in common.h → session has refs with disk line numbers
2. NEXT to usage in source1.c (becomes current, gets preloaded)
3. User adds line in source1.c → server knows via preload
4. NEXT to source2.c → source1.c NO LONGER preloaded
   - Server has no knowledge of source1.c modification
   - Session still has old line number from step 1
5. NEXT wraps to source1.c → WRONG LINE
   - Points to line before actual usage
```

==== Why Our Fix Attempt Didn't Work

We attempted to fix this (commit 8052518a4) by detecting modified files via timestamp comparison and reparsing them in `processModifiedFilesForNavigation`. **This failed because:**

* Can only detect modifications in **preloaded** files (current file)
* Cannot know about changes in non-preloaded modified buffers
* Client protocol doesn't support sending multiple preloaded buffers

==== Potential Solutions

* **Client preloads all modified buffers** - Requires Emacs client changes
* **LSP-style protocol** (did_open/did_change) - Major architectural change
* **Accept the limitation** - Document current behavior
* **Force save before cross-file navigation** - Intrusive UX

As of 2025-12-22, the limitation remains documented but unfixed. The attempted fix was reverted to preserve the original working architecture.

==== Architectural Invariants

**MUST be maintained:**

* Disk CXrefs = State of files on disk (from last tags generation)
* ReferenceableItem Table = Disk state + preloaded editor buffers
* Session references = Snapshot at PUSH time

The table can NEVER reflect non-preloaded modified files because the server doesn't receive that information from the client.

=== RefactoryMode Internally Calls XrefMode

Date: 2025-01-10

NOTE: This section describes the **current architecture** as of January 2025. ADR-0014 (Adopt On-Demand Parsing Architecture) proposes eliminating this `callXref()` pattern in favor of unified on-demand parsing. See section 17.2 (Unified Symbol Database Architecture) for the planned future architecture where refactoring uses the same in-memory references as navigation.

==== The Key Architectural Insight (Current Architecture)

**RefactoryMode runs XrefMode as an internal sub-task to update the reference database before performing refactorings.**

This is critical to understand because:

* Refactorings need current cross-reference data to find all symbol occurrences
* Server mode never creates/updates references (it only serves queries)
* RefactoryMode is a separate process invocation, not part of the interactive server

==== How It Works

When a refactoring is invoked:

[source,c]
----
refactory() [refactory.c:1337]
  │
  ├─ 1. Compute update strategy based on symbol scope/visibility
  │    updateOption = computeUpdateOptionForSymbol(point)
  │      • Local symbols: "" (no update - not in database)
  │      • Header symbols: "-update" (full update required)
  │      • Multi-file global: "-fastupdate" (incremental)
  │      • Single-file global: "" (no update needed)
  │
  ├─ 2. Perform the refactoring operation
  │    renameAtPoint() / parameterManipulation() / etc.
  │
  └─ 3. Update references via internal XrefMode call
       ensureReferencesAreUpdated(project) [line 146]
         ├─ Save current options
         ├─ Build argument vector with updateOption
         ├─ mainTaskEntryInitialisations(args)
         └─ callXref(args, true)  ← NESTS XREF MODE!
----

==== Why Refactorings Are Separate Processes

The Emacs client spawns a **separate RefactoryMode process** rather than using the interactive server because:

1. **Xref update can be slow** - Would block the interactive server for user operations
2. **Options isolation** - The nested `callXref()` "messes all static variables including options" (code comment, line 143-145)
3. **Memory requirements** - Refactorings need more memory than interactive operations (see `mainTaskEntryInitialisations` allocation logic)

==== The Three Modes Relationship

[source]
----
ServerMode (c-xref -server)
  - Never creates/updates references
  - Serves queries from existing .cx files
  - Long-running interactive process
  - Handles: completion, goto-definition, push/pop navigation

XrefMode (c-xref -create / -update)
  - Creates and updates .cx reference files
  - Batch operation over all scheduled files
  - Exits when complete

RefactoryMode (c-xref -refactory ...)
  - Separate one-shot process per refactoring
  - INTERNALLY calls XrefMode (via callXref) to update references
  - Applies source code edits
  - Exits when complete
----

==== Code Evidence

[source,c]
----
// From refactory.c:143-145
// be very careful when calling this function as it is messing all static variables
// including options, ...
// call to this function MUST be followed by a pushing action, to refresh options
void ensureReferencesAreUpdated(char *project) {
    // ...
    deepCopyOptionsFromTo(&options, &savedOptions);

    // Build xref arguments including update option
    argumentVector[argumentCount++] = updateOption;

    // Re-initialize as if starting fresh xref task
    mainTaskEntryInitialisations(args);

    // THE KEY CALL: Run XrefMode nested inside RefactoryMode
    callXref(args, true);

    // Restore options after the nested task
    deepCopyOptionsFromTo(&savedOptions, &options);
}
----

==== Implications

* **You cannot do refactorings in ServerMode** - the architecture doesn't support it
* **ServerMode never receives `-update` or `-create`** - those are XrefMode/RefactoryMode only
* **Refactorings are always consistent** - they get fresh reference data before executing
* **Performance trade-off** - Smart update strategies (local vs header vs multi-file) minimize update cost
* **Process isolation** - Separate RefactoryMode process prevents server state corruption

=== The lastParsedMtime Optimization and Refactoring Conflict

Date: 2025-01-21

==== Problem Discovery

When implementing staleness detection for navigation (refreshing references when files are modified), we added an optimization to `server.c`:

[source,c]
----
// After parsing with preload, update lastParsedMtime
if (buffer != NULL && buffer->preLoadedFromFile != NULL) {
    FileItem *fileItem = getFileItemWithFileNumber(parsingConfig.fileNumber);
    fileItem->lastParsedMtime = buffer->modificationTime;
}
----

This optimization prevents navigation from thinking a file is "stale" immediately after parsing it with preloaded content.

==== The Conflict

This broke refactoring operations (`test_delete_parameter_with_preload`). The problem:

1. **Server parses with preload** → In-memory references have correct positions (e.g., line 3)
2. **`lastParsedMtime` updated** → File marked as "freshly parsed"
3. **Refactoring triggers `callXref()`** → xref checks timestamps
4. **xref sees `editorFileModificationTime() == lastParsedMtime`** → Concludes "file already indexed"
5. **xref skips re-indexing** → Persistent `.cx` keeps old positions (e.g., line 2)
6. **Refactoring uses stale `.cx` data** → Wrong positions, operation fails

==== Root Cause: Two Sources of Truth

The architecture has two sources of references:

1. **In-memory references** (ReferenceableItemTable) - populated by parsing, used by navigation
2. **Persistent .cx database** - populated by xref, used by refactoring

The `lastParsedMtime` optimization conflated these:
* It correctly told navigation "in-memory is current"
* But incorrectly told xref "persistent database is current" (when it wasn't)

==== The Workaround

Exclude refactoring operations from the optimization:

[source,c]
----
if (buffer != NULL && buffer->preLoadedFromFile != NULL
    && options.serverOperation != OLO_RENAME
    && options.serverOperation != OLO_ARGUMENT_MANIPULATION
    && options.serverOperation != OLO_SAFETY_CHECK) {
    fileItem->lastParsedMtime = buffer->modificationTime;
}
----

This allows:
* Navigation to use the optimization (in-memory is sufficient)
* Refactoring to trigger xref re-indexing (reads preload, updates .cx correctly)

==== Architectural Lesson

This workaround highlights the fundamental tension: **navigation and refactoring use different sources of truth**. The proper fix is ADR-0014's unified on-demand architecture where both use the same in-memory reference database, eliminating the need for `callXref()` entirely.

==== Related

* ADR-0014: Adopt On-Demand Parsing Architecture
* Section 17.2: Unified Symbol Database Architecture
* Section 18.3: RefactoryMode Internally Calls XrefMode (describes current architecture)

=== Stale File Refresh and Cross-File References

Date: 2025-01-29 (Updated: 2026-01-29)

==== Stale Detection

When navigating (PUSH/NEXT), the server detects if the current file is "stale" by comparing:

* `fileItem->lastParsedMtime` (from disk database or last parse)
* `buffer->modificationTime` (from preloaded editor buffer)

If `buffer->modificationTime > lastParsedMtime`, the file is considered stale and `refreshStaleReferencesInSession()` is called.

==== The Refresh Algorithm

`refreshStaleReferencesInSession()` in `cxref.c` must preserve cross-file references while updating references from the modified file:

1. `removeReferenceableItemsForFile()` - remove old refs from in-memory table
2. `parseToCreateReferences()` - re-parse with preload, add fresh refs to in-memory table
3. Remove stale-file refs from menu - preserves cross-file refs, removes outdated positions
4. `extendBrowserMenuWithReferences()` - merge fresh refs from in-memory table
5. Mark file as freshly parsed (`lastParsedMtime = buffer->modificationTime`)
6. `recomputeSelectedReferenceable()` - rebuild session's reference list from updated menu

**Key insights:**

* The menu already has cross-file refs from the original PUSH operation (which scanned disk)
* We do NOT clear menu refs and re-scan from disk during refresh
* Scanning from disk creates problems: `addReferenceableToBrowserMenu` creates NEW menu items
  when `includeFileNumber` differs, and these new items have `selected=false`
* Only SELECTED menu items contribute refs to the session's reference list
* So scanning would add refs to new (unselected) items, leaving the original (selected) item empty

==== Why Scanning From Disk Fails

During PUSH, `createSelectionMenu` creates menu items and adds them to `sessionEntry->menu`.
These items are marked as selected. When you NEXT, the menu's reference list is what gets
used for navigation (via `recomputeSelectedReferenceable`).

If during refresh we:
1. Clear menu refs
2. Scan from disk

The scan calls `createSelectionMenu` which in turn calls `addReferenceableToBrowserMenu`.
This function compares incoming items by `(linkName, includeFileNumber, type)`. If the
`includeFileNumber` from the disk scan differs from the existing menu item's value,
a **new** menu item is created with `selected=false`.

The refs are then added to this new unselected item, while the original selected item
has empty refs. `recomputeSelectedReferenceable` only processes selected items, so
navigation loses most of its references.

==== Architectural Note

This is a manifestation of the "two sources of truth" architecture. The long-term fix (per roadmap) is to parse all project files at startup, keeping complete references in memory. Then stale refresh would just re-parse the single file and the in-memory table would already have all cross-file references.
