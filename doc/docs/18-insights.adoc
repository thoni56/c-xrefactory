== Insights

This chapter contains notes of all insights, large and small, that I make as I work on this project.
These insights should at some point be moved to some other, more structured, part of this document.
But rather than trying to find a structure where each new finding fits, I'm making it easy to just dump them here.
We can refactor these into a better and better structure as we go.

=== Yacc semantic data

As per usual a Yacc grammar requires each non-terminal to have a type.
Those types are named after which types of data they collect and
propagate.  The names always starts with `ast_` and then comes the
data type.  For example if some non-terminal needs to propagate a
Symbol and a Position that structure would be called
`ast_symbolParameterPair` ("Pair" being thrown in there for good
measure...).

Each of those structures also always carries a begin and end position
for that structure.  That means that any "ast" struct has three
fields, `begin`, `end` and the data.  The data are sometimes a struct,
like in this case, but can also be a single value, like an `int` or a
pointer to a `Symbol`.

[plantuml, ast, png]
....

class ast_symbolPositionPair {
Position begin
Position end
}

ast_symbolPositionPair *-- SymbolPositionPair : data

class SymbolPositionPair {
Symbol *symbol
Position position
}

....


=== Navigation Architecture and Preloading

Date: 2025-12-22, updated 2026-02

==== How Symbol Navigation Works

Symbol navigation (PUSH/NEXT/PREVIOUS/POP) merges references from **two sources**:

1. **Disk CXrefs Database** - Reflects saved files on disk
2. **In-Memory ReferenceableItem Table** - Reflects current server state including preloaded editor buffers

When you PUSH on a symbol, the navigation menu creation (`createSelectionMenuForOperation`) does:

1. **Load from disk** - Scans CXrefs files for the symbol (via `scanReferencesToCreateMenu`)
   * Creates menu items with disk-based line numbers

2. **Merge from memory** - Maps over the in-memory table (via `putOnLineLoadedReferences`)
   * Adds references from parsed/preloaded buffers with current line numbers
   * Duplicate detection prevents the same reference appearing twice

3. **Build session** - Copies merged references to the navigation session

This dual-source approach allows navigation without full project parse while providing updated positions for modified files.

==== Client Preloading

The Emacs client sends `-preload <file> <tmpfile>` for modified editor buffers, giving the server access to unsaved content. The current buffer is always preloaded (even if unmodified). On PUSH, NEXT, and PREVIOUS, all other modified buffers are also preloaded.

==== Stale File Detection During Navigation

When NEXT or PREVIOUS is invoked, the server detects if a file has been modified via its preload (comparing `lastParsedMtime` against the editor buffer's modification time). If stale, it reparses the file from the preloaded content before navigating, updating reference positions to match the modified buffer.

After a stale-file refresh, the reference list is rebuilt. The server restores its position by finding the nearest reference to where it was, then advances (NEXT) or retreats (PREVIOUS) in list order. This respects the definition-first navigation ordering without assuming any particular sort order.

==== Remaining Limitation: PUSH Target Positions

PUSH returns the definition position from the reference database, which reflects the last time each file was parsed. If the target file (not the current file) has been modified, PUSH navigates to the old position. The preloaded content is available but not used for the PUSH result.

This resolves naturally with link:/workspace/decisions#20[ADR-0020] (separate sync from dispatch): once all modified buffers are reparsed at server entry, PUSH will see current positions.

==== Architectural Invariants

**MUST be maintained:**

* Disk CXrefs = State of files on disk (from last tags generation)
* ReferenceableItem Table = Disk state + preloaded editor buffers
* Session references = Snapshot at PUSH time, refreshed on stale detection during NEXT/PREVIOUS

=== RefactoryMode Internally Calls XrefMode

Date: 2025-01-10

NOTE: This section describes the **current architecture** as of January 2025. link:/workspace/decisions#14[ADR-0014] (Adopt On-Demand Parsing Architecture) proposes eliminating this `callXref()` pattern in favor of unified on-demand parsing. See section 17.2 (Unified Symbol Database Architecture) for the planned future architecture where refactoring uses the same in-memory references as navigation.

==== The Key Architectural Insight (Current Architecture)

**RefactoryMode runs XrefMode as an internal sub-task to update the reference database before performing refactorings.**

This is critical to understand because:

* Refactorings need current cross-reference data to find all symbol occurrences
* Server mode never creates/updates references (it only serves queries)
* RefactoryMode is a separate process invocation, not part of the interactive server

==== How It Works

When a refactoring is invoked:

[source,c]
----
refactory() [refactory.c:1337]
  │
  ├─ 1. Compute update strategy based on symbol scope/visibility
  │    updateOption = computeUpdateOptionForSymbol(point)
  │      • Local symbols: "" (no update - not in database)
  │      • Header symbols: "-update" (full update required)
  │      • Multi-file global: "-fastupdate" (incremental)
  │      • Single-file global: "" (no update needed)
  │
  ├─ 2. Perform the refactoring operation
  │    renameAtPoint() / parameterManipulation() / etc.
  │
  └─ 3. Update references via internal XrefMode call
       ensureReferencesAreUpdated(project) [line 146]
         ├─ Save current options
         ├─ Build argument vector with updateOption
         ├─ mainTaskEntryInitialisations(args)
         └─ callXref(args, true)  ← NESTS XREF MODE!
----

==== Why Refactorings Are Separate Processes

The Emacs client spawns a **separate RefactoryMode process** rather than using the interactive server because:

1. **Xref update can be slow** - Would block the interactive server for user operations
2. **Options isolation** - The nested `callXref()` "messes all static variables including options" (code comment, line 143-145)
3. **Memory requirements** - Refactorings need more memory than interactive operations (see `mainTaskEntryInitialisations` allocation logic)

==== The Three Modes Relationship

[source]
----
ServerMode (c-xref -server)
  - Never creates/updates references
  - Serves queries from existing .cx files
  - Long-running interactive process
  - Handles: completion, goto-definition, push/pop navigation

XrefMode (c-xref -create / -update)
  - Creates and updates .cx reference files
  - Batch operation over all scheduled files
  - Exits when complete

RefactoryMode (c-xref -refactory ...)
  - Separate one-shot process per refactoring
  - INTERNALLY calls XrefMode (via callXref) to update references
  - Applies source code edits
  - Exits when complete
----

==== Code Evidence

[source,c]
----
// From refactory.c:143-145
// be very careful when calling this function as it is messing all static variables
// including options, ...
// call to this function MUST be followed by a pushing action, to refresh options
void ensureReferencesAreUpdated(char *project) {
    // ...
    deepCopyOptionsFromTo(&options, &savedOptions);

    // Build xref arguments including update option
    argumentVector[argumentCount++] = updateOption;

    // Re-initialize as if starting fresh xref task
    mainTaskEntryInitialisations(args);

    // THE KEY CALL: Run XrefMode nested inside RefactoryMode
    callXref(args, true);

    // Restore options after the nested task
    deepCopyOptionsFromTo(&savedOptions, &options);
}
----

==== Implications

* **You cannot do refactorings in ServerMode** - the architecture doesn't support it
* **ServerMode never receives `-update` or `-create`** - those are XrefMode/RefactoryMode only
* **Refactorings are always consistent** - they get fresh reference data before executing
* **Performance trade-off** - Smart update strategies (local vs header vs multi-file) minimize update cost
* **Process isolation** - Separate RefactoryMode process prevents server state corruption

=== The lastParsedMtime Optimization and Refactoring Conflict

Date: 2025-01-21

==== Problem Discovery

When implementing staleness detection for navigation (refreshing references when files are modified), we added an optimization to `server.c`:

[source,c]
----
// After parsing with preload, update lastParsedMtime
if (buffer != NULL && buffer->preLoadedFromFile != NULL) {
    FileItem *fileItem = getFileItemWithFileNumber(parsingConfig.fileNumber);
    fileItem->lastParsedMtime = buffer->modificationTime;
}
----

This optimization prevents navigation from thinking a file is "stale" immediately after parsing it with preloaded content.

==== The Conflict

This broke refactoring operations (`test_delete_parameter_with_preload`). The problem:

1. **Server parses with preload** → In-memory references have correct positions (e.g., line 3)
2. **`lastParsedMtime` updated** → File marked as "freshly parsed"
3. **Refactoring triggers `callXref()`** → xref checks timestamps
4. **xref sees `editorFileModificationTime() == lastParsedMtime`** → Concludes "file already indexed"
5. **xref skips re-indexing** → Persistent `.cx` keeps old positions (e.g., line 2)
6. **Refactoring uses stale `.cx` data** → Wrong positions, operation fails

==== Root Cause: Two Sources of Truth

The architecture has two sources of references:

1. **In-memory references** (ReferenceableItemTable) - populated by parsing, used by navigation
2. **Persistent .cx database** - populated by xref, used by refactoring

The `lastParsedMtime` optimization conflated these:
* It correctly told navigation "in-memory is current"
* But incorrectly told xref "persistent database is current" (when it wasn't)

==== The Workaround

Exclude refactoring operations from the optimization:

[source,c]
----
if (buffer != NULL && buffer->preLoadedFromFile != NULL
    && options.serverOperation != OP_RENAME
    && options.serverOperation != OP_ARGUMENT_MANIPULATION
    && options.serverOperation != OP_SAFETY_CHECK) {
    fileItem->lastParsedMtime = buffer->modificationTime;
}
----

This allows:
* Navigation to use the optimization (in-memory is sufficient)
* Refactoring to trigger xref re-indexing (reads preload, updates .cx correctly)

==== Architectural Lesson

This workaround highlights the fundamental tension: **navigation and refactoring use different sources of truth**. The proper fix is link:/workspace/decisions#14[ADR-0014]'s unified on-demand architecture where both use the same in-memory reference database, eliminating the need for `callXref()` entirely.

==== Related

* link:/workspace/decisions#14[ADR-0014]: Adopt On-Demand Parsing Architecture
* Section 17.2: Unified Symbol Database Architecture
* Section 18.3: RefactoryMode Internally Calls XrefMode (describes current architecture)

=== Stale File Refresh and Cross-File References

Date: 2025-01-29 (Updated: 2026-01-29)

==== Stale Detection

When navigating (PUSH/NEXT), the server detects if the current file is "stale" by comparing:

* `fileItem->lastParsedMtime` (from disk database or last parse)
* `buffer->modificationTime` (from preloaded editor buffer)

If `buffer->modificationTime > lastParsedMtime`, the file is considered stale and `refreshStaleReferencesInSession()` is called.

==== The Refresh Algorithm

`refreshStaleReferencesInSession()` in `cxref.c` must preserve cross-file references while updating references from the modified file:

1. `removeReferenceableItemsForFile()` - remove old refs from in-memory table
2. `parseToCreateReferences()` - re-parse with preload, add fresh refs to in-memory table
3. Remove stale-file refs from menu - preserves cross-file refs, removes outdated positions
4. `extendBrowsingMenuWithReferences()` - merge fresh refs from in-memory table
5. Mark file as freshly parsed (`lastParsedMtime = buffer->modificationTime`)
6. `recomputeSelectedReferenceable()` - rebuild session's reference list from updated menu

**Key insights:**

* The menu already has cross-file refs from the original PUSH operation (which scanned disk)
* We do NOT clear menu refs and re-scan from disk during refresh
* Scanning from disk creates problems: `addReferenceableToBrowsingMenu` creates NEW menu items
  when `includeFileNumber` differs, and these new items have `selected=false`
* Only SELECTED menu items contribute refs to the session's reference list
* So scanning would add refs to new (unselected) items, leaving the original (selected) item empty

==== Why Scanning From Disk Fails

During PUSH, `createSelectionMenu` creates menu items and adds them to `sessionEntry->menu`.
These items are marked as selected. When you NEXT, the menu's reference list is what gets
used for navigation (via `recomputeSelectedReferenceable`).

If during refresh we:
1. Clear menu refs
2. Scan from disk

The scan calls `createSelectionMenu` which in turn calls `addReferenceableToBrowsingMenu`.
This function compares incoming items by `(linkName, includeFileNumber, type)`. If the
`includeFileNumber` from the disk scan differs from the existing menu item's value,
a **new** menu item is created with `selected=false`.

The refs are then added to this new unselected item, while the original selected item
has empty refs. `recomputeSelectedReferenceable` only processes selected items, so
navigation loses most of its references.

==== Architectural Note

This is a manifestation of the "two sources of truth" architecture. The long-term fix (per roadmap) is to parse all project files at startup, keeping complete references in memory. Then stale refresh would just re-parse the single file and the in-memory table would already have all cross-file references.

=== Unified In-Memory Table Discovery

Date: 2025-01-25

Investigation revealed that **both XrefMode and ServerMode use the same in-memory `ReferenceableItemTable`**. This is the key enabler for the incremental path to "Memory as Truth" (see link:15-roadmap.adoc[Chapter 15: Roadmap]).

`handleFoundSymbolReference()` in `cxref.c` handles references found during parsing. It calls `isMemberInReferenceableItemTable()` to check if a symbol exists; if not found, creates a new entry; if found, adds a reference to the existing entry. This same table is used by both modes — there is no separate "server table" vs "xref table".

The disk scan operations (`ensureReferencesAreLoadedFor`, `scanReferencesToCreateMenu`, etc.) read from `.cx` files on disk and also call `isMemberInReferenceableItemTable()` to check/merge with existing entries. If parsing has already populated the table, these operations find data already present — making them effective no-ops once all files are parsed.
