== Planned Features

This chapter documents planned user-facing features—new refactorings, navigation capabilities, and editor integrations. These represent functionality users will interact with directly.

For internal architectural improvements and code quality work, see link:17-major-codebase-improvements.adoc[Chapter 17: Major Codebase Improvements].

For detailed specifications of refactoring operations (both existing and planned), see link:19-refactoring-recipes.adoc[Chapter 19: Refactoring Recipes].

[[move-function-refactoring]]
=== Move Function Between Files

**Status**: Phase 1 complete (December 2024)

==== Use Case

Reorganize code by moving function definitions between source files while maintaining correctness. Essential for refactoring large codebases into better module structure.

**Example**: Extract a utility function from `main.c` to `utils.c`, automatically handling visibility changes and header declarations.

==== What Works Now

* Move a function from one source file to another
* Automatically removes possible `static` keyword (makes function externally accessible)
* Adds extern declaration to target file's header
* Preserves comments and function decorations
* Works for both C and Yacc files

==== Next steps

**Remove extern declaration**: Remove the moved functions extern declaration from the
  header file for the source, if the function was not static.

**Include management**: Automatically add necessary `#include` directives based on dependencies.

**Helper function detection**: Identify and optionally move static helper functions that
  the moved function depends on. Prevents broken builds.

**Smarter header placement**: Automatically find the right location in header files
  based on existing declarations and dependencies.

**Preview**: Show what will be changed before applying the refactoring.

=== LSP Integration

**Status**: EXPERIMENTAL (January 2026)

==== Use Case

```plantuml
@startuml
Bob -> Alice : hello
@enduml
```

Language Server Protocol (LSP) integration enables c-xrefactory to work with modern editors and IDEs (VS Code, vim/neovim with LSP plugins, etc.) beyond Emacs. This opens c-xrefactory's refactoring and navigation capabilities to a much wider audience.

==== What Works

**Go to Definition** (`textDocument/definition`):

* Functions - Jump to function definition from any call site
* Global variables - Navigate to variable declarations
* Types - Find typedef and struct definitions

**File Parsing**:

* Files are parsed as they're opened in the editor
* Symbols become available for navigation immediately

==== Current Limitations

**Single-file scope**: Only symbols in the currently opened file are accessible. To navigate to a function in another file, you must first open that file.

**No local variables**: Go-to-definition doesn't work for local variables or function parameters. This works in Emacs mode but requires architectural changes for LSP.

**Missing LSP features**: Only `textDocument/definition` is implemented. Coming features:

* Find all references
* Hover information  
* Code completion
* Rename refactoring
* Organize imports

==== How to Use

See the README for LSP client configuration examples. Basic setup:

1. Build c-xrefactory with `make`
2. Configure your editor's LSP client to use `c-xref -lsp` as the server command
3. Open C or Yacc files
4. Use your editor's "go to definition" command

==== Related Work

* link:17-major-codebase-improvements.adoc[Chapter 17: Major Codebase Improvements] discusses the technical architecture
* Multi-file support requires include graph and on-demand parsing (foundational work described in Chapter 17)

=== Rename function handles `expect`

Many unittest frameworks have a feature for isolating a unit, often referred to as
"mocks", in C the "unit" of mocking/stubbing/doubling is almost always a function. These
mocks need to understand how they should respond to a call. As they have no logic they
are "programmed" by expressing conditions and responses.

In particular, Cgreen, has an `expect()` which takes the function name as the first
parameter, and then constraints to apply and values to return. This is implemented using
CPP macros so the function name is just text, and cannot be detected using normal
C-parsing/analysis.

Renaming a function that appears in an `expect` will not rename that reference. This
will usually cause the unittest to fail, because there is no call to that, no longer
existin, function.

A handy extension of the "Rename Function" would be to find these using some special
magic and replace them too.

=== Migrate to project local config

Previously `c-xrefactory` promoted a user-central config file, `~/.c-xrefrc` which
contained the config for all projects by containing a section for each project. The "New
Project" wizard in the Emacs client created new sections in this file.

Since 1.9 the promoted model is a project local config file, a `.c-xrefrc` in the root
of the project tree. The main advantage is that it can be checked in to repo and it will
not contain absolute file paths.

Legacy project configs will continue to work, but a user might want to migrate a
project. It's fairly easy to do by hande, but as polishing touch, providing a client
operation to do that would be nice.

=== Indexing Log Buffer

**Status**: Planned

==== Background

When the server does a cold start (no disk database), it parses all discovered compilation units to populate in-memory references. During this parsing, warnings and errors may occur (e.g., missing include files, syntax errors from missing `-D` defines). These are expected and harmless — c-xrefactory continues best-effort — but users benefit from seeing them to tune their `.c-xrefrc` (adding `-I` paths, `-D` defines, etc.).

The legacy `-create` command in Emacs offered "View log file?" after completion, showing a file with all parsing messages. The cold start server path needs an equivalent.

There are also other situations when a re-parse or re-discovery might throw the same kind of errors.

==== Problem

The current protocol has no non-modal message channel. Every message type either shows a modal dialog (`PPC_WARNING`, `PPC_ERROR`, `PPC_INFORMATION`) requiring "Press a key to continue", or writes a transient line to the minibuffer (`PPC_BOTTOM_INFORMATION`). Sending per-file warnings during cold start floods the user with one modal per warning, effectively locking up the editor.

==== Design Options

**Option A: New protocol record type** (recommended) — Add a `PPC_LOG` record that the Emacs client silently appends to a `*c-xref-log*` buffer. After cold start completes, send a `PPC_BOTTOM_INFORMATION` saying "Indexing done: N warnings (see *c-xref-log*)". Clean separation, no modals, inspectable at leisure. Touches protocol definition, C server code, and Emacs client.

**Option B: Server-side batching** — Collect all warnings during cold start into a single string, send as one `PPC_INFORMATION` after parsing completes. One modal instead of many. Simpler but still modal.

**Option C: Summary only** — Send a `PPC_BOTTOM_WARNING` summary to the minibuffer (e.g., "3 files could not be opened during indexing"). Details go only to the log file. Minimal change but no inspectable buffer in Emacs.
