== Algorithms

The code does not always explain the algorithms that it
implements. This chapter will ultimately be a description of various
algorithms used by _c-xrefactory_.

=== How is an Extract refactoring performed?

The region (mark and point/cursor positions) is sent to the _c-xref_
server in a `-refactory -rfct-extract` command.

The server parses the relevant file and sets some information that can
be used in some prechecks that are then performed, such as structure
check, and then the server answers with

```
<extraction-dialog>
    <str .... /str>
    <str .... /str>
    <str .... /str>
</extraction-dialog>
```

The first string is the code that will replace the extracted code,
such as a call to the extracted function. The second string is the header
part that will preceed the extracted code ("preamble"), and the third is then of
course any code that needs to go after the extracted code ("postamble").

The actual code in the region is never sent to, or returned from, the
server. This is handled completely by the editor extension, and used
verbatim (except if it is a macro that is extracted, in which case
each line is terminated by the backslash) so no changes to that code
can be made.

The pre- and post-ambles might be of varying complexity. E.g. when
extracting a macro, the postamble can be completely empty. When
extracting a function both may contain code to transfer and restore
parameters into local variables to propagate in/out variables as
required.

1. The editor then requests a name from the user that it will use in a
rename operation that renames the default named
function/macro/variable.

=== How does lexem stream management work?

Lexical analysis uses a stack of `LexemStream` structures to handle nested macro expansions. The key insight is that the stream type acts as a **discriminator** for buffer ownership and cleanup strategy.

==== The Stream Types

[source,c]
----
typedef enum {
    NORMAL_STREAM,              // File or local buffer
    MACRO_STREAM,               // Macro expansion
    MACRO_ARGUMENT_STREAM,      // Macro argument expansion
} LexemStreamType;
----

NOTE: Historically, there was also a `CACHED_STREAM` type when the caching mechanism was still active. This confirms that stream types are fundamentally about **buffer ownership and refill strategy** - each type encodes where the buffer came from and how to handle it when exhausted.

**NORMAL_STREAM**::
Buffer from file's `lexemBuffer` or a local temporary. Not allocated from arena memory, so no cleanup needed when stream exhausted.

**MACRO_STREAM**::
Buffer allocated from `macroBodyMemory` arena during macro expansion. Must call `mbmFreeUntil(stream.begin)` when popping from stack to free the arena allocation.

**MACRO_ARGUMENT_STREAM**::
Buffer allocated from `ppmMemory` arena during macro argument expansion. Signals `END_OF_MACRO_ARGUMENT_EXCEPTION` when exhausted (cleanup handled by caller).

==== The Refill Algorithm

When `currentInput` runs out of lexems (`read >= write`), `refillInputIfEmpty()` uses the stream type to decide what to do:

[source,c]
----
while (currentInput.read >= currentInput.write) {
    LexemStreamType inputType = currentInput.streamType;

    if (insideMacro()) {  // Stack not empty
        if (inputType == MACRO_ARGUMENT_STREAM) {
            return END_OF_MACRO_ARGUMENT_EXCEPTION;
        }
        // Only free MACRO_STREAM buffers (allocated from macroBodyMemory)
        if (inputType == MACRO_STREAM) {
            mbmFreeUntil(currentInput.begin);
        }
        currentInput = macroInputStack[--macroStackIndex];  // Pop
    }
    else if (inputType == NORMAL_STREAM) {
        // Refill from file
        buildLexemFromCharacters(&currentFile.characterBuffer, ...);
    }
}
----

==== Key Invariant

**Stream type must match buffer allocation:**

* `MACRO_STREAM` → buffer allocated from `macroBodyMemory`
* `NORMAL_STREAM` → buffer NOT from macro arenas
* `MACRO_ARGUMENT_STREAM` → buffer from `ppmMemory`

Violating this invariant causes fatal errors when trying to free buffers from the wrong arena.

==== Common Bug Pattern

Pushing a `NORMAL_STREAM` onto the macro stack, then trying to free it as if it were `MACRO_STREAM`:

[source,c]
----
// WRONG: Blindly freeing without checking type
mbmFreeUntil(currentInput.begin);  // Fails if currentInput is NORMAL_STREAM!

// CORRECT: Check type first
if (inputType == MACRO_STREAM) {
    mbmFreeUntil(currentInput.begin);
}
----

=== How does ...

TBD.