== Software Architecture

=== Container View

image::embed:ContainerView[]

=== Containers

At this point the description of the internal structure of the containers are
tentative. The actual interfaces are not particularly clean, most code
files can and do include much every other module.

NOTE: One focus area for the ongoing work is to try to pry out modules/components
from the code mess by moving functions around, renaming and hiding
functions, where possible.

==== CxrefCore

image::embed:CxrefCore[]

`cxrefCore` is the core container. It does all the work when it comes
to finding and reporting references to symbols, communicating
refactoring requests as well as storing reference information for
longer term storage and caching.

Although `c-xref` can be used as a command line tool, which can be
handy when debugging or exploring, it is normally used in "server"
mode. In server mode the communication between the editor extension
and the cxrefCore container is a back-and-forth communication using a
non-standard protocol over standard pipes.

The responsibilities of `cxrefCore` can largely be divided into

* parsing source files to create, maintain the references database which stores all inter-module references
* parsing source files to get important information such as positions for a functions begin and end
* managing editor buffer state (as it might differ from the file on disc)
* performing symbol navigation
* creating and serving completion suggestions
* performing refactorings such as renames, extracts and parameter manipulation

At this point it seems like refactorings are performed as separate
invocations of `c-xref` rather than through the server interface.

==== EditorExtension

image::embed:EditorExtension[]

The `EditorExtension` container is responsible for plugging into an
editor of choice and handle the user interface, buffer management and
executing the refactoring edit operations.

Currently there is only one such extension supported, for `Emacs`,
although there existed code, still available in the repo history, for
an extension for `jEdit` which hasn't been updated, modified or checked
for a long time and no longer is a part of this project.

==== ReferencesDB

The References database stores crossreferencing information for
symbols visible outside the module it is defined in. Information about
local/static symbols are not stored but gathered by parsing that
particular source file on demand.

Currently this information is stored in a somewhat cryptic, optimized
text format.

This storage can be divided into multiple files, probably for faster
access. Symbols are then hashed to know which of the "database" files
it is stored in. As all crossreferencing information for a symbol is
stored in the same "record", this allows reading only a single file
when a symbol is looked up.

=== Caching System Architecture

The c-xrefactory includes a sophisticated caching system that enables incremental parsing by caching parsed input streams, parser state, and file modification tracking. This optimization allows for faster re-analysis when only portions of source files have changed.

==== Core Design Principles

**Cache Point Model**: The system places strategic snapshots of parser state at external definition boundaries (functions, global variables, etc.). When files are re-processed, the system can validate cache integrity, recover from cache points, and resume parsing only from the first changed definition onward.

**Separation of Concerns**: Recent refactoring has separated file tracking from cache validation:

* `updateFileModificationTracking()` - Updates file timestamps without side effects
* `isFileModifiedSinceCached()` - Pure validation function for cache integrity

==== Key Components

**Cache Point Management** (`caching.c`):

* `placeCachePoint(bool)` - Places strategic parser state snapshots
* `recoverFromCache()` - Restores parser state from cache points  
* `recoverCachePointZero()` - Resets to initial cache state

**File Modification Tracking**:

The `FileItem` structure maintains multiple timestamp fields for tracking file modification:

[source,c]
----
struct FileItem {
    time_t lastModified;    // File's actual modification time
    time_t lastInspected;   // When we last checked the file
    // ... other fields
}
----

**Input Stream Caching**:

* `cacheInput()` - Caches tokenized input from lexer
* `cachingIsActive()` - Checks if caching is currently enabled
* `activateCaching()` / `deactivateCaching()` - Control caching state

==== Parser Integration

**C Parser Integration**: Both C and Yacc parsers place cache points after each `external_definition`, but only when not processing include files (`includeStack.pointer == 0`).

**Parser-Specific Behavior**:

* **C Parser**: Full caching enabled with regular cache point placement
* **Yacc Parser**: Explicitly deactivates caching via `deactivateCaching()` but still places strategic cache points
* **Include Files**: Cache points skipped during include processing

==== System Dependencies

The caching system is deeply integrated throughout the parsing pipeline:

[cols="1,2,2"]
|===
|Component |Functions Used |Purpose

|`main.c`
|`initCaching()`, `activateCaching()`, `recoverCachePointZero()`
|Lifecycle control

|`lexer.c`  
|`cacheInput()`, `cachingIsActive()`, `deactivateCaching()`
|Input processing

|`yylex.c`
|`updateFileModificationTracking()`
|File tracking

|`filetable.c`
|`updateFileModificationTracking()`
|File management

|`xref.c`
|`recoverFromCache()`, recovery functions
|Cross-reference coordination

|`c_parser.y`
|`placeCachePoint()`
|C grammar integration

|`yacc_parser.y`
|`deactivateCaching()`, `placeCachePoint()`
|Yacc grammar integration
|===

==== Performance Characteristics

**Cache Hit Scenarios**:

1. **Full Cache Hit**: No file modifications since last parse - parser state recovered from cache point zero with minimal re-processing
2. **Partial Cache Hit**: File modified after Nth definition - recovery from cache point N with re-parsing only from point of change onward  
3. **Cache Miss**: File structure changed or timestamps invalid - full re-parse with new cache points placed

**Optimization Benefits**:

* Memory usage scales with number of definitions, not file size
* File modification checking minimizes unnecessary re-reads
* Input stream caching reduces lexer overhead
* Strategic cache point placement enables clean recovery at definition boundaries
