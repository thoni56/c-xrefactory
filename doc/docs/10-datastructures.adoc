== Data Structures

There are a lot of different data structures used in `c-xrefactory`.
This is a first step towards visualising some of them.

=== ReferenceItems and References

This is a fundamental pair. A `ReferenceItem` is the symbol that
occurs at the locations that `References` indicate.

Each `ReferenceItem` has a linked list of `Reference`s, each denoting
one occurence of that "symbol".

=== Symbols and References

There is also a structure called `Symbol`. But, why is there no
connection between the symbols and the references?!?

So what are these actually?

.Symbol and Reference Data Structures
image::diagrams/symbol-structures.svg[Symbol structures]

=== Files and Buffers

Many strange things are going on with reading files so that is not completely understood yet.

Here is an initial attempt at illustrating how some of the file and text/lexem buffers are related.

.File Descriptor and Buffer Relationships
image::diagrams/buffer-structures.svg[Buffer structures]

NOTE: It would be nice if the `LexemStream` structure could point to a
`LexemBuffer` instead of holding separate pointers which are
impossible to know what they actually point to...

NOTE: This could be achieved if we could remove the CharacterBuffer
from LexemBuffer and make that a reference instead of a
composition. Then we'd need to add a CharacterBuffer to the structures
that has a LexemBuffer as a component (if they use it).

=== Modes

`c-xrefactory` operates in different modes ("regimes" in original
`c-xref` parlance):

- xref - batch mode reference generation
- server - editor server
- refactory - refactory browser

The default mode is "xref". The command line options `-server` and `-refactory`
selects one of the other modes. Branching is done in the final lines in
`main()`.

The code for the modes are intertwined, probably through re-use of
already existing functionality when extending to a refactoring
browser.

One evidence for this is that the refactory module calls the "main
task" as a "sub-task".  This forces some intricate fiddling with the
options data structure, like copying it.  Which I don't
fully understand yet.

TODO?: Strip away the various "regimes" into more separated concerns
and handle options differently.

=== Options

The `Options` datastructure is used to collect options from the
command line as well as from options/configuration files and piped
options from the editor client using process-to-process
communication.

It consists of a collection of fields of the types

- elementary types (bool, int, ...)
- string (pointers to strings)
- lists of strings (linked lists of pointers to strings)

==== Allocation & Copying

Options has its own allocation using `optAlloc` which allocates in a
separate area, currently part of the options structure and utilizing
"dynamic allocation" (`dm_` functions on the `Memory` structure).

The Options structure are copied multiple times during a session, both
as a backup (`savedOptions`) and into a separate options structure
used by the Refactorer (`refactoringOptions`).

Since the options memory is then also copied, all pointers into the
options memory need to be updated. To be able to do this, the options
structure contains lists of addresses that needs to by "shifted".

When an option with a string or string list value is modified the
option is registered in either the list of string valued options or
the list of string list valued options. When an options structure is
copied it must be performed using a deep copy function which "shifts"
those options and their values (areas in the options memory) in the
copy so that they point into the memory area of the copy, not the
original.

After the deep copy the following point into the option memory of the
copy

- the lists of string and string list valued options (option fields)
- all string and string valued option fields that are used (allocated)
- all list nodes for the used option (allocated)
- all list nodes for the string lists (allocated)

=== Arena Allocators (Memory)

Arena allocators (also called region-based or bump allocators) are the fundamental memory management strategy used throughout c-xrefactory for performance-critical operations like macro expansion and lexical analysis.

==== The Memory Structure

[source,c]
----
typedef struct memory {
    char   *name;              // Arena name for diagnostics
    bool  (*overflowHandler)(int n); // Optional resize handler
    int     index;             // Next allocation offset (bump pointer)
    int     max;               // High-water mark
    size_t  size;              // Total arena size
    char   *area;              // Actual memory region
} Memory;
----

==== Allocation Model

Arena allocators use **bump pointer allocation**:

1. Allocation: Return `&area[index]`, then `index += size`
2. Deallocation: Bulk rollback via `FreeUntil(marker)`
3. Reallocation: Only possible for most recent allocation

This is extremely fast (O(1) allocation) but requires stack-like discipline for deallocation.

==== Stack-Like Discipline

Arenas follow LIFO (last-in-first-out) cleanup:

[source,c]
----
marker = ppmAllocc(0);        // Save current index
temp1 = ppmAllocc(100);       // Allocate
temp2 = ppmAllocc(200);       // Allocate
// Use temp1, temp2...
ppmFreeUntil(marker);         // Free both temp1 and temp2
----

==== Key Constraint: Top-of-Stack Reallocation

Only the most recent allocation can be resized:

[source,c]
----
buffer = ppmAllocc(1000);     // Allocate buffer
temp = ppmAllocc(500);        // Allocate temporary
ppmReallocc(buffer, ...);     // ‚ùå FAILS - buffer not at top
----

This constraint is enforced by guards in `memory.c` (see Development Environment chapter).

==== Memory Arena Types

c-xrefactory uses specialized arenas for different purposes (see Modules chapter for details):

* `cxMemory` - Cross-reference database and symbol tables
* `ppmMemory` - Preprocessor macro expansion (temporary)
* `macroBodyMemory` - Macro body buffers
* `macroArgumentsMemory` - Macro argument expansion
* `fileTableMemory` - File table entries
* `optMemory` - Option strings (with special pointer adjustment)

=== Preload Mechanism

The preload mechanism allows the server to work with editor buffer contents that haven't been saved to disk. This is essential for providing real-time symbol navigation and completion while the user is actively editing.

==== How It Works

When an editor buffer is modified but not yet saved:

1. **Editor Action**: The Emacs client writes the current buffer content to a temporary file
2. **Server Request**: The client sends a request with `-preload <filename> <tmpfile>` options
3. **Buffer Association**: The server creates an `EditorBuffer` structure linking the on-disk filename to the temporary file containing the actual content
4. **Transparent Parsing**: When the server needs to parse the file, it transparently reads from the temporary file instead of the on-disk file

==== Why It's Needed

Without preload, the server would only see the last saved version of the file. The preload mechanism ensures that:

* Symbol navigation works with the current buffer state
* Completion suggests symbols based on what's actually typed
* Refactorings operate on the current code, not stale saved content
* Users get immediate feedback without having to save constantly

==== Reference Management

When a file is preloaded, the server must handle reference updates carefully:

* **Old references** from the previous file version must be removed from the reference table before parsing
* This prevents duplicate references (one set at old positions, another at new positions)
* The removal happens in `removeReferencesForFile()` when preloaded content is detected

=== Browser Stack

The browser stack maintains navigation history for symbol references, allowing users to browse through code by pushing symbol lookups and navigating back through previous queries.

==== Structure

The browser stack is a linked list of `OlcxReferences` entries, where each entry represents a symbol lookup session:

* **Stack entries** contain complete symbol information and reference lists for one navigation session
* **Top pointer** indicates the current active entry being navigated
* **Root pointer** tracks the base of the stack (most recent entry still available)
* Entries between root and top are "future" navigation states that can be returned to via "next"

==== Lifecycle

1. **Push**: When user requests symbol references (e.g., `-olcxpush`), a new empty entry is created on the stack
2. **Population**: After parsing, the entry is filled with `SymbolsMenu` structures containing references
3. **Navigation**: Commands like `-olcxnext` and `-olcxprevious` move through references in the current entry
4. **Pop**: User can pop back to previous entries to return to earlier symbol lookups

==== Relationship to Parsing

The browser stack is populated in two stages:

1. **Parse-time**: References are collected in the reference table during file parsing
2. **Menu Creation**: References are copied from the reference table into the browser stack entry via `putOnLineLoadedReferences()`

This separation means that browser stack entries can become stale if files are reparsed (e.g., with preloaded content) without refreshing the stack. Users typically need to pop and re-push to get fresh reference lists after edits.

=== Symbols Menu

A symbols menu is a navigable list of symbols with their references, organized for presentation to the user. Multiple symbols may appear in a single menu when name resolution finds several candidates (e.g., overloaded functions, inherited methods).

==== Structure

Each `SymbolsMenu` entry contains:

* **Reference item**: The symbol itself (name, type, storage class, scope)
* **Reference list**: All locations where this symbol appears
* **Selection state**: Whether this symbol is currently selected for operations
* **Filter state**: Whether this symbol passes current visibility filters
* **Default reference**: The "best" reference to jump to (usually the definition)

==== Multiple Menus in One Session

A single browser stack entry can contain multiple symbols in its menu:

* **hkSelectedSym**: Symbols that matched at the cursor position (after disambiguation)
* **symbolsMenu**: Complete menu including related symbols (same name, similar signatures)

This allows users to:

* See all candidates when a symbol is ambiguous
* Navigate between related definitions (overloads, implementations)
* Select specific symbols for refactoring operations

==== Menu Population

Menus are populated by scanning the reference table:

1. **Symbol lookup**: Find all `ReferenceItem` entries matching the requested symbol
2. **Reference collection**: For each matching item, add its references to the menu
3. **Sorting and filtering**: Order symbols by relevance and apply visibility filters
4. **Selection**: Mark symbols that best match the cursor context



