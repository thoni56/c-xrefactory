== Data Structures

There are a lot of different data structures used in `c-xrefactory`.
This is a first step towards visualising some of them.

=== ReferenceableItem and Reference: Core Domain Concepts

These are the fundamental cross-reference data structures that represent the "what" and "where" of code entities.

==== ReferenceableItem

A `ReferenceableItem` represents a **referenceable entity** in the codebase - something that can be referenced from multiple locations:

* Functions and variables
* Types (structs, unions, enums, typedefs)
* Macros
* Include directives (special case: `TypeCppInclude`)
* Yacc non-terminals and rules

Each `ReferenceableItem` contains:

* `linkName` - Fully qualified name (e.g., `"MyClass::method"`)
* `type` - What kind of entity (function, variable, type, etc.)
* `storage`, `scope`, `visibility` - Language properties
* `includeFile` - For `TypeCppInclude` items, which file is being included
* `references` - Linked list of all `Reference` (occurrences) of this entity

ReferenceableItems are stored in the `referenceableItemTable` (hash table) and persisted to `.cx` files.

==== Reference (Occurrence)

A `Reference` represents a **single occurrence** of a ReferenceableItem at a specific location:

* `position` - File, line, and column where this occurrence appears
* `usage` - How it's used (definition, declaration, usage, etc.)
* `next` - Pointer to next occurrence in the list

Each ReferenceableItem maintains a linked list of all its References, allowing you to find every place that entity appears in the codebase.

**Note:** The term "Reference" in this context means "occurrence" - one specific use of an entity at one location. This is distinct from C++ references or reference semantics.

=== Symbol (Parser Symbol Table)

There is also a structure called `Symbol`. This is **separate from ReferenceableItem** and serves a different purpose:

**`Symbol`** - Parser-level symbol table entry (temporary, exists only during parsing):

* Used by the C/Yacc parser for semantic analysis
* Contains type information, position, storage class
* Lives in `symbolTable` (hash table) during file parsing
* **Not persisted** - discarded after parsing completes

**`ReferenceableItem`** - Cross-reference entity (persistent across entire codebase):

* Created FROM Symbol properties when a referenceable construct is found
* Stored in `referenceableItemTable` and saved to `.cx` files
* Accumulates References from all files in the project

**Relationship:** During parsing, when the parser encounters a referenceable symbol (function, variable, etc.), it:

1. Creates a `Symbol` in `symbolTable` for semantic analysis
2. Creates or finds a `ReferenceableItem` by copying Symbol properties
3. Adds a `Reference` to that ReferenceableItem's list
4. Discards the Symbol when parsing completes

This separation allows the parser to maintain its own temporary symbol table while building the persistent cross-reference database.

.Symbol and Reference Data Structures
image::diagrams/symbol-structures.svg[Symbol structures]

=== Files and Buffers

Many strange things are going on with reading files so that is not completely understood yet.

Here is an initial attempt at illustrating how some of the file and text/lexem buffers are related.

.File Descriptor and Buffer Relationships
image::diagrams/buffer-structures.svg[Buffer structures]

NOTE: It would be nice if the `LexemStream` structure could point to a
`LexemBuffer` instead of holding separate pointers which are
impossible to know what they actually point to...

NOTE: This could be achieved if we could remove the CharacterBuffer
from LexemBuffer and make that a reference instead of a
composition. Then we'd need to add a CharacterBuffer to the structures
that has a LexemBuffer as a component (if they use it).

=== Modes

`c-xrefactory` operates in different modes ("regimes" in original
`c-xref` parlance):

- xref - batch mode reference generation
- server - editor server
- refactory - refactory browser

The default mode is "xref". The command line options `-server` and `-refactory`
selects one of the other modes. Branching is done in the final lines in
`main()`.

The code for the modes are intertwined, probably through re-use of
already existing functionality when extending to a refactoring
browser.

One evidence for this is that the refactory module calls the "main
task" as a "sub-task".  This forces some intricate fiddling with the
options data structure, like copying it.  Which I don't
fully understand yet.

TODO?: Strip away the various "regimes" into more separated concerns
and handle options differently.

=== Options

The `Options` datastructure is used to collect options from the
command line as well as from options/configuration files and piped
options from the editor client using process-to-process
communication.

It consists of a collection of fields of the types

- elementary types (bool, int, ...)
- string (pointers to strings)
- lists of strings (linked lists of pointers to strings)

==== Allocation & Copying

Options has its own allocation using `optAlloc` which allocates in a
separate area, currently part of the options structure and utilizing
"dynamic allocation" (`dm_` functions on the `Memory` structure).

The Options structure are copied multiple times during a session, both
as a backup (`savedOptions`) and into a separate options structure
used by the Refactorer (`refactoringOptions`).

Since the options memory is then also copied, all pointers into the
options memory need to be updated. To be able to do this, the options
structure contains lists of addresses that needs to by "shifted".

When an option with a string or string list value is modified the
option is registered in either the list of string valued options or
the list of string list valued options. When an options structure is
copied it must be performed using a deep copy function which "shifts"
those options and their values (areas in the options memory) in the
copy so that they point into the memory area of the copy, not the
original.

After the deep copy the following point into the option memory of the
copy

- the lists of string and string list valued options (option fields)
- all string and string valued option fields that are used (allocated)
- all list nodes for the used option (allocated)
- all list nodes for the string lists (allocated)

=== Arena Allocators (Memory)

Arena allocators (also called region-based or bump allocators) are the fundamental memory management strategy used throughout c-xrefactory for performance-critical operations like macro expansion and lexical analysis.

==== The Memory Structure

[source,c]
----
typedef struct memory {
    char   *name;              // Arena name for diagnostics
    bool  (*overflowHandler)(int n); // Optional resize handler
    int     index;             // Next allocation offset (bump pointer)
    int     max;               // High-water mark
    size_t  size;              // Total arena size
    char   *area;              // Actual memory region
} Memory;
----

==== Allocation Model

Arena allocators use **bump pointer allocation**:

1. Allocation: Return `&area[index]`, then `index += size`
2. Deallocation: Bulk rollback via `FreeUntil(marker)`
3. Reallocation: Only possible for most recent allocation

This is extremely fast (O(1) allocation) but requires stack-like discipline for deallocation.

==== Stack-Like Discipline

Arenas follow LIFO (last-in-first-out) cleanup:

[source,c]
----
marker = ppmAllocc(0);        // Save current index
temp1 = ppmAllocc(100);       // Allocate
temp2 = ppmAllocc(200);       // Allocate
// Use temp1, temp2...
ppmFreeUntil(marker);         // Free both temp1 and temp2
----

==== Key Constraint: Top-of-Stack Reallocation

Only the most recent allocation can be resized:

[source,c]
----
buffer = ppmAllocc(1000);     // Allocate buffer
temp = ppmAllocc(500);        // Allocate temporary
ppmReallocc(buffer, ...);     // ❌ FAILS - buffer not at top
----

This constraint is enforced by guards in `memory.c` (see Development Environment chapter).

==== Memory Arena Types

c-xrefactory uses specialized arenas for different purposes (see Components chapter for details):

* `cxMemory` - Cross-reference database and symbol tables
* `ppmMemory` - Preprocessor macro expansion (temporary)
* `macroBodyMemory` - Macro body buffers
* `macroArgumentsMemory` - Macro argument expansion
* `fileTableMemory` - File table entries
* `optMemory` - Option strings (with special pointer adjustment)

=== Preload Mechanism

The preload mechanism allows the server to work with editor buffer contents that haven't been saved to disk. This is essential for providing real-time symbol navigation and completion while the user is actively editing.

==== How It Works

When an editor buffer is modified but not yet saved:

1. **Editor Action**: The Emacs client writes the current buffer content to a temporary file
2. **Server Request**: The client sends a request with `-preload <filename> <tmpfile>` options
3. **Buffer Association**: The server creates an `EditorBuffer` structure linking the on-disk filename to the temporary file containing the actual content
4. **Transparent Parsing**: When the server needs to parse the file, it transparently reads from the temporary file instead of the on-disk file

==== Why It's Needed

Without preload, the server would only see the last saved version of the file. The preload mechanism ensures that:

* Symbol navigation works with the current buffer state
* Completion suggests symbols based on what's actually typed
* Refactorings operate on the current code, not stale saved content
* Users get immediate feedback without having to save constantly

==== Reference Management

When a file is preloaded, the server must handle reference updates carefully:

* **Old references** from the previous file version must be removed from the reference table before parsing
* This prevents duplicate references (one set at old positions, another at new positions)
* The removal happens in `removeReferencesForFile()` when preloaded content is detected

=== Browser Stack

The browser stack maintains navigation history for symbol references, allowing users to browse through code by pushing symbol lookups and navigating back through previous queries.

==== Structure

The browser stack is a linked list of `OlcxReferences` entries, where each entry represents a symbol lookup session:

* **Stack entries** contain complete symbol information and reference lists for one navigation session
* **Top pointer** indicates the current active entry being navigated
* **Root pointer** tracks the base of the stack (most recent entry still available)
* Entries between root and top are "future" navigation states that can be returned to via "next"

==== Lifecycle

1. **Push**: When user requests symbol references (e.g., `-olcxpush`), a new empty entry is created on the stack
2. **Population**: After parsing, the entry is filled with `BrowsingMenu` structures containing references
3. **Navigation**: Commands like `-olcxnext` and `-olcxprevious` move through references in the current entry
4. **Pop**: User can pop back to previous entries to return to earlier symbol lookups

==== Relationship to Parsing

The browser stack is populated in two stages:

1. **Parse-time**: References are collected in the referenceableItemTable during file parsing
2. **Menu Creation**: ReferenceableItems are wrapped in BrowsingMenu structures and added to the browser stack entry via `putOnLineLoadedReferences()`

This separation means that browser stack entries can become stale if files are reparsed (e.g., with preloaded content) without refreshing the stack. Users typically need to pop and re-push to get fresh reference lists after edits.

=== Browser Menu

A browser menu is a navigable list of referenceable items with their occurrences, organized for presentation to the user in Emacs. Multiple items may appear in a single menu when name resolution finds several candidates (e.g., symbols with the same name in different scopes).

==== BrowsingMenu Structure

Each `BrowsingMenu` entry is a menu item wrapping a `ReferenceableItem` with UI presentation state:

* **referenceable**: The embedded `ReferenceableItem` (the entity being browsed)
  ** Contains `linkName`, `type`, `storage`, `scope`, `visibility`
  ** Contains the list of `references` (occurrences) for this item
* **selected**: Whether this item is currently selected for operations
* **visible**: Whether this item passes current visibility filters
* **defaultPosition**: The "best" occurrence to jump to (usually the definition)
* **defaultUsage**: The usage type of the default occurrence
* **outOnLine**: Display line number in the Emacs menu
* **markers**: Editor markers for refactoring operations
* **next**: Pointer to next menu item in the list

**Key insight:** `BrowsingMenu` is not just a menu - it's a **menu item**. A collection of `BrowserMenu` items forms the actual menu shown to the user.

==== Multiple Menu Items in One Session

A single browser stack entry (`OlcxReferences`) can contain multiple `BrowsingMenu` items:

* **hkSelectedSym**: Menu items that matched at the cursor position (after disambiguation)
* **symbolsMenu**: Complete menu including related items (same name, similar signatures)

This allows users to:

* See all candidates when a symbol is ambiguous
* Navigate between related definitions (different scopes, include files)
* Select specific items for refactoring operations

==== Menu Population

Browser menus are populated by scanning the referenceableItemTable:

1. **Symbol lookup**: Find all `ReferenceableItem` entries matching the requested symbol
2. **Menu item creation**: Wrap each matching item in a `BrowsingMenu` structure
3. **Reference collection**: References are already in the ReferenceableItem
4. **Sorting and filtering**: Order items by relevance and apply visibility filters
5. **Selection**: Mark items that best match the cursor context (e.g., same file)

=== Putting It All Together: Domain Model Summary

Understanding the complete flow from parsing to browsing:

==== During Parsing (Building the Cross-Reference Database)

1. **Parser creates Symbols**: As the C/Yacc parser processes source code, it creates `Symbol` entries in `symbolTable` for semantic analysis
2. **ReferenceableItems are created/found**: When encountering referenceable constructs (functions, variables, types, etc.):
   * Create a `ReferenceableItem` from Symbol properties
   * Check if it already exists in `referenceableItemTable`
   * If new, add it to the table; if exists, reuse the existing one
3. **References are recorded**: Add a `Reference` (occurrence) to the ReferenceableItem's list, recording position and usage
4. **Symbols are discarded**: After parsing completes, the `symbolTable` is cleared (Symbols are temporary)
5. **Database is persisted**: ReferenceableItems and their References are saved to `.cx` files

**Result:** A persistent database mapping each entity (ReferenceableItem) to all its occurrences (References) across the entire codebase.

==== During Browsing (Interactive Navigation)

1. **User requests symbol info**: User places cursor on a symbol and invokes a command (e.g., "push to symbol")
2. **Symbol lookup**: Server finds matching ReferenceableItem(s) in `referenceableItemTable`
3. **BrowsingMenu creation**: Each matching ReferenceableItem is wrapped in a `BrowserMenu` structure
   * Adds UI state (selected, visible, display position)
   * Marks best-fit match (e.g., same file as cursor)
4. **Stack push**: BrowsingMenu items are added to the browser stack (`OlcxReferences` entry)
5. **Display to user**: Menu sent to Emacs showing all matching items and their occurrences
6. **Navigation**: User can browse through references, select items, invoke refactorings

**Result:** Interactive navigation through the cross-reference database with selection and filtering.

==== Key Relationships

[source]
----
Symbol (parser)
    ↓ (creates during parsing)
ReferenceableItem (persistent entity)
    ├─→ references: Reference* (list of occurrences)
    └─→ stored in: referenceableItemTable
         ↓ (wrapped for browsing)
      BrowsingMenu (UI wrapper)
         └─→ stored in: OlcxReferences.symbolsMenu (browser stack)
----

This architecture separates concerns:

* **Parser symbols** - Temporary, for semantic analysis
* **Cross-reference database** - Persistent, for finding all uses
* **Browser menus** - Presentation layer, for user interaction



