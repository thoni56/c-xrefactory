== Functional Overview

The _c-xref_ program is actually a mish-mash of a multitude of
features baked into one program. This is the major cause of the mess
that it is source-wise.

It was

- a generator for persistent cross-reference data
- a reference server for editors, serving cross-reference, navigational and completion data over a protocol
- a refactoring server (the worlds first to cross the Refactoring Rubicon)
- [.line-through]#an HTML cross-reference generator (probably the root of the project)# (REMOVED)
- [.line-through]#a C macro generator for structure fill (and other) functions# (REMOVED)

It is the first three that are unique and constitutes the great value
of this project. The last two have been removed from the source, the
last one because it was a hack and prevented modern, tidy, building,
coding and refactoring. The HTML cross-reference generator has been
superseeded by modern alternatives like Doxygen and is not at the core
of the goal of this project.

One might surmise that it was the HTML-crossreference generator that
was the initial purpose of what the original `Xrefactory` was based
upon. Once that was in place the other followed, and were basically
only bolted on top without much re-architecting the C sources.

What we'd like to do is partition the project into separate parts,
each having a clear usage.

The following sections are aimed at describing various features of
`c-xrefactory`.

=== Main functionality

A programmer constantly needs to navigate, understand and improve the
source code in order to lessen the cognitive load for understanding
and making changes.

`c-xrefactory` provides two sets of functions for this directly from
within the editor

- navigation, searching and browsing symbols
- automated refactorings, i.e. non-behaviour changing edits

C and Yacc source code is supported.

==== Navigation and Browsing

A user can navigate all references of a symbol, limited to the
semantic scope of that symbol, by "Goto Definition" and then navigate
using "Next/previous Reference". This is a fast way to inspect where a
symbol is used.

NOTE: This also applies to non-terminals and semantic attributes in
Yacc grammars!

It is also possible to search for definitions or symbols containing a
string, including possible wildcards. This will present various forms
of "menues" where filters can be applied and a found symbol be
inspected.

Together these provides a comprehensive set of features for exploring
and navigating any code base.

==== Automated refactorings

In his book "Refactoring" Martin Fowler describes a large number of
refactorings, changes to source code that does not change the
behaviour, but improves it structure and readability. In an article
from 2001 he actually pronounces `Xref`, the ancestor to
`c-xrefactory`, to be the first tool to cross "Refactorings Rubicon",
being able to extract a function semantically correct.

The term "automated" means that some software can examine the source
code and quickly and safely modify it using patterns from the list of
possible refactorings, without user interaction. Many refactorings in
the book, and on the website, are applicable mostly for OO-languages,
but many also apply to C. `c-xrefactory` can perform some of
them. More are considered for implementation.

- "Rename Symbol" - change the name of a variable, type, function only for the semantic scope of the symbol
- "Extract Macro/Function" - a region of the code can be extracted to a new function or macro
- "Organize Includes" - clean up a list of #include directives by particioning and sorting them
- "Rename Included File" - rename the file in the #include directive and update all other #include directives of that file
- "Move Function To Other File" - move a function to another file, automatically add an extern declaration in an appropriate header file and ensure that is included in the file where the function originally was

Using these automated refactorings it is much easier and safer to
continuously maintain and improve the quality of any code base.

=== Options, option files and configuration

The current version of C-xrefactory allows only two possible sets of
configuration/options.

The primary storage is (currently) the file `$HOME/.c-xrefrc`
which stores the "standard" options for all projects. Each project has
a separate section which is started with a section marker, the project
name surrounded by square brackets, `[project1]`.

When you start `c-xref` you can use the command line option `-xrefrc`
to request that a particular option file should be used instead of the
"standard options".

NOTE: When running the edit server there seems to be no way to
indicate a different options files for different
projects/files. Although you can start the server with `-xrefrc` you
will be stuck with that in the whole session and for all projects.

=== LSP

The LSP protocol is a common protocol for language servers such as
`clangd` and `c-xrefactory`. It allows an editor (client) to interface
to a server to request information, such as reference positions, and
operations, such as refactorings, without knowing exactly which server
it talks to.

Recent versions of `c-xrefactory` have an initial implementation of a
very small portion of the LSP protocol. The plan is to fully integrate
the functionality of `c-xrefactory` into the LSP protocol. This will
allow use of `c-xrefactory` from not only Emacs but also Visual Studio
Code or any other editor that supports the LSP protocol.

==== LSP Protocol Limitations

The LSP protocol was designed for single-shot, non-interactive operations.
This creates constraints for c-xrefactory's advanced refactorings:

**Interactive Refactorings**: C-xrefactory's extract/parameter operations
require multi-step user input (names, positions, declarations). LSP's
`textDocument/codeAction` doesn't support interactive dialogs.

**Symbol Browsing**: C-xrefactory provides interactive symbol browsers
with filtering and keyboard navigation. LSP returns flat reference lists
with no standard for interactive UI.

**Strategy**: The LSP implementation aims to:

- Provide basic IDE features (definition, completion, simple refactorings)
  to modern editors
- Expose c-xrefactory's advanced refactoring capabilities where possible
- Keep the Emacs client as the primary interface for full interactive features

LSP serves to make c-xrefactory more accessible while the Emacs client
probably will remain the gateway to its complete refactoring power.

