== Major Codebase Improvements

This chapter documents internal architectural changes and technical debt reduction efforts that improve code quality, maintainability, and performance. These are improvements to c-xrefactory's own implementation, not features users interact with directly.

For planned user-facing features, see link:16-planned-features.adoc[Chapter 16: Planned Features].

=== Clean Persistence Store Abstraction

==== Problem Statement

The `cxfile` module currently mixes multiple responsibilities that should be separated:

* **Persistence implementation** (reading/writing .cx files) ✓ Correct level
* **Search and filter operations** (matching search strings) ✗ Wrong level
* **Operation-specific loading** (menu creation, macro completion, unused detection) ✗ Too specific
* **Treated as source of truth** (when it should be just a cache) ✗ Architectural confusion

This mixing creates tight coupling, makes testing difficult, and prevents future architectural improvements (like LSP integration or alternative storage backends).

==== Architectural Confusion: In-Memory vs Persistence

The current code conflates two distinct concepts:

*Reference Database* (Smart Layer - Source of Truth)::

- **Always in-memory**: The `referenceableItemTable` hash table
- Answers queries fast from RAM
- Decides when to load from persistence
- Decides when to save to persistence
- Manages invalidation and staleness
- **This is the actual database**

*Persistence Store* (Dumb Layer - Durable Cache)::

- **Always on disk/database**: The `.cx` files (or future SQLite, etc.)
- Just knows how to save/load a specific format
- Has NO in-memory state of its own
- No business logic, no searching, no filtering
- **This is just the storage mechanism**

IMPORTANT: The persistence layer is **always about durable storage** that survives restarts. "In-memory persistence" is a contradiction - persistence means surviving across sessions.

==== Current Architecture Problems

===== Mixed Abstraction Levels

The current `cxfile.h` public interface exposes:

[source,c]
----
// Operation-specific scanning (too high-level for storage)
extern void scanReferencesToCreateMenu(char *symbolName);
extern void scanForMacroUsage(char *symbolName);
extern void scanForGlobalUnused(char *cxrefFileName);
extern void scanForSearch(char *cxrefFileName);

// Implementation details leaked (partitioning is internal)
extern int cxFileHashNumberForSymbol(char *symbol);
extern void searchSymbolCheckReference(ReferenceableItem *item, Reference *ref);

// Generic API (already identified as "Abstract API")
extern bool loadFileNumbersFromStore(void);
extern void ensureReferencesAreLoadedFor(char *symbolName);
extern void saveReferencesToStore(bool updating, char *name);
----

Problems:

* **Four `scan*` functions**: Encode specific use cases (menu, macro, unused, search) instead of providing generic operations
* **Implementation details exposed**: `cxFileHashNumberForSymbol()` is a partitioning optimization that shouldn't be public
* **Search logic in storage**: `searchSymbolCheckReference()` mixes filtering with persistence
* **Side-effect heavy**: All functions mutate global `referenceableItemTable` implicitly

===== Tight Coupling to Use Cases

Currently `cxfile.c` knows about:

* Browser menus (`scanReferencesToCreateMenu`)
* Macro completion (`scanForMacroUsage`)
* Unused symbol detection (`scanForGlobalUnused`)
* Symbol search (`scanForSearch`)

A persistence layer shouldn't know about any of these! These are *clients* of storage, not responsibilities of storage.

===== Wrong Source of Truth

From the navigation debugging (see Insights chapter), we discovered:

[source,c]
----
// In cxref.c - loads FROM DISK directly
scanReferencesToCreateMenu(symbolName);  // Treats .cx files as truth
----

This bypasses the in-memory `referenceableItemTable`, treating disk as authoritative. But the **actual truth** is:

----
referenceableItemTable = Disk state (.cx files) + Preloaded editor buffers
----

The disk is just a **cache** of the last saved state, not the current truth.

==== Proposed Architecture

===== Two-Layer Design

[source]
----
┌──────────────────────────────────────────────────┐
│  Reference Database (Smart Layer)                │
│  Source of Truth: referenceableItemTable (RAM)   │
│                                                  │
│  - Fast in-memory queries                        │
│  - Knows what's current vs stale                 │
│  - Handles invalidation/refresh                  │
│  - Decides when to load/save                     │
│  - Unified interface for all clients             │
└──────────────────────────────────────────────────┘
                      ↓
        (only when loading/saving needed)
                      ↓
┌──────────────────────────────────────────────────┐
│  Persistence Store (Dumb Layer)                  │
│  Durable Cache: .cx files on disk                │
│                                                  │
│  - Just save/load binary format                  │
│  - No business logic                             │
│  - No in-memory state                            │
│  - Can be swapped (SQLite, Protobuf, etc.)       │
└──────────────────────────────────────────────────┘
----

===== Clean Persistence Store Interface

[source,c]
----
// persistence_store.h - Pure storage operations
#ifndef PERSISTENCE_STORE_H_INCLUDED
#define PERSISTENCE_STORE_H_INCLUDED

#include "referenceableitem.h"

/* ============================================
 * Store Lifecycle
 * ============================================ */

// Load metadata (file numbers, timestamps)
extern bool persistenceLoadMetadata(void);

// Persist all references to durable storage
extern void persistenceSaveAll(bool updating, char *location);

/* ============================================
 * Reference Loading (into referenceableItemTable)
 * ============================================ */

// Load references for specific symbol into memory table
// Returns true if symbol found in storage
extern bool persistenceLoadSymbol(char *symbolName);

/* ============================================
 * Bulk Scanning
 * ============================================ */

// Scan entire storage, calling visitor for each reference
// Visitor decides what to do with each reference
typedef void (*PersistenceVisitor)(ReferenceableItem *item,
                                    Reference *ref,
                                    void *context);
extern void persistenceScanAll(PersistenceVisitor visitor, void *context);

#endif
----

===== Reference Database Interface

This layer provides the "smart" operations that clients actually need:

[source,c]
----
// reference_database.h - Smart operations (initially thin wrapper)
#ifndef REFERENCE_DATABASE_H_INCLUDED
#define REFERENCE_DATABASE_H_INCLUDED

#include "referenceableitem.h"
#include "position.h"

// Initialize the in-memory reference database
extern bool refDbInitialize(void);

// Lookup symbol in the in-memory table
// Automatically loads from persistence if not in memory
extern ReferenceableItem* refDbLookupSymbol(char *name);

// Get all references for a symbol
// Ensures data is loaded and current
extern Reference* refDbGetReferences(char *symbolName);

// Mark a file's references as stale (needs reload)
extern void refDbInvalidateFile(int fileNumber);

// Persist the current in-memory state
extern void refDbSave(bool updating, char *location);

#endif
----

NOTE: This interface starts simple but is where the *Unified Symbol Database* refactoring (next section) will add smart on-demand loading, dependency tracking, and invalidation logic.

==== Migration Strategy

===== Phase 1: Create Clean Boundaries (No Behavior Change)

. Rename `cxfile.h` → `cxfile_internal.h` (implementation detail)
. Create `persistence_store.h` with clean interface
. Create `persistence_store.c` that delegates to `cxfile_*` functions
. Update all callers to use `persistence_store.h` instead of `cxfile.h`

Result: Same behavior, cleaner names, clear intent.

===== Phase 2: Extract Operation Logic

Move operation-specific logic OUT of persistence layer:

*Search Logic*:: `searchSymbolCheckReference()` → new `search.c` module
+
[source,c]
----
// Before: In cxfile.c (WRONG LEVEL)
void searchSymbolCheckReference(ReferenceableItem *item, Reference *ref) {
    if (searchStringMatch(...)) {
        reportMatch(item, ref);
    }
}

// After: In search.c (RIGHT LEVEL)
void searchForSymbol(char *pattern) {
    persistenceScanAll(checkSearchMatch, pattern);
}

static void checkSearchMatch(ReferenceableItem *item, Reference *ref, void *ctx) {
    if (searchStringMatch(item->linkName, (char *)ctx)) {
        reportMatch(item, ref);
    }
}
----

*Unused Detection*:: Extract from `cxfile.c` to `refactorings.c` or new `analysis.c`

*Menu Creation*:: Keep in `cxref.c` but use clean `refDbGetReferences()` instead of direct disk scanning

===== Phase 3: Hide Implementation Details

Make these functions `static` (internal to cxfile.c):

* `cxFileHashNumberForSymbol()` - partitioning is implementation detail
* `searchSymbolCheckReference()` - moved to search module
* All internal scanning logic

===== Phase 4: Consolidate Scanning Functions

Replace four specific scanners with generic visitor pattern:

[cols="1,1"]
|===
|Old (Use-Case Specific) |New (Generic)

|`scanReferencesToCreateMenu(name)`
|`refDbGetReferences(name)`

|`scanForMacroUsage(name)`
|`refDbGetReferences(name)`

|`scanForGlobalUnused(location)`
|`persistenceScanAll(checkUnused, ctx)`

|`scanForSearch(location)`
|`persistenceScanAll(checkMatch, pattern)`
|===

==== Benefits

*Testability*:: Can mock `persistence_store.h` for testing navigation without .cx files
+
*Future Storage Backends*:: Could implement with SQLite, in-memory testing mock, or different binary format
+
*Clear Boundaries*:: Storage vs search vs navigation clearly separated
+
*Simpler Interface*:: 4 functions instead of 9, clearer responsibilities
+
*Less Coupling*:: Parsing code doesn't call storage directly, goes through reference database
+
*LSP Readiness*:: Reference database layer is where LSP `textDocument/didChange` integration will live

==== Relationship to Unified Symbol Database

This refactoring is the **foundation** for the larger *Unified Symbol Database Architecture* (next section):

* **Clean persistence layer** enables swapping storage backends without affecting clients
* **Reference database layer** is where smart on-demand loading logic will live
* **Separation of concerns** makes the unified architecture clearer

Migration path:

. First: Clean up persistence (this refactoring)
. Then: Add smart on-demand logic to reference database (next refactoring)
. Finally: Both Emacs and LSP use same unified code path

==== Implementation Checklist

- [ ] Create `persistence_store.h` with proposed interface
- [ ] Create `persistence_store.c` delegating to cxfile
- [ ] Rename `cxfile.h` → `cxfile_internal.h`
- [ ] Create `reference_database.h` (thin wrapper initially)
- [ ] Create `reference_database.c` delegating to persistence
- [ ] Update all callers to use new interfaces
- [ ] Move search logic from cxfile to search module
- [ ] Move unused detection logic to appropriate module
- [ ] Make `cxFileHashNumberForSymbol` static
- [ ] Make `searchSymbolCheckReference` static or remove
- [ ] Add unit tests for both interfaces
- [ ] Update documentation

==== References

* Current implementation: `src/cxfile.c`, `src/cxfile.h`
* In-memory table: `src/reftab.c` (referenceableItemTable)
* Navigation architecture: Chapter 17 (Insights) - Navigation Architecture section

[[unified-symbol-database]]
=== Unified Symbol Database Architecture

NOTE: This section describes the implementation details for the "Memory as Truth" architectural vision. See link:15-roadmap.adoc[Chapter 15: Roadmap] for the high-level dependency chain showing how this work relates to other architectural goals.

==== Problem Statement

The current symbol database has evolved from a batch cross-referencer (like `ctags`) with artificial distinctions between "file-based" and "on-demand" modes. This creates:

* **Mode complexity**: Different code paths for Emacs vs LSP clients
* **Cold start problems**: Requires upfront `-create` operation before use
* **Manual updates**: Users must remember to run `-update` after changes
* **Inconsistent behavior**: Different modes provide different guarantees
* **Maintenance overhead**: Multiple implementations to maintain and test

==== Current Architecture Limitations

The existing system distinguishes between:

[cols="1,1,1"]
|===
|Aspect |File-Based Mode |On-Demand Mode

|**Cold Start**
|Requires `-create` first
|Parse file immediately

|**Warm Queries**
|O(1) hash lookup
|O(file_size) parsing

|**Memory Usage**
|Low (streaming)
|High (in-memory cache)

|**Incremental Updates**
|Smart file tracking
|Per-file invalidation

|**Multi-project**
|Separate databases
|Workspace-scoped
|===

==== Proposed Solution

===== Core Insight: Unified On-Demand Architecture

Both Emacs and LSP clients want the same thing: **up-to-date symbol and reference information**. The distinction between "file-based" and "on-demand" modes is artificial complexity. Instead, c-xrefactory should provide a unified interface that:

1. **Always ensures information is current** using existing dependency tracking
2. **Scans incrementally** only what's needed, when needed  
3. **Uses `.cx` files as persistent cache** for optimization
4. **Eliminates cold start problems** by avoiding upfront full-project scanning

===== Simplified Interface Design

[source,c]
----
typedef struct SymbolDatabase SymbolDatabase;

typedef struct {
    // Unified operations for any client (Emacs or LSP)
    Symbol* (*lookupSymbol)(SymbolDatabase* db, const char* name, Position pos);
    ReferenceList* (*getReferences)(SymbolDatabase* db, const char* name, Position pos);
    ReferenceList* (*getOccurrences)(SymbolDatabase* db, const char* name, Position pos);
    
    // All complexity hidden in implementation:
    // - File modification checking (existing: checkFileModifiedTime)
    // - Include dependency tracking (existing: cachedIncludedFilePass) 
    // - Incremental scanning (existing: makeIncludeClosureOfFilesToUpdate)
    // - Persistent caching (existing: .cx file system)
} SymbolDatabaseOperations;
----

===== Implementation Strategy: Smart On-Demand

IMPORTANT: This refactoring builds on the *Clean Persistence Store* foundation (previous section). The smart logic lives in the **in-memory reference database layer**, while `.cx` files remain a **durable cache** for persistence.

===== Core Principle: In-Memory Is Always Authoritative

The fundamental architectural shift is that **in-memory references are the single source of truth** once a file is parsed:

----
┌─────────────────────────────────────────────────────────────┐
│                   In-memory references                       │
│                   (single source of truth)                   │
└─────────────────────────────────────────────────────────────┘
        ▲                    │                    ▲
        │ parse              │ persist            │ parse on demand
        │ on demand          │ (background)       │
        │                    ▼                    │
┌───────┴───────┐   ┌────────────────┐   ┌───────┴───────┐
│    server     │   │  .cx cache     │   │   refactory   │
│  (navigation) │   │  (startup      │   │ (finds files, │
│               │   │   speedup)     │   │  parses them) │
└───────────────┘   └────────────────┘   └───────────────┘
----

**Key changes from current architecture:**

1. **In-memory is authoritative** - once a file is parsed, that's the truth
2. **.cx becomes a cache** - only for faster startup, never consulted during operations
3. **Refactoring parses on demand** - no `callXref()`, just parse the files it needs
4. **Navigation and refactoring use same code path** - unified architecture

The implementation leverages **existing sophisticated logic**:

[source,c]
----
Symbol* lookupSymbol(const char* name, Position pos) {
    // 1. Check if in-memory table has current information
    if (refTableHasCurrent(name, pos)) {
        return lookupInMemoryTable(name, pos);  // Answer from RAM
    }

    // 2. Load from persistence if not in memory
    if (!refTableHasSymbol(name)) {
        persistenceLoadSymbol(name);  // Load .cx into referenceableItemTable
    }

    // 3. Check if loaded data is stale (file modified since load)
    if (refTableDataIsStale(name, pos)) {
        // Use existing dependency tracking to scan minimal set
        FileList* filesToScan = calculateDependencyClosure(pos.file);
        for (FileItem* file : filesToScan) {
            if (checkFileModifiedTime(file->fileNumber)) {
                parseFileAndUpdateTable(file);  // Reparse into memory
            }
        }
    }

    // 4. Answer from in-memory table (now guaranteed current)
    return lookupInMemoryTable(name, pos);
}
----

**Architectural Layers:**

----
Query → Reference Database (in-memory, smart) → Persistence Store (disk, dumb)
        ↑                                         ↑
        Always answers from RAM                   Only for load/save
----

**Key Benefits:**

* **No artificial modes** - same code path for all clients
* **No cold start** - first lookup triggers minimal necessary scanning
* **Incremental by design** - only scans files that need updating
* **In-memory speed** - all queries answered from RAM (referenceableItemTable)
* **Durable cache** - `.cx` files persist state across sessions
* **Existing logic reuse** - leverages proven dependency tracking system

===== Legacy Architecture Recognition

c-xrefactory evolved from a **batch cross-referencer** (like `ctags`) and was enhanced for real-time use:

[source,bash]
----
# Legacy batch workflow:
c-xref -create project.c     # Full scan, build .cx database
c-xref -update modified.c    # Incremental update
c-xref -olcxpush symbol      # Query pre-built database

# Unified approach:
c-xref -server               # Start server, scan on-demand as needed
c-xref -lsp                  # Same logic, different protocol
----

IMPORTANT: The `.cx` files are a **durable cache** that persists the in-memory `referenceableItemTable` between sessions. They are an optimization, not the database itself. The actual database is always in RAM.

==== Implementation Plan

===== Phase 1: Interface Unification

* Create unified `SymbolDatabase` interface
* Wrap existing logic in smart on-demand implementation
* Replace explicit `-create`/`-update` commands with automatic dependency checking
* Both Emacs and LSP use same code path

===== Phase 2: Optimization

* Enhance existing dependency tracking for finer-grained invalidation
* Optimize in-memory caching strategies
* Background `.cx` file maintenance for long-running sessions
* Performance tuning for large codebases

==== Benefits

===== Architectural Simplification

* **Single code path** for both Emacs and LSP clients - eliminates maintenance overhead
* **No mode distinctions** - same smart logic serves all use cases optimally
* **Leverages existing logic** - reuses proven dependency tracking and caching systems
* **Reduced complexity** - eliminates artificial FILE_BASED/ON_DEMAND/HYBRID modes

===== User Experience Improvements

* **Zero configuration** - works immediately on any C project without setup
* **No cold start delay** - first symbol lookup triggers minimal necessary scanning
* **Transparent caching** - `.cx` files automatically maintained as performance optimization
* **Consistent behavior** - same results whether using Emacs or modern IDE with LSP

===== Performance Characteristics

* **Minimal initial cost** - avoids expensive upfront full-project scanning
* **Smart incremental updates** - only rescans files that have actually changed
* **Automatic dependency tracking** - includes files affected by changes get updated
* **Persistent optimization** - analysis results cached across sessions

===== Development Benefits

* **Backward compatibility** - existing Emacs workflows continue unchanged
* **Forward compatibility** - natural path to modern LSP integration
* **Reduced maintenance** - single implementation instead of multiple modes
* **Enhanced testability** - unified logic easier to test comprehensively

==== Existing Infrastructure

===== Sophisticated Dependency Tracking

The unified approach leverages c-xrefactory's **existing sophisticated dependency management** that handles include file relationships automatically:

**File Modification Tracking** (`filetable.h`):

[source,c]
----
typedef struct fileItem {
    char *name;
    time_t lastModified;        // Last known modification time
    time_t lastInspected;       // Last time we checked
    time_t lastUpdateMtime;     // Last update cycle time  
    time_t lastFullUpdateMtime; // Last full update time
    // ... scheduling and state flags
} FileItem;

bool checkFileModifiedTime(int fileNumber);
----

**Include Dependency Tracking** (`yylex.c`):

[source,c]
----
void pushInclude(FILE *file, EditorBuffer *buffer, char *name, char *prepend) {
    // ... setup include stack
    includeStack.stack[includeStack.pointer++] = currentFile;
    // Track include relationships for dependency analysis
}
----

**Automatic Include Closure** (`xref.c:81-108`):

[source,c]
----
static void makeIncludeClosureOfFilesToUpdate(void) {
    // If file A includes file B, and B is modified, A gets scheduled for update
    // This uses the reference database to track include relationships
    bool fileAddedFlag = true;
    while (fileAddedFlag) {
        // Iterative closure: keeps adding dependent files until stable
        for (all scheduled files) {
            find_all_files_that_include_this_file();
            schedule_them_for_update();
        }
    }
}
----

IMPORTANT: This dependency tracking infrastructure is **already production-ready** and handles the complex cases (transitive dependencies, modification time checking, include stack management). The unified symbol database can leverage this existing logic instead of reimplementing dependency management.

===== Refactoring Without callXref()

The current architecture has RefactoryMode internally calling XrefMode (`callXref()`) to update the persistent `.cx` database before performing refactorings (see Insights chapter, section "RefactoryMode Internally Calls XrefMode").

With the unified on-demand architecture, refactoring uses the **same in-memory reference database** as navigation:

[source,c]
----
void performRefactoring(Symbol *symbol) {
    // 1. Find files where symbol is referenced (from in-memory refs)
    FileList *referencingFiles = getFilesWithReferencesTo(symbol->name);

    // 2. Compute include closure of those files
    //    Uses existing makeIncludeClosureOfFilesToUpdate() infrastructure
    FileList *potentialReferences = computeIncludeClosure(referencingFiles);

    // 3. Filter to only stale files (mtime > lastParsedMtime)
    for (FileItem *f : potentialReferences) {
        if (f->lastModified > f->lastParsedMtime) {
            parseFileIntoMemory(f);  // Uses preload if available
        }
    }
    // Files already parsed with current content are NOT reparsed

    // 4. Perform refactoring using in-memory references
    // Same reference list used by navigation is now used by refactoring
    applyRefactoring(symbol, potentialReferences);
}
----

**Key simplification**: By limiting support to "include file patterns" only (see ADR-0013), we don't need to scan the entire project for archaic `extern` declarations in `.c` files. The include graph provides a complete and correct dependency closure.

**Benefits:**

* **Single code path** - Navigation and refactoring use the same reference database
* **No xref subprocess** - Eliminates process isolation complexity
* **Preloads work correctly** - Modified editor buffers are used directly
* **Faster refactoring** - Only stale files are reparsed, not entire project

==== Open Questions

. Should we maintain backward compatibility with explicit `-create`/`-update` commands?
** Probably yes, at least as no-ops or aliases to make transition easier

. How to handle very large projects (>1M LOC)?
** May need workspace-level configuration for incremental scanning thresholds
** Consider lazy loading of symbol data

. What's the migration path for existing users?
** Existing `.cx` files should continue to work
** Auto-migrate on first run with new version
** Provide clear documentation on new behavior

==== References

* Current implementation: `src/cxfile.c`, `src/xref.c`
* File tracking: `src/filetable.h`, `src/filetable.c`
* Dependency tracking: `src/xref.c` lines 81-108
* Current database description: See chapter 08 (Code) - Reference Database section

[[macro-expansion-module]]
=== Extract Macro Expansion Module

==== Problem Statement

The `yylex.c` file is **2353 lines** and combines multiple responsibilities:

* Lexical analysis and token reading
* File and buffer management
* Preprocessor directive processing
* **Macro expansion system** (~800 lines)

The macro expansion code is a substantial, cohesive subsystem that would benefit from extraction into its own module. Currently, it's deeply embedded in yylex.c, making both lexing and macro expansion harder to understand and test in isolation.

==== Current Architecture

The macro expansion system in `yylex.c` comprises:

===== Core Responsibilities (~800 lines)

* **Macro call expansion** - Main orchestration (`expandMacroCall()`)
* **Argument processing** - Collection and recursive expansion
* **Token collation** - `##` operator implementation
* **Stringification** - `#` operator implementation
* **Memory management** - Separate arenas for macro bodies (MBM) and arguments (PPM)
* **Cyclic detection** - Preventing infinite macro recursion

===== Key State

[source,c]
----
int macroStackIndex;  // Current macro expansion depth
static LexemStream macroInputStack[MACRO_INPUT_STACK_SIZE];
static Memory macroBodyMemory;      // Long-lived: macro definitions
static Memory macroArgumentsMemory; // Short-lived: expansion temporaries
----

===== Memory Lifetime Separation

The system uses **two distinct memory arenas** with different lifetimes:

* **MBM (Macro Body Memory)**: Persistent storage for macro definitions throughout compilation
* **PPM (PreProcessor Memory)**: Temporary storage for expansion, collation, and argument processing

This separation is fundamental and should be preserved in any refactoring.

==== Proposed Solution

Extract macro expansion into a new module: `macroexpansion.c/h`

===== Public Interface

The new module would expose a minimal, focused API:

[source,c]
----
// Initialization
void initMacroExpansion(void);
int getMacroBodyMemoryIndex(void);
void setMacroBodyMemoryIndex(int index);

// Core expansion
bool expandMacroCall(Symbol *macroSymbol, Position position);
bool insideMacro(void);
int getMacroStackDepth(void);

// Memory allocation (exposed for macro definition processing)
void *macroBodyAlloc(size_t size);
void *macroBodyRealloc(void *ptr, size_t oldSize, size_t newSize);
void *macroArgumentAlloc(size_t size);
----

===== Module Boundaries

*What moves to macroexpansion.c:*

* Macro call expansion and argument processing
* Token collation (`collate()` and helpers)
* Stringification (`macroArgumentsToString()`)
* Cyclic call detection
* MBM/PPM memory management
* Buffer expansion utilities (`expandPreprocessorBufferIfOverflow()`, etc.)

*What remains in yylex.c:*

* Lexing and file input
* Preprocessor directive processing (`#define`, `#ifdef`, etc.)
* Include file handling
* Main `yylex()` function
* Macro symbol table operations

*Dependencies:*

The macro module would depend on:

* Lexem stream operations (reading/writing)
* Symbol lookup (`findMacroSymbol()`)
* Cross-referencing (for collation and expansion references)
* Current input state (via accessor functions)

==== Benefits

===== Architectural

* **Separation of concerns**: Lexing vs. preprocessing clearly separated
* **Reduced file size**: yylex.c drops from 2353 → ~1550 lines (34% reduction)
* **Testability**: Macro expansion can be unit tested independently
* **Clearer ownership**: Macro state and memory management centralized

===== Maintainability

* **Focused modules**: Each file has a single, clear purpose
* **Easier reasoning**: Macro behavior isolated from lexer concerns
* **Better documentation**: Module-level documentation for macro system

===== Future flexibility

* Could support different macro systems (C vs. C++)
* Easier to add macro debugging/tracing
* Independent optimization of macro expansion

==== Implementation Strategy

===== Phase 1: Preparation (Already Complete)

✓ Create `LexemBufferDescriptor` type for buffer management +
✓ Refactor buffer expansion functions to use descriptor +
✓ Eliminate return values for size updates

===== Phase 2: Create Module Structure

* Create `macroexpansion.h` with public interface
* Create `macroexpansion.c` with initial implementations
* Move `LexemBufferDescriptor` to appropriate header
* Create accessor functions for `currentInput` state

===== Phase 3: Incremental Function Migration

Move functions in this order (lowest risk first):

1. **Memory management** - MBM/PPM allocation functions
2. **Buffer expansion** - `expandPreprocessorBufferIfOverflow()`, `expandMacroBodyBufferIfOverflow()`
3. **Support utilities** - `cyclicCall()`, `prependMacroInput()`
4. **Token processing** - `collate()`, `resolveMacroArgument()`, etc.
5. **Core expansion** - `expandMacroCall()`, `createMacroBodyAsNewStream()`, etc.

===== Phase 4: Integration and Cleanup

* Update yylex.c to use new interface
* Run full test suite after each migration step
* Add focused unit tests for macro expansion
* Update build system
* Document the new architecture

==== Risks and Mitigation

===== Risk: Complex dependencies

*Mitigation:*

* Create clear accessor functions for shared state
* Use incremental approach - one function group at a time
* Validate with tests after each step

===== Risk: Performance overhead

*Mitigation:*

* Keep critical functions inline where necessary
* Profile before/after migration
* Current code already has abstraction layers

*Assessment:* Low risk - macro operations are complex enough that function call overhead is negligible

===== Risk: Breaking existing tests

*Mitigation:*

* Run test suite after every migration step
* Keep interface behavior identical
* Use compiler to catch interface mismatches

==== Success Metrics

* All existing tests pass
* yylex.c reduced to ~1550 lines
* New focused tests for macro expansion added
* No performance regression (< 5% overhead acceptable)
* Code review confirms improved clarity

==== Open Questions

. Should `findMacroSymbol()` move to the macro module or stay in yylex.c?
** It's used by both lexer (for expansion triggering) and macro module (for nested expansions)
** Probably belongs in a shared location or as part of symbol table operations

. How to handle `currentInput` global state?
** Options: Pass explicitly, use accessor functions, or provide context structure
** Accessor functions likely cleanest: `getCurrentInput()`, `setCurrentInput()`

. Should we extract preprocessor directives at the same time?
** No - keep changes focused
** Could be a future refactoring after macro extraction proves successful

==== References

* Current code: `src/yylex.c` lines 1327-2089 (macro expansion system)
* Memory management: `src/memory.h`, `src/memory.c`
* Symbol operations: `src/symbol.h`
* Related refactoring: <<LexemStream API Improvements>> addresses buffer management patterns

---

NOTE: This refactoring is independent of the LexemStream API improvements but would benefit from them being completed first, as they simplify buffer management patterns throughout the macro expansion code.

[[move-function-refactoring]]
=== Move Function Between Files

==== Problem Statement

Moving functions between C source files is a frequent manual refactoring task that requires:

* Cutting function definition from source file
* Pasting into target file
* Changing `static` to `extern` (or vice versa)
* Adding function declaration to appropriate header
* Updating `#include` directives in both files
* Ensuring all dependencies (headers, types, macros) are available in target file

This is **error-prone** and **tedious**, especially for functions with complex dependencies.

==== Discovery: Existing Move Refactorings in c-xref-java

The Java-supporting version at `/home/thoni/Utveckling/c-xref-java` contains substantial move refactoring infrastructure:

[source,c]
----
// From c-xref-java/src/refactorings.def
#define AVR_MOVE_STATIC_METHOD 80
#define AVR_MOVE_CLASS 160
#define AVR_MOVE_CLASS_TO_NEW_FILE 170
#define AVR_MOVE_STATIC_FIELD 70
#define AVR_MOVE_FIELD 90
----

**Key implementations** in `c-xref-java/src/refactory.c`:

* `moveStaticMethod()` (line 2974) - Moves static methods between classes
* `moveClass()` (line 3074+) - Moves entire classes
* `moveStaticObjectAndMakeItPublic()` (line 2814) - Core move logic
* `applyExpandShortNames()` (line 2300) - Dependency expansion before move
* `reduceNamesAndAddImports()` (line 2645) - Import management after move

==== Leverageable Code from Java Version

===== Core Move Logic (Directly Reusable)

**Text block extraction/movement** is language-agnostic:

[source,c]
----
// From refactory.c:2865-2874
size = mend->offset - mstart->offset;
moveBlockInEditorBuffer(target, mstart, size, &editorUndo);
----

**Reference finding and updating** already works for C:

[source,c]
----
// From refactory.c:2843-2862
occs = getReferences(point, STANDARD_SELECT_SYMBOLS_MESSAGE, PPCV_BROWSER_TYPE_INFO);
LIST_MERGE_SORT(EditorMarkerList, occs, editorMarkerListBefore);
for (EditorMarkerList *ll = occs; ll != NULL; ll = ll->next) {
    // Update each call site
}
----

**Access modifier changes** map to C visibility:

[source,c]
----
// From refactory.c:2868
changeAccessModifier(point, limitIndex, "public");
// C equivalent: change "static" → "extern", add header declaration
----

===== Dependency Management Pattern (Needs C Adaptation)

**Java approach:**

[source,c]
----
// 1. Expand short names to fully qualified
applyExpandShortNames(point);
   // Before:  List myList;
   // After:   java.util.List myList;

// 2. Move the code
moveBlockInEditorBuffer(target, mstart, size, &editorUndo);

// 3. Reduce names and add imports
reduceNamesAndAddImports(&regions, INTERACTIVE_NO);
   // Before:  java.util.List myList;
   // After:   List myList; (with "import java.util.List;" added)
----

**C equivalent approach:**

[source,c]
----
// 1. Find required headers by analyzing dependencies
findRequiredHeaders(functionStart, functionEnd, &neededHeaders, &headerCount);
   // Scan function body for:
   // - Function calls → which header declares them?
   // - Type references → which header defines them?
   // - Macro usage → which header defines them?
   // Use symbol database to find declarations

// 2. Move the code (same as Java)
moveBlockInEditorBuffer(target, mstart, size, &editorUndo);

// 3. Add include directives to target file
addRequiredIncludes(targetFile, neededHeaders, headerCount);
   // Insert #include directives at top of target file
----

==== Proposed Implementation

**Estimation Approach**: We use relative complexity estimates (Story Points) with Phase 1 as the baseline (1×). This is more meaningful for hobby/OSS development than calendar time estimates. As phases complete, we can track velocity and refine future estimates.

===== Phase 1: Basic Move (MVP - Immediate Value) ✓ COMPLETED

**Relative complexity**: 1× (baseline for future estimates)

**Status**: Completed December 2024 / January 2025

**Implementation**: Handles 80% of common move function use cases with minimal user intervention.

**What was implemented:**

1. **Parser Integration** (`src/c_parser.y`, `src/yacc_parser.y`):
   - Added semantic actions to capture function boundaries during parsing
   - Uses `parsedPositions[IPP_FUNCTION_BEGIN/END]` to store function extent
   - Includes closing brace and trailing newline in boundary detection
   - Server operation `OLO_GET_FUNCTION_BOUNDS` triggers boundary capture

2. **Function Boundary Detection** (`src/refactory.c`):
   - `getFunctionBoundariesForMoving()` uses parser to find exact function extent
   - Handles comments and decorations before/after function
   - Works for both static and non-static functions

3. **Static Keyword Removal** (`src/refactory.c`):
   - Simple string search for "static " from function start to name
   - Only removes static when moving **between files** (not within same file)
   - Automatically removes without user prompting (streamlined UX)
   - Removes 7 characters ("static ") before moving to avoid offset tracking

4. **UI Integration** (`src/cxref.c`):
   - "Move Function" appears in refactoring menu only on function **definitions** (not call sites)
   - Uses `isDefinitionUsage()` to filter appropriately
   - Two-step workflow: set target, then invoke move

5. **Target Validation** (`src/refactory.c`, `src/yylex.c`):
   - Validates target is at global scope (not inside function/struct)
   - Uses `parsedInfo.moveTargetAccepted` flag from parser

6. **Tests**:
   - `test_move_c_function_to_other_file/` - moves between files, removes static
   - `test_move_c_function_inside_file/` - moves within file, keeps static
   - Both tests passing with deterministic output

**What user manually handles (acceptable for MVP):**

- Adding function declaration to header files
- Adding `#include` directives for dependencies
- Moving tightly-coupled static helper functions

**Files modified:**

- `src/c_parser.y` - parser integration for boundary detection
- `src/yacc_parser.y` - same for yacc files
- `src/refactory.c` - simplified `moveStaticFunctionAndMakeItExtern()`
- `src/cxref.c` - UI filter for definitions only
- `src/misc.c` - added `OLO_GET_FUNCTION_BOUNDS` to `requiresCreatingRefs()`
- `tests/test_move_c_function_*/` - enabled and passing

===== Phase 2: Add Function Declaration to Header

**Relative complexity**: ~0.5× Phase 1

Add automatic function declaration to target file's header:

**Approach:**

Following C conventions, when moving a function to `target.c`, add its declaration to `target.h` so other files can call it. This is much simpler than analyzing all dependencies.

**Algorithm:**

1. Determine target file path (e.g., `/path/to/target.c`)
2. Derive header path by replacing `.c` with `.h` (e.g., `/path/to/target.h`)
3. If header doesn't exist, create it with include guards
4. Find insertion point in header (after includes, before end of guard)
5. Generate function declaration from Symbol: `extern void func(int a);`
6. Insert declaration into header
7. User manually adds any needed `#include` directives to target file

**Implementation sketch:**

[source,c]
----
char *getHeaderPathForSourceFile(char *sourcePath) {
    // "/path/to/target.c" -> "/path/to/target.h"
    char *header = stackMemoryAlloc(strlen(sourcePath) + 1);
    strcpy(header, sourcePath);
    char *ext = strrchr(header, '.');
    if (ext && strcmp(ext, ".c") == 0) {
        strcpy(ext, ".h");
    }
    return header;
}

void createHeaderIfNeeded(char *headerPath) {
    if (!fileExists(headerPath)) {
        // Create header with include guards
        // "#ifndef TARGET_H\n#define TARGET_H\n\n#endif\n"
        char *guardName = makeIncludeGuardName(headerPath);
        // Write to file or EditorBuffer
    }
}

char *generateFunctionSignature(Symbol *function) {
    // Reconstruct function signature from Symbol
    // Example: "extern void func(int a, char *b)"
    // Need to walk function->typeModifier to build type string
    // This is the trickiest part
}

void addFunctionDeclarationToHeader(Symbol *function, char *headerPath) {
    // 1. Open or load header into EditorBuffer
    // 2. Find insertion point (before final #endif)
    // 3. Generate signature: "extern void func(int a);\n"
    // 4. Insert declaration
}

// In moveFunction() after moving the function block:
if (movingBetweenFiles) {
    char *headerPath = getHeaderPathForSourceFile(targetFilePath);
    createHeaderIfNeeded(headerPath);
    addFunctionDeclarationToHeader(parsedInfo.function, headerPath);
}
----

**Required infrastructure** (already exists):
- `Symbol` with function information (symbol.h)
- `Symbol.typeModifier` - contains return type and parameter information
- `EditorBuffer` manipulation for header file editing
- File path utilities

**Challenges:**

1. **Generating function signature**: Need to reconstruct `void func(int a, char *b)` from Symbol's type information
   - Walk `typeModifier` chain to build type string
   - Handle pointers, arrays, function pointers correctly
   - Parameter names might not be available (use `arg1`, `arg2`, etc.)

2. **Finding insertion point in header**: Where to add the declaration?
   - After `#include` directives
   - Before final `#endif` of include guard
   - After existing declarations (maintain some order)

3. **Creating header file**: If `target.h` doesn't exist
   - Generate include guard name from filename (`TARGET_H`)
   - Create basic header structure
   - Or warn user and skip?

4. **Header guard formats**: Different styles exist
   - `#ifndef HEADER_H` / `#define HEADER_H` / `#endif`
   - `#pragma once`
   - Need to detect and handle both

**Value:**
- Automatically makes moved function callable from other files
- Follows C convention of declarations in `.h`, definitions in `.c`
- Much simpler than full dependency analysis
- User still controls `#include` directives (maintains flexibility)

**New code required**: ~150 lines
- Header path derivation: ~20 lines
- Signature generation from Symbol: ~60 lines (complex type reconstruction)
- Header file manipulation: ~50 lines
- Include guard detection/creation: ~20 lines

**Success Criteria**:
1. ✓ When moving function to `target.c`, declaration is added to `target.h`
2. ✓ Function signature is correctly generated (return type, name, parameters)
3. ✓ Declaration is inserted at appropriate location in header
4. ✓ If header doesn't exist, either create it or warn user
5. ✓ Duplicate declarations are avoided (check if already present)
6. ✓ Works with both `#ifndef` guards and `#pragma once`
7. ✓ No regression in Phase 1 functionality

**Acceptable limitations** (defer to Phase 3/4):
- User manually adds `#include` directives to target `.c` file
- May not preserve exact parameter names if not in Symbol
- Basic include guard format if creating new header
- Doesn't remove declaration from old header (user handles manually)

===== Phase 3: Static Helper Functions

**Relative complexity**: 1-1.5× Phase 1

Detect and optionally move tightly-coupled static helpers:

[source,c]
----
static void detectStaticHelpers(EditorMarker *functionStart,
                                 EditorMarker *functionEnd,
                                 Symbol ***helpersOut, int *countOut) {
    SymbolList *helpers = NULL;

    // Find all function calls within the moved function
    parseRegion(functionStart, functionEnd);
    for (Symbol *calledFunc = calledFunctions; calledFunc != NULL;
         calledFunc = calledFunc->next) {
        // Is it static in the same file?
        if (calledFunc->storage == StorageStatic &&
            calledFunc->pos.file == functionStart->buffer->fileNumber) {
            // Add to helpers list
            addSymbol(&helpers, calledFunc);
        }
    }

    *countOut = countList(helpers);
    *helpersOut = listToArray(helpers);
}

// In moveFunction():
if (staticHelperCount > 0) {
    if (promptUser("Move %d static helper function(s) too?", staticHelperCount)) {
        for (int i = 0; i < staticHelperCount; i++) {
            moveFunction(staticHelpers[i]->pos, target);
        }
    }
}
----

**Value:**
- Prevents broken builds from missing static helpers
- Maintains logical cohesion
- Reduces manual follow-up work

===== Phase 4: Polish

**Scope**: Smaller effort, quality-of-life improvements

- Preview dialog showing what will be moved
- Better insertion point heuristics (group with related functions)
- Handle comments and documentation
- Update existing callers if needed

==== Code Locations

===== In c-xref-java (Leverage These)

[cols="1,2,1"]
|===
|Function |Purpose |Line

|`moveStaticObjectAndMakeItPublic`
|Core move logic with reference updating
|2814

|`getMethodLimitsForMoving`
|Find function boundaries using parser
|2908

|`applyExpandShortNames`
|Pattern for dependency analysis (adapt for C)
|2300

|`reduceNamesAndAddImports`
|Pattern for import management (adapt for C)
|2645

|`moveBlockInEditorBuffer`
|Language-agnostic text movement
|Used at 2867

|`getReferences`
|Find all call sites (already works for C)
|Used at 2843

|`changeAccessModifier`
|Change visibility (adapt for static/extern)
|Used at 2868
|===

===== In c-xrefactory (Already Available)

* `EditorMarker` position tracking - `src/editor.h`
* `EditorBuffer` text manipulation - `src/editorbuffer.h`
* Undo/redo infrastructure - `src/editor.c`
* Symbol database lookups - `src/reftab.c`
* Reference tracking - `src/reference.c`

==== Implementation Summary

[cols="1,2"]
||===
||Phase |Value
|
||Phase 1: Basic Move
||**High** - Eliminates manual cut/paste, handles 80% of cases
|
||Phase 2: Include Management
||**High** - Prevents build breakage, major time saver
|
||Phase 3: Static Helpers
||**Medium** - Nice to have, improves completeness
|
||Phase 4: Polish
||**Low** - Quality of life improvements
||===

**Phases 1-2 provide most value**, independently testable
**Leverages existing Java refactoring code**, reduces complexity significantly

==== Benefits

*Developer Productivity*::
- Frequent manual refactoring becomes automated
- Reduces errors from missed dependencies
- Maintains code quality during reorganization

*Code Quality*::
- Correct header management (no missing includes)
- Proper visibility (static vs extern)
- Preserves all references and call sites

*Showcase for c-xrefactory*::
- Demonstrates unique C-specific refactoring capabilities
- Differentiates from generic LSP servers
- Builds on existing Java refactoring experience

==== Risks and Mitigation

[cols="1,1,2"]
|===
|Risk |Likelihood |Mitigation

|Complex header dependencies
|Medium
|Start with simple cases in Phase 1, iterate in Phase 2

|Parser limitations finding function boundaries
|Low
|Already works for extract function refactoring

|Missing static helper detection
|Medium
|Make it optional, user can manually move helpers

|Breaking builds with incorrect includes
|Medium
|Generate preview, allow user to review before applying
|===

==== Success Metrics

* **Phase 1 MVP**: Successfully moves function 90% of cases without build errors
* **Phase 2**: Correctly identifies and adds required headers 80% of time
* **Phase 3**: Detects static helpers with >95% accuracy
* **User adoption**: Refactoring used frequently by active c-xrefactory users

==== Alternatives Considered

*Manual refactoring with editor macros*::
- Fragile, error-prone
- No understanding of code structure
- Can't handle dependencies

*Use generic LSP move/rename*::
- LSP has no "move function" operation
- Would need custom extension
- Doesn't understand C header dependencies

*Wait for Clangd to implement*::
- Clangd has no move function refactoring
- C++-focused, may not handle C idioms well
- We have opportunity to do it first and better

==== References

* Java implementation: `/home/thoni/Utveckling/c-xref-java/src/refactory.c`
* Current extract function: `src/extract.c` (proves function boundary detection works)
* Editor infrastructure: `src/editor.c`, `src/editorbuffer.c`
* Symbol database: `src/reftab.c`, `src/referenceableitemtable.c`

==== Next Steps

1. **After persistence store cleanup**: Take a break from architectural work
2. **Implement Phase 1 MVP**: Smaller effort, high value
3. **Gather usage feedback**: Identify most common dependency patterns
4. **Implement Phase 2**: Based on real-world usage patterns
5. **Document and showcase**: Blog post, video demonstration

---

NOTE: Even Phase 1 MVP provides significant value by eliminating manual text manipulation. The developer who does this refactoring "very often" confirms the high ROI potential.

[[clean-parser-api]]
=== Clean Parser API and Multi-File Definition Support

==== Current State: Recent LSP Definition Finding Success

The recent implementation of `textDocument/definition` for LSP created a **clean, operation-based parser API** in `parsing.h/c` that successfully decouples high-level operations from low-level parsing details. This API discovery presents an opportunity to gradually modernize legacy parsing infrastructure.

**What works**:
* Single-file definition lookup via clean `parsing.h` interface
* Operation-based configuration (ParserOperation enum)
* No reliance on `.cx` files for immediate queries

**What doesn't work yet**:
* Multi-file definitions (symbol defined in different file than reference)
* Cross-file type resolution
* Include graph persistence

==== Problem Statement

The LSP definition finding currently fails when a symbol's **definition is in a different file** from the reference. This requires:

1. **Symbol type information** - Current reference database only stores name and position, not types needed for resolution
2. **Include graph** - Don't know which files include which headers to find definition files
3. **Multi-file parsing** - Ability to efficiently reparse relevant files without loading entire project

More broadly, the legacy codebase still relies on **magic string command routing** to drive parsing behavior:

[source,c]
----
// Scattered throughout codebase (cxref.c, refactory.c, server.c, etc.)
parseBufferUsingServer(project, point, mark, "-olcxpush", NULL);
parseBufferUsingServer(project, point, mark, "-olcxmovetarget", NULL);
parseBufferUsingServer(project, point, mark, "-olcxmodemenu", NULL);
// ... 20+ more magic strings, each with unclear semantics
----

This makes the codebase fragile, hard to understand, and difficult to extend with new operations.

==== The Parser API Innovation

The new `parsing.h` interface provides operation-based configuration (see `src/parsing.h` for details):

**Key innovations**:
* Enum-based operations - Discoverable list (IDE autocomplete shows all options)
* Configuration struct - Single point of setup, no scattered global flags
* Operation predicates - Self-documenting behavior (`needsReferenceAtCursor`, `allowsDuplicateReferences`)
* Type-safe - Compile-time checking replaces runtime magic string matching

==== Benefits of Backporting This API

===== Code Clarity and Safety

Replace magic strings with discoverable enums:

[source,c]
----
/* Before: What does this do? Need to search for documentation */
parseBufferUsingServer(options.project, target, NULL, "-olcxmovetarget", NULL);

/* After: Type-safe and self-documenting via ParserOperation enum */
parsingConfig.operation = PARSE_TO_VALIDATE_MOVE_TARGET;
parsingConfig.positionOfSelectedReference = makePositionFromMarker(target);
parseCurrentInputFile(LANG_C);
----

Replace scattered global flags with structured configuration:

[source,c]
----
/* Before: Scattered throughout, unclear semantics */
options.olcxPushButton = 1;
options.olcxRenameOption = 1;
s_noParametersToExpand = 0;
originalFileNumber = someValue;

/* After: All configuration in one place, clear purpose */
parsingConfig.operation = PARSE_TO_COMPLETE;
parsingConfig.targetParameterIndex = 5;
parsingConfig.extractMode = EXTRACT_VARIABLE;
----

===== Foundation for Multi-File Definition Lookup

The clean API makes it easier to implement required enhancements:

[source,c]
----
/* New operation for multi-file definition lookup */
typedef enum {
    /* ... existing operations ... */
    PARSE_TO_RESOLVE_DEFINITION,  /* NEW: Find definition across files */
} ParserOperation;

/* Simpler to add new parsing modes when API is clean */
parsingConfig.operation = PARSE_TO_RESOLVE_DEFINITION;
parsingConfig.symbolName = "findReferenceableAt";
parsingConfig.startFile = fileNumber;
----

===== Easier Feature Development

Adding new operations becomes straightforward:

1. Add to `ParserOperation` enum
2. Implement predicate functions if needed
3. Add semantic actions in grammar
4. Done - no magic strings to maintain

==== Implementation Plan: Three Non-Blocking Phases

===== Phase 1: Expose New API Alongside Legacy Code

**Scope**: Purely additive - new API works alongside legacy code
**Risk**: LOW (no changes to existing code paths)
**Value**: Proof of concept, enables gradual migration

**Approach**:
1. `parseWithConfig()` becomes primary entry point
2. `parseBufferUsingServer()` internally bridges legacy magic strings to new `ParsingConfig`
3. Both code paths work identically (verified with tests)
4. No changes needed to existing functionality

**Benefit**: Can merge this without affecting legacy code at all

===== Phase 2: Migrate High-Value Callsites

**Scope**: Refactor 50%+ of parsing infrastructure
**Risk**: MEDIUM (refactoring, but with tests)
**Value**: Significant improvement to codebase clarity

**Priority callsites**:
1. LSP handlers - Already partially using new API
2. Definition finding - Multi-file lookup
3. Extract refactoring - Complex logic, multiple operations
4. Move function - Multiple parsing passes

**Benefit**: 50%+ of parsing infrastructure modernized, multi-file definitions enabled

===== Phase 3: Complete Legacy Code Cleanup

**Scope**: Remove all magic string command routing, consolidate parsing
**Risk**: MEDIUM (larger refactoring)
**Value**: Long-term maintainability and extensibility

**Scope**:
* Remove all magic string command routing
* Consolidate parsing entry points
* Eliminate scattered global flags
* Document parser behavior in code

**Benefit**: Codebase future-proof for new operations

**Important**: Phase 3 is **optional** - Phases 1-2 already provide most value

==== Multi-File Definition: Requirements

===== 1. Symbol Type Information Persistence

**Current**: ReferenceableItemTable only stores name, position, kind
**Needed**: Minimal type info for cross-file resolution

**Lightweight approach** (preferred over full type serialization):

[source,c]
----
/* Extend ReferenceableItem with minimal type data */
struct ReferenceableItem {
    /* ... existing fields ... */
    char *returnType;      /* For functions: return type string */
    int   parameterCount;  /* For functions: number of parameters */
    bool  isDefinition;    /* True if this is the function/variable definition */
};
----

**Scope**: Extend ReferenceableItem, careful memory management

===== 2. Include Graph Construction

**Current**: Include relationships processed during lexing, not persisted
**Needed**: Map of which files include which headers

**Lightweight approach**:

[source,c]
----
typedef struct {
    int   sourceFile;         /* File with #include directive */
    int   includedFile;       /* File being included */
    bool  isSystemInclude;    /* <> vs \"\" */
} IncludeEdge;

/* Stored in file's metadata, retrievable by file number */
int getIncludedFileCount(int fileNumber);
int getIncludedFile(int fileNumber, int index);
int *getIncludingFiles(int fileNumber);  /* Files that include this one */
----

**Scope**: Moderate effort, moderate complexity

===== 3. Incremental Multi-File Parsing

**Current**: Full project parse or single-file parse
**Needed**: Efficient "parse files needed for definition lookup" operation

**Approach**:
1. Use include graph to find "definition file candidates"
2. Parse only those files (typically 1-5 for most projects)
3. Store symbols in special "definition lookup" arena
4. Return to in-memory reference table when done

**Scope**: Parse relevant files, update reference table

**Total for full multi-file support**: Larger foundational work combining above three components

==== Code Locations

**New Parser API**:
* `src/parsing.h` - Public interface (167 lines)
* `src/parsing.c` - Implementation with bridges (187 lines)
* Functions: `getParserOperation()`, `needsReferenceAtCursor()`, `parseToCreateReferences()`

**Legacy code currently using magic strings**:
* `src/cxref.c` - 20+ `parseBufferUsingServer()` calls
* `src/refactory.c` - 10+ operations
* `src/extract.c` - Multiple parsing passes
* `src/complete.c` - Completion-specific parsing
* `src/server.c` - Operation dispatch

**Files for multi-file support**:
* `src/reference_database.h/c` - Add symbol type info
* `src/yylex.c` - Build include graph
* `src/filetable.h/c` - Persist include relationships

==== Success Metrics

**Phase 1**:
* ✓ New `ParsingConfig` API works alongside legacy strings
* ✓ No performance regression
* ✓ Both code paths tested and working

**Phase 2**:
* ✓ 50%+ of parsing callsites use new API
* ✓ Multi-file definition lookup works
* ✓ All existing tests still pass

**Phase 3** (if pursued):
* ✓ All parsing driven by enum operations
* ✓ Magic strings completely removed
* ✓ New developers understand control flow

==== Risks and Mitigation

[cols="1,1,2"]
|===
|Risk |Likelihood |Mitigation

|Breaking existing workflows
|Medium
|Phase 1 keeps old API working, extensive testing, clear migration timeline

|Incomplete refactoring
|Medium
|Phase 1-2 provide value even if Phase 3 never completes

|Performance regression
|Low
|New API does same work, just different control flow; profile before/after

|Memory overhead from type info
|Medium
|Use lightweight approach, store only essential fields, consider lazy loading
|===

==== Related Work

This refactoring supports:
* **ADR-0014** (On-Demand Parsing) - Single code path for all operations
* **Unified Symbol Database** (next major refactoring) - Requires clean parsing API
* **LSP Multi-File Support** - Immediately enables cross-file definition lookup

==== Notes

The key insight is that we can **backport this gradually without breaking anything**. The bridge pattern (new API calls old code for now) lets us improve incrementally, retiring magic strings and globals one section at a time.

Phase 1 proves the approach works with minimal risk. Phases 2-3 build on proven foundation, so failure to complete them doesn't harm existing functionality.

Multi-file definitions are one motivating use case, but the real long-term benefit is a codebase where parsing behavior is **discoverable and type-safe** instead of driven by magic strings scattered throughout 25-year-old code.
