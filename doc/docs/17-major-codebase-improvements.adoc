== Major Codebase Improvements

This chapter documents internal architectural changes and technical debt reduction efforts that improve code quality, maintainability, and performance. These are improvements to c-xrefactory's own implementation, not features users interact with directly.

For planned user-facing features, see link:16-planned-features.adoc[Chapter 16: Planned Features].

=== Clean Persistence Store Abstraction

==== Problem Statement

The `cxfile` module currently mixes multiple responsibilities that should be separated:

* **Persistence implementation** (reading/writing .cx files) ✓ Correct level
* **Search and filter operations** (matching search strings) ✗ Wrong level
* **Operation-specific loading** (menu creation, macro completion, unused detection) ✗ Too specific
* **Treated as source of truth** (when it should be just a startup snapshot) ✗ Architectural confusion

This mixing creates tight coupling, makes testing difficult, and prevents future architectural improvements (like LSP integration or alternative storage backends).

==== Architectural Confusion: In-Memory vs Persistence

The current code conflates two distinct concepts:

*Reference Database* (Smart Layer - Source of Truth)::

- **Always in-memory**: The `referenceableItemTable` hash table
- Answers queries fast from RAM
- Decides when to load from persistence
- Decides when to save to persistence
- Manages invalidation and staleness
- **This is the actual database**

*Persistence Store* (Dumb Layer - Startup Snapshot)::

- **Always on disk**: The `.cx` files (or future SQLite, etc.)
- Just knows how to save/load a specific format
- Has NO in-memory state of its own
- No business logic, no searching, no filtering
- **This is just the storage mechanism**
- Only consulted at startup; never read during normal operation

IMPORTANT: The persistence layer stores a **startup snapshot** of disk-file-derived references. It exists to avoid a full project parse on server start. See link:15-roadmap.adoc[Chapter 15: Roadmap] for the target snapshot semantics.

==== Current Architecture Problems

**Mixed Abstraction Levels**

The current `cxfile.h` public interface exposes:

[source,c]
----
// Operation-specific scanning (too high-level for storage)
extern void scanReferencesToCreateMenu(char *symbolName);
extern void scanForMacroUsage(char *symbolName);
extern void scanForGlobalUnused(char *cxrefFileName);
extern void scanForSearch(char *cxrefFileName);

// Implementation details leaked (partitioning is internal)
extern int cxFileHashNumberForSymbol(char *symbol);
extern void searchSymbolCheckReference(ReferenceableItem *item, Reference *ref);

// Generic API (already identified as "Abstract API")
extern bool loadFileNumbersFromStore(void);
extern void ensureReferencesAreLoadedFor(char *symbolName);
extern void saveReferencesToStore(bool updating, char *name);
----

Problems:

* **Four `scan*` functions**: Encode specific use cases (menu, macro, unused, search) instead of providing generic operations
* **Implementation details exposed**: `cxFileHashNumberForSymbol()` is a partitioning optimization that shouldn't be public
* **Search logic in storage**: `searchSymbolCheckReference()` mixes filtering with persistence
* **Side-effect heavy**: All functions mutate global `referenceableItemTable` implicitly

*_Tight Coupling to Use Cases_*

Currently `cxfile.c` knows about:

* Browser menus (`scanReferencesToCreateMenu`)
* Macro completion (`scanForMacroUsage`)
* Unused symbol detection (`scanForGlobalUnused`)
* Symbol search (`scanForSearch`)

A persistence layer shouldn't know about any of these! These are *clients* of storage, not responsibilities of storage.

*_Wrong Source of Truth_*

From the navigation debugging (see Insights chapter), we discovered:

[source,c]
----
// In cxref.c - loads FROM DISK directly
scanReferencesToCreateMenu(symbolName);  // Treats .cx files as truth
----

This bypasses the in-memory `referenceableItemTable`, treating disk as authoritative. But the **actual truth** is:

----
referenceableItemTable = Disk state (.cx files) + Preloaded editor buffers
----

The disk is just a **cache** of the last saved state, not the current truth.

==== Proposed Architecture

*_Two-Layer Design_*

[source]
----
┌──────────────────────────────────────────────────┐
│  Reference Database (Smart Layer)                │
│  Source of Truth: referenceableItemTable (RAM)   │
│                                                  │
│  - Fast in-memory queries                        │
│  - Knows what's current vs stale                 │
│  - Handles invalidation/refresh                  │
│  - Decides when to load/save                     │
│  - Unified interface for all clients             │
└──────────────────────────────────────────────────┘
                      ↓
        (only when loading/saving needed)
                      ↓
┌──────────────────────────────────────────────────┐
│  Persistence Store (Dumb Layer)                  │
│  Startup snapshot: .cx files on disk              │
│                                                  │
│  - Just save/load binary format                  │
│  - No business logic                             │
│  - No in-memory state                            │
│  - Can be swapped (SQLite, Protobuf, etc.)       │
└──────────────────────────────────────────────────┘
----

*_Clean Persistence Store Interface_*

[source,c]
----
// persistence_store.h - Pure storage operations
#ifndef PERSISTENCE_STORE_H_INCLUDED
#define PERSISTENCE_STORE_H_INCLUDED

#include "referenceableitem.h"

/* ============================================
 * Store Lifecycle
 * ============================================ */

// Load metadata (file numbers, timestamps)
extern bool persistenceLoadMetadata(void);

// Persist all references to durable storage
extern void persistenceSaveAll(bool updating, char *location);

/* ============================================
 * Reference Loading (into referenceableItemTable)
 * ============================================ */

// Load references for specific symbol into memory table
// Returns true if symbol found in storage
extern bool persistenceLoadSymbol(char *symbolName);

/* ============================================
 * Bulk Scanning
 * ============================================ */

// Scan entire storage, calling visitor for each reference
// Visitor decides what to do with each reference
typedef void (*PersistenceVisitor)(ReferenceableItem *item,
                                    Reference *ref,
                                    void *context);
extern void persistenceScanAll(PersistenceVisitor visitor, void *context);

#endif
----

*_Reference Database Interface_*

This layer provides the "smart" operations that clients actually need:

[source,c]
----
// reference_database.h - Smart operations (initially thin wrapper)
#ifndef REFERENCE_DATABASE_H_INCLUDED
#define REFERENCE_DATABASE_H_INCLUDED

#include "referenceableitem.h"
#include "position.h"

// Initialize the in-memory reference database
extern bool refDbInitialize(void);

// Lookup symbol in the in-memory table
// Automatically loads from persistence if not in memory
extern ReferenceableItem* refDbLookupSymbol(char *name);

// Get all references for a symbol
// Ensures data is loaded and current
extern Reference* refDbGetReferences(char *symbolName);

// Mark a file's references as stale (needs reload)
extern void refDbInvalidateFile(int fileNumber);

// Persist the current in-memory state
extern void refDbSave(bool updating, char *location);

#endif
----

NOTE: This interface starts simple but is where the *Unified Symbol Database* refactoring (next section) will add smart on-demand loading, dependency tracking, and invalidation logic.

==== Migration Strategy

*_Phase 1: Create Clean Boundaries (No Behavior Change)_*

. Rename `cxfile.h` → `cxfile_internal.h` (implementation detail)
. Create `persistence_store.h` with clean interface
. Create `persistence_store.c` that delegates to `cxfile_*` functions
. Update all callers to use `persistence_store.h` instead of `cxfile.h`

Result: Same behavior, cleaner names, clear intent.

*_Phase 2: Extract Operation Logic_*

Move operation-specific logic OUT of persistence layer:

*Search Logic*:: `searchSymbolCheckReference()` → new `search.c` module
+
[source,c]
----
// Before: In cxfile.c (WRONG LEVEL)
void searchSymbolCheckReference(ReferenceableItem *item, Reference *ref) {
    if (searchStringMatch(...)) {
        reportMatch(item, ref);
    }
}

// After: In search.c (RIGHT LEVEL)
void searchForSymbol(char *pattern) {
    persistenceScanAll(checkSearchMatch, pattern);
}

static void checkSearchMatch(ReferenceableItem *item, Reference *ref, void *ctx) {
    if (searchStringMatch(item->linkName, (char *)ctx)) {
        reportMatch(item, ref);
    }
}
----

*Unused Detection*:: Extract from `cxfile.c` to `refactorings.c` or new `analysis.c`

*Menu Creation*:: Keep in `cxref.c` but use clean `refDbGetReferences()` instead of direct disk scanning

*_Phase 3: Hide Implementation Details_*

Make these functions `static` (internal to cxfile.c):

* `cxFileHashNumberForSymbol()` - partitioning is implementation detail
* `searchSymbolCheckReference()` - moved to search module
* All internal scanning logic

*_Phase 4: Consolidate Scanning Functions_*

Replace four specific scanners with generic visitor pattern:

[cols="1,1"]
|===
|Old (Use-Case Specific) |New (Generic)

|`scanReferencesToCreateMenu(name)`
|`refDbGetReferences(name)`

|`scanForMacroUsage(name)`
|`refDbGetReferences(name)`

|`scanForGlobalUnused(location)`
|`persistenceScanAll(checkUnused, ctx)`

|`scanForSearch(location)`
|`persistenceScanAll(checkMatch, pattern)`
|===

==== Benefits

*Testability*:: Can mock `persistence_store.h` for testing navigation without .cx files
+
*Future Storage Backends*:: Could implement with SQLite, in-memory testing mock, or different binary format
+
*Clear Boundaries*:: Storage vs search vs navigation clearly separated
+
*Simpler Interface*:: 4 functions instead of 9, clearer responsibilities
+
*Less Coupling*:: Parsing code doesn't call storage directly, goes through reference database
+
*LSP Readiness*:: Reference database layer is where LSP `textDocument/didChange` integration will live

==== Relationship to Unified Symbol Database

This refactoring is the **foundation** for the larger *Unified Symbol Database Architecture* (next section):

* **Clean persistence layer** enables swapping storage backends without affecting clients
* **Reference database layer** is where smart on-demand loading logic will live
* **Separation of concerns** makes the unified architecture clearer

Migration path:

. First: Clean up persistence (this refactoring)
. Then: Add smart on-demand logic to reference database (next refactoring)
. Finally: Both Emacs and LSP use same unified code path

==== Implementation Checklist

- [ ] Create `persistence_store.h` with proposed interface
- [ ] Create `persistence_store.c` delegating to cxfile
- [ ] Rename `cxfile.h` → `cxfile_internal.h`
- [ ] Create `reference_database.h` (thin wrapper initially)
- [ ] Create `reference_database.c` delegating to persistence
- [ ] Update all callers to use new interfaces
- [ ] Move search logic from cxfile to search module
- [ ] Move unused detection logic to appropriate module
- [ ] Make `cxFileHashNumberForSymbol` static
- [ ] Make `searchSymbolCheckReference` static or remove
- [ ] Add unit tests for both interfaces
- [ ] Update documentation

==== References

* Current implementation: `src/cxfile.c`, `src/cxfile.h`
* In-memory table: `src/reftab.c` (referenceableItemTable)
* Navigation architecture: Chapter 17 (Insights) - Navigation Architecture section

[[unified-symbol-database]]
=== Unified Symbol Database Architecture

NOTE: This section describes the implementation details for the "Memory as Truth" architectural vision. See link:15-roadmap.adoc[Chapter 15: Roadmap] for the high-level dependency chain showing how this work relates to other architectural goals.

==== Problem Statement

The current symbol database has evolved from a batch cross-referencer (like `ctags`) with artificial distinctions between "file-based" and "on-demand" modes. This creates:

* **Mode complexity**: Different code paths for Emacs vs LSP clients
* **Cold start problems**: Requires upfront `-create` operation before use
* **Manual updates**: Users must remember to run `-update` after changes
* **Inconsistent behavior**: Different modes provide different guarantees
* **Maintenance overhead**: Multiple implementations to maintain and test

==== Current Architecture Limitations

The existing system distinguishes between:

[cols="1,1,1"]
|===
|Aspect |File-Based Mode |On-Demand Mode

|**Cold Start**
|Requires `-create` first
|Parse file immediately

|**Warm Queries**
|O(1) hash lookup
|O(file_size) parsing

|**Memory Usage**
|Low (streaming)
|High (in-memory cache)

|**Incremental Updates**
|Smart file tracking
|Per-file invalidation

|**Multi-project**
|Separate databases
|Workspace-scoped
|===

==== Proposed Solution

*_Core Insight: Unified On-Demand Architecture_*

Both Emacs and LSP clients want the same thing: **up-to-date symbol and reference information**. The distinction between "file-based" and "on-demand" modes is artificial complexity. Instead, c-xrefactory should provide a unified interface that:

1. **Always ensures information is current** using existing dependency tracking
2. **Scans incrementally** only what's needed, when needed  
3. **Uses `.cx` files as startup snapshot** for fast server start
4. **Eliminates cold start problems** by avoiding upfront full-project scanning

*_Simplified Interface Design_*

[source,c]
----
typedef struct SymbolDatabase SymbolDatabase;

typedef struct {
    // Unified operations for any client (Emacs or LSP)
    Symbol* (*lookupSymbol)(SymbolDatabase* db, const char* name, Position pos);
    ReferenceList* (*getReferences)(SymbolDatabase* db, const char* name, Position pos);
    ReferenceList* (*getOccurrences)(SymbolDatabase* db, const char* name, Position pos);
    
    // All complexity hidden in implementation:
    // - File modification checking (existing: checkFileModifiedTime)
    // - Include dependency tracking (existing: cachedIncludedFilePass) 
    // - Incremental scanning (existing: makeIncludeClosureOfFilesToUpdate)
    // - Persistent caching (existing: .cx file system)
} SymbolDatabaseOperations;
----

*_Implementation Strategy: Smart On-Demand_*

IMPORTANT: This refactoring builds on the *Clean Persistence Store* foundation (previous section). The smart logic lives in the **in-memory reference database layer**, while `.cx` files become a startup snapshot (see link:15-roadmap.adoc[Chapter 15: Roadmap] for the architectural vision and dependency chain).

The implementation leverages **existing sophisticated logic**:

[source,c]
----
Symbol* lookupSymbol(const char* name, Position pos) {
    // 1. Check if in-memory table has current information
    if (refTableHasCurrent(name, pos)) {
        return lookupInMemoryTable(name, pos);  // Answer from RAM
    }

    // 2. Load from persistence if not in memory
    if (!refTableHasSymbol(name)) {
        persistenceLoadSymbol(name);  // Load .cx into referenceableItemTable
    }

    // 3. Check if loaded data is stale (file modified since load)
    if (refTableDataIsStale(name, pos)) {
        // Use existing dependency tracking to scan minimal set
        FileList* filesToScan = calculateDependencyClosure(pos.file);
        for (FileItem* file : filesToScan) {
            if (checkFileModifiedTime(file->fileNumber)) {
                parseFileAndUpdateTable(file);  // Reparse into memory
            }
        }
    }

    // 4. Answer from in-memory table (now guaranteed current)
    return lookupInMemoryTable(name, pos);
}
----

**Architectural Layers:**

----
Query → Reference Database (in-memory, smart) → Persistence Store (disk, dumb)
        ↑                                         ↑
        Always answers from RAM                   Only for load/save
----

**Key Benefits:**

* **No artificial modes** - same code path for all clients
* **No cold start** - first lookup triggers minimal necessary scanning
* **Incremental by design** - only scans files that need updating
* **In-memory speed** - all queries answered from RAM (referenceableItemTable)
* **Startup snapshot** - `.cx` files avoid full project parse on restart
* **Existing logic reuse** - leverages proven dependency tracking system

[[snapshot-loading]]
*_Startup Snapshot Loading_*

At startup, the `.cx` snapshot is used to populate the in-memory table without a full project parse. The algorithm for each file entry in the snapshot:

[source]
----
For file F in snapshot:

1. Does stored lastParsedMtime match current disk mtime?
   NO  → Snapshot is stale for F. Re-parse from disk.
   YES → Use snapshot references for F.
----

After startup, the client connects and sends preloaded buffers for modified files. Those are parsed into memory, overriding any snapshot-loaded references for those files.

During normal operation, the `.cx` file is never consulted. All queries are answered from the in-memory table.

**Cold start** (no `.cx` file): All project source files are parsed. Slower but self-healing — no manual action needed.

**Snapshot persistence constraint**: Only disk-file-derived references are written to the snapshot. References parsed from preloaded editor buffers (unsaved content) are never persisted, so that mtime-based validation at next startup remains correct.

See link:15-roadmap.adoc[Chapter 15: Roadmap] for the full startup snapshot semantics.

*_Legacy Architecture Recognition_*

c-xrefactory evolved from a **batch cross-referencer** (like `ctags`) and was enhanced for real-time use:

[source,bash]
----
# Legacy batch workflow:
c-xref -create project.c     # Full scan, build .cx database
c-xref -update modified.c    # Incremental update
c-xref -olcxpush symbol      # Query pre-built database

# Unified approach:
c-xref -server               # Start server, scan on-demand as needed
c-xref -lsp                  # Same logic, different protocol
----

IMPORTANT: With this architecture, the `.cx` files become a **startup snapshot** of the in-memory `referenceableItemTable`. They exist to avoid a full project parse on server start. The actual database is always in RAM, and `.cx` is not consulted during normal operation.

==== Implementation Plan

*_Phase 1: Interface Unification_*

* Create unified `SymbolDatabase` interface
* Wrap existing logic in smart on-demand implementation
* Replace explicit `-create`/`-update` commands with automatic dependency checking
* Both Emacs and LSP use same code path

*_Phase 2: Optimization_*

* Enhance existing dependency tracking for finer-grained invalidation
* Optimize in-memory caching strategies
* Background `.cx` file maintenance for long-running sessions
* Performance tuning for large codebases

==== Benefits

*_Architectural Simplification_*

* **Single code path** for both Emacs and LSP clients - eliminates maintenance overhead
* **No mode distinctions** - same smart logic serves all use cases optimally
* **Leverages existing logic** - reuses proven dependency tracking and caching systems
* **Reduced complexity** - eliminates artificial FILE_BASED/ON_DEMAND/HYBRID modes

*_User Experience Improvements_*

* **Zero configuration** - works immediately on any C project without setup
* **No cold start delay** - first symbol lookup triggers minimal necessary scanning
* **Transparent snapshots** - `.cx` files automatically maintained for fast startup
* **Consistent behavior** - same results whether using Emacs or modern IDE with LSP

*_Performance Characteristics_*

* **Minimal initial cost** - avoids expensive upfront full-project scanning
* **Smart incremental updates** - only rescans files that have actually changed
* **Automatic dependency tracking** - includes files affected by changes get updated
* **Fast restart** - analysis results snapshotted across sessions

*_Development Benefits_*

* **Backward compatibility** - existing Emacs workflows continue unchanged
* **Forward compatibility** - natural path to modern LSP integration
* **Reduced maintenance** - single implementation instead of multiple modes
* **Enhanced testability** - unified logic easier to test comprehensively

==== Existing Infrastructure

*_Sophisticated Dependency Tracking_*

The unified approach leverages c-xrefactory's **existing sophisticated dependency management** that handles include file relationships automatically:

**File Modification Tracking** (`filetable.h`):

[source,c]
----
typedef struct fileItem {
    char *name;
    time_t lastModified;        // Last known modification time
    time_t lastInspected;       // Last time we checked
    time_t lastUpdateMtime;     // Last update cycle time  
    time_t lastFullUpdateMtime; // Last full update time
    // ... scheduling and state flags
} FileItem;

bool checkFileModifiedTime(int fileNumber);
----

**Include Dependency Tracking** (`yylex.c`):

[source,c]
----
void pushInclude(FILE *file, EditorBuffer *buffer, char *name, char *prepend) {
    // ... setup include stack
    includeStack.stack[includeStack.pointer++] = currentFile;
    // Track include relationships for dependency analysis
}
----

**Automatic Include Closure** (`xref.c:81-108`):

[source,c]
----
static void makeIncludeClosureOfFilesToUpdate(void) {
    // If file A includes file B, and B is modified, A gets scheduled for update
    // This uses the reference database to track include relationships
    bool fileAddedFlag = true;
    while (fileAddedFlag) {
        // Iterative closure: keeps adding dependent files until stable
        for (all scheduled files) {
            find_all_files_that_include_this_file();
            schedule_them_for_update();
        }
    }
}
----

IMPORTANT: This dependency tracking infrastructure is **already production-ready** and handles the complex cases (transitive dependencies, modification time checking, include stack management). The unified symbol database can leverage this existing logic instead of reimplementing dependency management.

*_Refactoring Without callXref()_*

The current architecture has RefactoryMode internally calling XrefMode (`callXref()`) to update the persistent `.cx` database before performing refactorings (see Insights chapter, section "RefactoryMode Internally Calls XrefMode").

With the unified on-demand architecture, refactoring uses the **same in-memory reference database** as navigation:

[source,c]
----
void performRefactoring(Symbol *symbol) {
    // 1. Find files where symbol is referenced (from in-memory refs)
    FileList *referencingFiles = getFilesWithReferencesTo(symbol->name);

    // 2. Compute include closure of those files
    //    Uses existing makeIncludeClosureOfFilesToUpdate() infrastructure
    FileList *potentialReferences = computeIncludeClosure(referencingFiles);

    // 3. Filter to only stale files (mtime > lastParsedMtime)
    for (FileItem *f : potentialReferences) {
        if (f->lastModified > f->lastParsedMtime) {
            parseFileIntoMemory(f);  // Uses preload if available
        }
    }
    // Files already parsed with current content are NOT reparsed

    // 4. Perform refactoring using in-memory references
    // Same reference list used by navigation is now used by refactoring
    applyRefactoring(symbol, potentialReferences);
}
----

**Key simplification**: By limiting support to "include file patterns" only (see link:/workspace/decisions#13[ADR-0013]), we don't need to scan the entire project for archaic `extern` declarations in `.c` files. The include graph provides a complete and correct dependency closure.

**Benefits:**

* **Single code path** - Navigation and refactoring use the same reference database
* **No xref subprocess** - Eliminates process isolation complexity
* **Preloads work correctly** - Modified editor buffers are used directly
* **Faster refactoring** - Only stale files are reparsed, not entire project

==== Open Questions

. Should we maintain backward compatibility with explicit `-create`/`-update` commands?
** Probably yes, at least as no-ops or aliases to make transition easier

. How to handle very large projects (>1M LOC)?
** May need workspace-level configuration for incremental scanning thresholds
** Consider lazy loading of symbol data

. What's the migration path for existing users?
** Existing `.cx` files should continue to work
** Auto-migrate on first run with new version
** Provide clear documentation on new behavior

==== References

* Current implementation: `src/cxfile.c`, `src/xref.c`
* File tracking: `src/filetable.h`, `src/filetable.c`
* Dependency tracking: `src/xref.c` lines 81-108
* Current database description: See chapter 08 (Code) - Reference Database section

[[macro-expansion-module]]
=== Extract Macro Expansion Module

==== Problem Statement

The `yylex.c` file is **2353 lines** and combines multiple responsibilities:

* Lexical analysis and token reading
* File and buffer management
* Preprocessor directive processing
* **Macro expansion system** (~800 lines)

The macro expansion code is a substantial, cohesive subsystem that would benefit from extraction into its own module. Currently, it's deeply embedded in yylex.c, making both lexing and macro expansion harder to understand and test in isolation.

==== Current Architecture

The macro expansion system in `yylex.c` comprises:

*_Core Responsibilities (~800 lines)_*

* **Macro call expansion** - Main orchestration (`expandMacroCall()`)
* **Argument processing** - Collection and recursive expansion
* **Token collation** - `##` operator implementation
* **Stringification** - `#` operator implementation
* **Memory management** - Separate arenas for macro bodies (MBM) and arguments (PPM)
* **Cyclic detection** - Preventing infinite macro recursion

*_Key State_*

[source,c]
----
int macroStackIndex;  // Current macro expansion depth
static LexemStream macroInputStack[MACRO_INPUT_STACK_SIZE];
static Memory macroBodyMemory;      // Long-lived: macro definitions
static Memory macroArgumentsMemory; // Short-lived: expansion temporaries
----

*_Memory Lifetime Separation_*

The system uses **two distinct memory arenas** with different lifetimes:

* **MBM (Macro Body Memory)**: Persistent storage for macro definitions throughout compilation
* **PPM (PreProcessor Memory)**: Temporary storage for expansion, collation, and argument processing

This separation is fundamental and should be preserved in any refactoring.

==== Proposed Solution

Extract macro expansion into a new module: `macroexpansion.c/h`

*_Public Interface_*

The new module would expose a minimal, focused API:

[source,c]
----
// Initialization
void initMacroExpansion(void);
int getMacroBodyMemoryIndex(void);
void setMacroBodyMemoryIndex(int index);

// Core expansion
bool expandMacroCall(Symbol *macroSymbol, Position position);
bool insideMacro(void);
int getMacroStackDepth(void);

// Memory allocation (exposed for macro definition processing)
void *macroBodyAlloc(size_t size);
void *macroBodyRealloc(void *ptr, size_t oldSize, size_t newSize);
void *macroArgumentAlloc(size_t size);
----

*_Module Boundaries_*

*What moves to macroexpansion.c:*

* Macro call expansion and argument processing
* Token collation (`collate()` and helpers)
* Stringification (`macroArgumentsToString()`)
* Cyclic call detection
* MBM/PPM memory management
* Buffer expansion utilities (`expandPreprocessorBufferIfOverflow()`, etc.)

*What remains in yylex.c:*

* Lexing and file input
* Preprocessor directive processing (`#define`, `#ifdef`, etc.)
* Include file handling
* Main `yylex()` function
* Macro symbol table operations

*Dependencies:*

The macro module would depend on:

* Lexem stream operations (reading/writing)
* Symbol lookup (`findMacroSymbol()`)
* Cross-referencing (for collation and expansion references)
* Current input state (via accessor functions)

==== Benefits

*_Architectural_*

* **Separation of concerns**: Lexing vs. preprocessing clearly separated
* **Reduced file size**: yylex.c drops from 2353 → ~1550 lines (34% reduction)
* **Testability**: Macro expansion can be unit tested independently
* **Clearer ownership**: Macro state and memory management centralized

*_Maintainability_*

* **Focused modules**: Each file has a single, clear purpose
* **Easier reasoning**: Macro behavior isolated from lexer concerns
* **Better documentation**: Module-level documentation for macro system

*_Future flexibility_*

* Could support different macro systems (C vs. C++)
* Easier to add macro debugging/tracing
* Independent optimization of macro expansion

==== Implementation Strategy

*_Phase 1: Preparation (Already Complete)_*

✓ Create `LexemBufferDescriptor` type for buffer management +
✓ Refactor buffer expansion functions to use descriptor +
✓ Eliminate return values for size updates

*_Phase 2: Create Module Structure_*

* Create `macroexpansion.h` with public interface
* Create `macroexpansion.c` with initial implementations
* Move `LexemBufferDescriptor` to appropriate header
* Create accessor functions for `currentInput` state

*_Phase 3: Incremental Function Migration_*

Move functions in this order (lowest risk first):

1. **Memory management** - MBM/PPM allocation functions
2. **Buffer expansion** - `expandPreprocessorBufferIfOverflow()`, `expandMacroBodyBufferIfOverflow()`
3. **Support utilities** - `cyclicCall()`, `prependMacroInput()`
4. **Token processing** - `collate()`, `resolveMacroArgument()`, etc.
5. **Core expansion** - `expandMacroCall()`, `createMacroBodyAsNewStream()`, etc.

*_Phase 4: Integration and Cleanup_*

* Update yylex.c to use new interface
* Run full test suite after each migration step
* Add focused unit tests for macro expansion
* Update build system
* Document the new architecture

==== Risks and Mitigation

*_Risk: Complex dependencies_*

*Mitigation:*

* Create clear accessor functions for shared state
* Use incremental approach - one function group at a time
* Validate with tests after each step

*_Risk: Performance overhead_*

*Mitigation:*

* Keep critical functions inline where necessary
* Profile before/after migration
* Current code already has abstraction layers

*Assessment:* Low risk - macro operations are complex enough that function call overhead is negligible

*_Risk: Breaking existing tests_*

*Mitigation:*

* Run test suite after every migration step
* Keep interface behavior identical
* Use compiler to catch interface mismatches

==== Success Metrics

* All existing tests pass
* yylex.c reduced to ~1550 lines
* New focused tests for macro expansion added
* No performance regression (< 5% overhead acceptable)
* Code review confirms improved clarity

==== Open Questions

. Should `findMacroSymbol()` move to the macro module or stay in yylex.c?
** It's used by both lexer (for expansion triggering) and macro module (for nested expansions)
** Probably belongs in a shared location or as part of symbol table operations

. How to handle `currentInput` global state?
** Options: Pass explicitly, use accessor functions, or provide context structure
** Accessor functions likely cleanest: `getCurrentInput()`, `setCurrentInput()`

. Should we extract preprocessor directives at the same time?
** No - keep changes focused
** Could be a future refactoring after macro extraction proves successful

==== References

* Current code: `src/yylex.c` lines 1327-2089 (macro expansion system)
* Memory management: `src/memory.h`, `src/memory.c`
* Symbol operations: `src/symbol.h`
* Related refactoring: <<LexemStream API Improvements>> addresses buffer management patterns

---

NOTE: This refactoring is independent of the LexemStream API improvements but would benefit from them being completed first, as they simplify buffer management patterns throughout the macro expansion code.


[[clean-parser-api]]
=== Clean Parser API and Multi-File Definition Support

==== Current State: Recent LSP Definition Finding Success

The recent implementation of `textDocument/definition` for LSP created a **clean, operation-based parser API** in `parsing.h/c` that successfully decouples high-level operations from low-level parsing details. This API discovery presents an opportunity to gradually modernize legacy parsing infrastructure.

**What works**:

* Single-file definition lookup via clean `parsing.h` interface
* Operation-based configuration (ParserOperation enum)
* No reliance on `.cx` files for immediate queries

**What doesn't work yet**:

* Multi-file definitions (symbol defined in different file than reference)
* Cross-file type resolution
* Include graph persistence

==== Problem Statement

The LSP definition finding currently fails when a symbol's **definition is in a different file** from the reference. This requires:

1. **Symbol type information** - Current reference database only stores name and position, not types needed for resolution
2. **Include graph** - Don't know which files include which headers to find definition files
3. **Multi-file parsing** - Ability to efficiently reparse relevant files without loading entire project

More broadly, the legacy codebase still relies on **magic string command routing** to drive parsing behavior:

[source,c]
----
// Scattered throughout codebase (cxref.c, refactory.c, server.c, etc.)
parseBufferUsingServer(project, point, mark, "-olcxpush", NULL);
parseBufferUsingServer(project, point, mark, "-olcxmovetarget", NULL);
parseBufferUsingServer(project, point, mark, "-olcxmodemenu", NULL);
// ... 20+ more magic strings, each with unclear semantics
----

This makes the codebase fragile, hard to understand, and difficult to extend with new operations.

==== The Parser API Innovation

The new `parsing.h` interface provides operation-based configuration (see `src/parsing.h` for details):

**Key innovations**:
* Enum-based operations - Discoverable list (IDE autocomplete shows all options)
* Configuration struct - Single point of setup, no scattered global flags
* Operation predicates - Self-documenting behavior (`needsReferenceAtCursor`, `allowsDuplicateReferences`)
* Type-safe - Compile-time checking replaces runtime magic string matching

==== Benefits of Backporting This API

*_Code Clarity and Safety_*

Replace magic strings with discoverable enums:

[source,c]
----
/* Before: What does this do? Need to search for documentation */
parseBufferUsingServer(options.project, target, NULL, "-olcxmovetarget", NULL);

/* After: Type-safe and self-documenting via ParserOperation enum */
parsingConfig.operation = PARSE_TO_VALIDATE_MOVE_TARGET;
parsingConfig.positionOfSelectedReference = makePositionFromMarker(target);
parseCurrentInputFile(LANG_C);
----

Replace scattered global flags with structured configuration:

[source,c]
----
/* Before: Scattered throughout, unclear semantics */
options.olcxPushButton = 1;
options.olcxRenameOption = 1;
s_noParametersToExpand = 0;
originalFileNumber = someValue;

/* After: All configuration in one place, clear purpose */
parsingConfig.operation = PARSE_TO_COMPLETE;
parsingConfig.targetParameterIndex = 5;
parsingConfig.extractMode = EXTRACT_VARIABLE;
----

*_Foundation for Multi-File Definition Lookup_*

The clean API makes it easier to implement required enhancements:

[source,c]
----
/* New operation for multi-file definition lookup */
typedef enum {
    /* ... existing operations ... */
    PARSE_TO_RESOLVE_DEFINITION,  /* NEW: Find definition across files */
} ParserOperation;

/* Simpler to add new parsing modes when API is clean */
parsingConfig.operation = PARSE_TO_RESOLVE_DEFINITION;
parsingConfig.symbolName = "findReferenceableAt";
parsingConfig.startFile = fileNumber;
----

*_Easier Feature Development_*

Adding new operations becomes straightforward:

1. Add to `ParserOperation` enum
2. Implement predicate functions if needed
3. Add semantic actions in grammar
4. Done - no magic strings to maintain

==== Implementation Plan: Three Non-Blocking Phases

*_Phase 1: Expose New API Alongside Legacy Code_*

**Scope**: Purely additive - new API works alongside legacy code
**Risk**: LOW (no changes to existing code paths)
**Value**: Proof of concept, enables gradual migration

**Approach**:

1. `parseWithConfig()` becomes primary entry point
2. `parseBufferUsingServer()` internally bridges legacy magic strings to new `ParsingConfig`
3. Both code paths work identically (verified with tests)
4. No changes needed to existing functionality

**Benefit**: Can merge this without affecting legacy code at all

*_Phase 2: Migrate High-Value Callsites_*

**Scope**: Refactor 50%+ of parsing infrastructure
**Risk**: MEDIUM (refactoring, but with tests)
**Value**: Significant improvement to codebase clarity

**Priority callsites**:

1. LSP handlers - Already partially using new API
2. Definition finding - Multi-file lookup
3. Extract refactoring - Complex logic, multiple operations
4. Move function - Multiple parsing passes

**Benefit**: 50%+ of parsing infrastructure modernized, multi-file definitions enabled

*_Phase 3: Complete Legacy Code Cleanup_*

**Scope**: Remove all magic string command routing, consolidate parsing
**Risk**: MEDIUM (larger refactoring)
**Value**: Long-term maintainability and extensibility

**Scope**:

* Remove all magic string command routing
* Consolidate parsing entry points
* Eliminate scattered global flags
* Document parser behavior in code

**Benefit**: Codebase future-proof for new operations

**Important**: Phase 3 is **optional** - Phases 1-2 already provide most value

==== Multi-File Definition: Requirements

*_Symbol Type Information Persistence_*

**Current**: ReferenceableItemTable only stores name, position, kind
**Needed**: Minimal type info for cross-file resolution

**Lightweight approach** (preferred over full type serialization):

[source,c]
----
/* Extend ReferenceableItem with minimal type data */
struct ReferenceableItem {
    /* ... existing fields ... */
    char *returnType;      /* For functions: return type string */
    int   parameterCount;  /* For functions: number of parameters */
    bool  isDefinition;    /* True if this is the function/variable definition */
};
----

**Scope**: Extend ReferenceableItem, careful memory management

*_Include Graph Construction_*

**Current**: Include relationships processed during lexing, not persisted
**Needed**: Map of which files include which headers

**Lightweight approach**:

[source,c]
----
typedef struct {
    int   sourceFile;         /* File with #include directive */
    int   includedFile;       /* File being included */
    bool  isSystemInclude;    /* <> vs \"\" */
} IncludeEdge;

/* Stored in file's metadata, retrievable by file number */
int getIncludedFileCount(int fileNumber);
int getIncludedFile(int fileNumber, int index);
int *getIncludingFiles(int fileNumber);  /* Files that include this one */
----

**Scope**: Moderate effort, moderate complexity

*_Incremental Multi-File Parsing_*

**Current**: Full project parse or single-file parse
**Needed**: Efficient "parse files needed for definition lookup" operation

**Approach**:

1. Use include graph to find "definition file candidates"
2. Parse only those files (typically 1-5 for most projects)
3. Store symbols in special "definition lookup" arena
4. Return to in-memory reference table when done

**Scope**: Parse relevant files, update reference table

**Total for full multi-file support**: Larger foundational work combining above three components

==== Code Locations

**New Parser API**:

* `src/parsing.h` - Public interface (167 lines)
* `src/parsing.c` - Implementation with bridges (187 lines)
* Functions: `getParserOperation()`, `needsReferenceAtCursor()`, `parseToCreateReferences()`

**Legacy code currently using magic strings**:

* `src/cxref.c` - 20+ `parseBufferUsingServer()` calls
* `src/refactory.c` - 10+ operations
* `src/extract.c` - Multiple parsing passes
* `src/complete.c` - Completion-specific parsing
* `src/server.c` - Operation dispatch

**Files for multi-file support**:

* `src/reference_database.h/c` - Add symbol type info
* `src/yylex.c` - Build include graph
* `src/filetable.h/c` - Persist include relationships

==== Success Metrics

**Phase 1**:

* New `ParsingConfig` API works alongside legacy strings
* No performance regression
* Both code paths tested and working

**Phase 2**:

* 50%+ of parsing callsites use new API
* Multi-file definition lookup works
* All existing tests still pass

**Phase 3** (if pursued):

* All parsing driven by enum operations
* Magic strings completely removed
* New developers understand control flow

==== Risks and Mitigation

[cols="1,1,2"]
|===
|Risk |Likelihood |Mitigation

|Breaking existing workflows
|Medium
|Phase 1 keeps old API working, extensive testing, clear migration timeline

|Incomplete refactoring
|Medium
|Phase 1-2 provide value even if Phase 3 never completes

|Performance regression
|Low
|New API does same work, just different control flow; profile before/after

|Memory overhead from type info
|Medium
|Use lightweight approach, store only essential fields, consider lazy loading
|===

==== Related Work

This refactoring supports:

* **link:/workspace/decisions#14[ADR-0014]** (On-Demand Parsing) - Single code path for all operations
* **Unified Symbol Database** (next major refactoring) - Requires clean parsing API
* **LSP Multi-File Support** - Immediately enables cross-file definition lookup

==== Notes

The key insight is that we can **backport this gradually without breaking anything**. The bridge pattern (new API calls old code for now) lets us improve incrementally, retiring magic strings and globals one section at a time.

Phase 1 proves the approach works with minimal risk. Phases 2-3 build on proven foundation, so failure to complete them doesn't harm existing functionality.

Multi-file definitions are one motivating use case, but the real long-term benefit is a codebase where parsing behavior is **discoverable and type-safe** instead of driven by magic strings scattered throughout 25-year-old code.
