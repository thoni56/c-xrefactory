== Roadmap

This chapter outlines the high-level architectural and feature goals for c-xrefactory. For implementation details, see link:17-major-codebase-improvements.adoc[Chapter 17: Major Codebase Improvements].

=== Guiding Principles

* **Incremental improvement**: Each step should provide immediate value while moving toward long-term goals
* **Test-driven modernization**: Maintain 85%+ test coverage to enable confident refactoring
* **Backward compatibility**: Preserve existing Emacs workflows while enabling modern IDE integration
* **Architectural simplification**: Replace artificial mode distinctions with unified, smart on-demand behavior
* **Legacy code respect**: Work with the existing 1990s codebase thoughtfully, not against it

=== Architectural Vision: Memory as Truth

==== The Goal

**In-memory references become the single source of truth.** Currently, the system has two sources (in-memory `referenceableItemTable` and `.cx` files on disk) with different code paths for navigation vs. refactoring. This creates complexity, bugs, and makes preloaded editor buffers work inconsistently.

==== Dependency Chain

The following diagram shows how the architectural pieces depend on each other. Work proceeds from bottom to top.

----
┌─────────────────────────────────────────────────────────────────────┐
│                    ARCHITECTURAL GOAL                                │
│         "In-memory references are the single source of truth"        │
└─────────────────────────────────────────────────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────────┐
│                         REQUIRES                                     │
├─────────────────────────────────────────────────────────────────────┤
│  A. Refactoring uses in-memory table (no callXref)                  │
│  B. Navigation uses in-memory table (no .cx lookups mid-session)    │
│  C. In-memory table is always current for all modified files        │
└─────────────────────────────────────────────────────────────────────┘
         │                    │                         │
         ▼                    ▼                         ▼
┌─────────────────┐  ┌─────────────────┐  ┌─────────────────────────┐
│ A. No callXref  │  │ B. Index-based  │  │ C. Table always current │
│ in refactoring  │  │    sessions     │  │                         │
└────────┬────────┘  └────────┬────────┘  └────────────┬────────────┘
         │                    │                         │
         │                    │                         ▼
         │                    │           ┌─────────────────────────┐
         │                    │           │ C1. All modified files  │
         │                    │           │     are preloaded       │
         │                    │           │ (Emacs client change)   │
         │                    │           └────────────┬────────────┘
         │                    │                        │
         │                    │                        ▼
         │                    │           ┌─────────────────────────┐
         │                    │           │ C2. Preloaded files     │
         │                    │           │     parsed upfront      │
         │                    │           │ (before any operation)  │
         │                    │           └────────────┬────────────┘
         │                    │                        │
         │                    ▼                        │
         │           ┌─────────────────┐               │
         │           │ B1. Session     │               │
         │           │ stores key +    │◄──────────────┘
         │           │ position, not   │  (upfront refresh works
         │           │ copies          │   because navigation reads
         │           └────────┬────────┘   from current table)
         │                    │
         │                    ▼
         │           ┌─────────────────┐
         │           │ B2. Table not   │
         │           │ corrupted by    │
         │           │ project mixing  │
         │           └────────┬────────┘
         │                    │
         ▼                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│                    SINGLE-PROJECT SERVER POLICY                      │
│         (Server handles one project, client manages switching)       │
└─────────────────────────────────────────────────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────────┐
│                    ENABLED BY (makes it natural)                     │
├─────────────────────────────────────────────────────────────────────┤
│  Project-local .c-xrefrc with automatic upward discovery            │
│  (See section: Foundational Change: Project-Local Configuration)    │
└─────────────────────────────────────────────────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────────┐
│                       ALSO ENABLES                                   │
├─────────────────────────────────────────────────────────────────────┤
│  • .cx becomes startup cache only (not consulted during ops)        │
│  • Include closure sufficient for finding affected files (ADR-13)   │
│  • LSP mode can use same architecture                               │
│  • Simpler mental model for debugging                               │
└─────────────────────────────────────────────────────────────────────┘
----

==== Component Summary

[cols="1,3"]
|===
|Component |Description

|**Single-project server**
|Foundation: Server handles one project at a time. Client (Emacs) manages project switching by restarting server or using separate server instances. Eliminates table corruption from project mixing and enables index-based sessions.

|**Index-based sessions**
|Session stores symbol key + current position instead of copying all references. Navigation reads directly from in-memory table, eliminating the "stale session copies" problem.

|**Upfront preload refresh**
|All preloaded files are parsed at start of each request, before any operation runs. Ensures in-memory table is always current. Requires index-based sessions to work (otherwise session copies would still be stale).

|**Emacs preloads all modified buffers**
|Client-side change: Send `-preload` for all modified buffers, not just current file. Without this, server is blind to modifications in non-current files.

|**No callXref in refactoring**
|Refactoring uses same in-memory table as navigation. Include closure (already implemented) finds affected files; parse on demand. Eliminates the architectural split between navigation and refactoring code paths.
|===

==== .cx File: Standard Cache Semantics

The `.cx` file is a **startup cache**, not a database. It follows standard cache semantics:

* **Cache miss**: No entry, or entry is stale → parse from authoritative source
* **Cache hit**: Entry exists and is current → use cached references

**Authoritative sources** (in priority order):

1. **Editor preload buffer** - if Emacs sends `-preload` for a file, that content is authoritative
2. **Disk file** - verified by mtime comparison against stored `lastParsedMtime`

The cache self-heals: missing `.cx` (cold start) or stale `.cx` (crash, external changes) are detected and corrected on access. See link:17-major-codebase-improvements.adoc#cache-miss-detection[Chapter 17: Cache Miss Detection] for the precise algorithm.

==== Related Decisions and Details

* **ADR-13**: No archaic extern patterns - limits symbol visibility to include-based, making include closure complete
* **ADR-14**: Adopt on-demand parsing architecture - formalizes this direction
* **Chapter 17**: Implementation details for Clean Persistence Store and Unified Symbol Database

==== Current State (January 2025)

The foundation work is **not yet started**. Current workarounds (like excluding refactoring operations from `lastParsedMtime` updates) paper over the architectural tension but don't resolve it.

See link:18-insights.adoc[Chapter 18: Insights] section "The lastParsedMtime Optimization and Refactoring Conflict" for a concrete example of the current complexity.

=== Foundational Change: Project-Local Configuration

==== The Goal

Enable project-local `.c-xrefrc` files with automatic discovery, replacing the current `$HOME/.c-xrefrc` multi-project architecture. This makes single-project server operation **natural** rather than restrictive.

==== Current Architecture

* Single `$HOME/.c-xrefrc` contains sections for all projects
* All paths must be absolute (not portable across machines)
* Client asks server "which project covers this file?"
* Server searches through all project sections to find a match

==== Target Architecture

**Automatic project discovery:**

----
Operation on /foo/bar/src/file.c
         ↓
Search upward: /foo/bar/src/.c-xrefrc? No
               /foo/bar/.c-xrefrc? Yes → project root is /foo/bar/
         ↓
Server locks to this single project
----

**Two-file configuration split:**

[cols="1,2,1"]
|===
|File |Purpose |Version control

|`.c-xrefrc`
|Project settings: compiler flags, `-D` defines, relative source paths
|Committed

|`.c-xrefrc.local`
|Machine-specific: external library paths, personal preferences
|Gitignored

|`$HOME/.c-xrefrc`
|Global defaults, backward compatibility
|N/A
|===

**Settings cascade** (priority low→high):

1. Built-in defaults
2. `$HOME/.c-xrefrc` (global, backward compat)
3. `.c-xrefrc` (project, committed)
4. `.c-xrefrc.local` (project, local overrides)
5. Command-line options

==== How This Enables Single-Project Server

With automatic project discovery:

* Project determined by file location, not explicit `-p` parameter
* Server "locks" to discovered project root on first request
* Request for file outside project → reject or prompt "add to project?"
* Multi-project operation becomes impossible by design

This makes single-project server a **natural consequence**, not an artificial restriction.

==== Protocol Evolution

The existing `-getproject <file>` command becomes the lock point:

----
First -getproject <file>:
  1. Upward search for .c-xrefrc from <file>
  2. If found: LOCK to that directory as project root
  3. Return project root (or name)

Subsequent -getproject <file>:
  1. Is <file> under locked project root?
  2. Yes → return same project
  3. No  → error "file not in current project"
----

**Key insight**: The client's existing pattern of sending `-getproject` before each operation requires no change. The server simply adds locking behavior.

==== Implementation Phases

**Phase 1: Upward search with locking** (minimal, unblocks single-project server)

* Add upward search for `.c-xrefrc` in `-getproject` handler
* First successful discovery locks server to that project root
* Subsequent requests for files outside root return error
* If no `.c-xrefrc` found: fall back to `$HOME/.c-xrefrc` (backward compat)
* Paths still absolute (no change to path handling yet)

**Phase 2: Relative paths**

* Paths in project-local `.c-xrefrc` resolved relative to project root
* Enables version-controllable project settings
* `$HOME/.c-xrefrc` continues using absolute paths

**Phase 3: Local overrides**

* Add `.c-xrefrc.local` support
* External library paths, personal preferences
* Document: add `.c-xrefrc.local` to `.gitignore`

**Phase 4: Migration tooling** (optional)

* Tool to extract `$HOME/.c-xrefrc` sections into project-local files
* Deprecation warnings for multi-project `$HOME/.c-xrefrc` usage

==== Relationship to Memory as Truth

This work directly enables the **Single-Project Server Policy** at the base of the Memory as Truth dependency chain. Without a natural way to scope to a single project, enforcing single-project operation would feel like an artificial limitation to users.

==== Open Questions

* Projects with sources in multiple unrelated directories - multiple `-I` paths but single root?
* Environment variable expansion in `.c-xrefrc.local` (e.g., `${MYLIB_PATH}/include`)?
* Migration path for users with complex multi-project `$HOME/.c-xrefrc`?

=== Feature Vision: Full LSP Support

==== The Goal

Enable VS Code, Neovim, and other LSP-capable editors to use c-xrefactory's refactoring and navigation features with full feature parity to the Emacs integration.

==== Current State

* ✓ Go-to-definition for functions, global variables, types (single file only)
* ✓ Files parsed as opened, immediate symbol availability

==== Planned Capabilities

[cols="1,1"]
|===
|Feature |Enables

|**Multi-file navigation**
|Jump to definitions in other files without opening them first

|**Find all references**
|Show all usages of a symbol across the project

|**Hover information**
|Display type and documentation on mouse hover

|**Code completion**
|Context-aware symbol completion

|**Rename refactoring**
|Safe rename across all files

|**Workspace search**
|Find symbols by name across project
|===

==== Dependencies

Full LSP support depends on the "Memory as Truth" architecture:

* Multi-file navigation requires the unified symbol database
* Rename refactoring requires the "no callXref" path
* All features benefit from single-project server simplicity

=== Feature Vision: Modern Refactorings

==== The Goal

Provide refactoring capabilities that understand C semantics, going beyond what generic text-based tools can offer.

==== Current Capabilities

* ✓ Rename (symbols, parameters, macros)
* ✓ Extract function/macro/variable
* ✓ Add/delete/reorder parameters
* ✓ Move function between files (Phase 1 MVP)

==== Planned Improvements

[cols="1,2"]
|===
|Feature |Value

|**Move function Phase 2**
|Automatically add function declaration to target header file

|**Move function Phase 3**
|Detect and optionally move tightly-coupled static helper functions

|**Smart include management**
|Automatically add/remove `#include` directives based on dependencies

|**Refactoring preview**
|Show what will be changed before applying
|===

==== Details

See link:17-major-codebase-improvements.adoc#move-function-refactoring[Chapter 17: Move Function Between Files] for implementation details and phase breakdown.
