== Roadmap

This chapter outlines the high-level architectural and feature goals for c-xrefactory. For implementation details, see link:17-major-codebase-improvements.adoc[Chapter 17: Major Codebase Improvements].

=== Guiding Principles

* **Incremental improvement**: Each step should provide immediate value while moving toward long-term goals
* **Test-driven modernization**: Maintain 85%+ test coverage to enable confident refactoring
* **Backward compatibility**: Preserve existing Emacs workflows while enabling modern IDE integration
* **Architectural simplification**: Replace artificial mode distinctions with unified, smart on-demand behavior
* **Legacy code respect**: Work with the existing 1990s codebase thoughtfully, not against it

=== Architectural Vision: Memory as Truth

==== The Goal

**In-memory references become the single source of truth.** Currently, the system has two sources (in-memory `referenceableItemTable` and `.cx` files on disk) with different code paths for navigation vs. refactoring. This creates complexity, bugs, and makes preloaded editor buffers work inconsistently.

==== Dependency Chain

The following diagram shows how the remaining architectural pieces depend on each other. Work proceeds from bottom to top.

----
                  Memory is truth
                  (convergence point)
                   /              \
                  v                v
    No callXref in           .cx becomes
    refactoring           startup snapshot
           |                      |
           v                      v
    ADR 22: Lightweight     Index-based sessions
    file structure scan    (keys + positions,
    (replaces -create        not copies)
     and callXref)                |
           |                      |
           v                      v
    ┌───────────────────────────────────┐
    │          FOUNDATION (done)        │
    │  ADR 20: Sync before dispatch    │
    │  Client sends all modified buffers│
    │  Single-project server (ADR-0021) │
    │  Project-local config (ADR-0005)  │
    │  Unified startup (shared init)    │
    └───────────────────────────────────┘
----

==== Component Summary

[cols="1,3"]
|===
|Component |Description

|**Separate sync from dispatch (done)**
|Server-side restructuring (link:/workspace/decisions#20[ADR-0020]): the server entry point reparses stale files before dispatching any operation. Pass 1 reparses stale CUs, Pass 2 walks the reverse-include graph (via `TypeCppInclude` references) to find and reparse CUs that include stale headers. Operations can assume the in-memory table is current.

|**Lightweight file structure scanning**
|Replace the expensive full-project `-create` and `callXref()` with lightweight scanning (link:/workspace/decisions#22[ADR-0022]): discover CUs by globbing the project directory, extract include structure from `#include` lines, populate the same `TypeCppInclude` references that full parsing creates. The scan/mtime-check/incremental-reparse pipeline built for ADR 20 is the same pipeline needed here — just triggered at a different point (server startup or before refactoring, instead of per-request).

|**Index-based sessions**
|Session stores symbol key + current position instead of copying all references. Navigation reads directly from in-memory table, eliminating the "stale session copies" problem. Depends on upfront refresh (ADR 20) so that the table is always current when sessions read from it.

|**No callXref in refactoring**
|Refactoring uses same in-memory table as navigation, with lightweight scanning replacing `callXref()`. The existing graduated update strategy in `computeUpdateOptionForSymbol()` already decides the right scope per refactoring: no update for local symbols, fast update for multi-file globals, full update for symbols in headers. This logic maps directly onto the lightweight scan approach — only the update mechanism changes (scan + incremental reparse instead of `callXref()`). Include closure (link:/workspace/decisions#13[ADR-0013]) finds affected files; parse on demand. See link:18-insights.adoc[Chapter 18: RefactoryMode Internally Calls XrefMode] for the current architecture this replaces.

|**Disk snapshot strategy**
|The `.cx` file transitions from a live database to a startup snapshot. This requires a strategy for initial creation from disk files and incremental updates — taking care that modified-buffer data is never persisted to the snapshot (it reflects disk state only). See below for target semantics.
|===

==== Incremental Implementation Path

Both navigation and refactoring already use the same in-memory `ReferenceableItemTable` (see link:18-insights.adoc[Chapter 18: Unified In-Memory Table Discovery] for details). The infrastructure for memory-as-truth is largely already in place:

* **Include structure** is already tracked via `TypeCppInclude` references in the reference table — the same mechanism that full parsing creates. Lightweight scanning (ADR 22) would populate these without full parsing.
* **Staleness detection** is already working: mtime checks on editor buffers, entry-point reparse with transitive include-graph walking (ADR 20).
* **Graduated update scope** already exists: `computeUpdateOptionForSymbol()` decides per-refactoring whether no update, fast update, or full update is needed based on symbol visibility and scope.

The path forward is:

1. **Lightweight scanning replaces `-create`** — discover CUs and include structure without full parsing. Populate the same `TypeCppInclude` references. No disk db write needed.
2. **Same scanning replaces `callXref()` before refactoring** — scan + mtime check + reparse stale files in the include closure. The graduated scope decision (`computeUpdateOptionForSymbol`) stays the same.
3. **`.cx` becomes startup snapshot** — loaded once at startup for fast warm start, never consulted during operation. The in-memory table is authoritative.

==== .cx File: Startup Snapshot

Once memory is truth, the `.cx` file is a **startup snapshot** — a serialized copy of previously-computed references that avoids a full project parse on server start.

**Startup sequence:**

1. Load snapshot from `.cx` (if it exists)
2. Compare each entry's stored mtime against the current disk file
3. Re-parse any files that changed since the snapshot was written
4. Client connects, sends preloaded buffers — those are parsed into memory, overriding disk state

After startup, the `.cx` file is not consulted. All operations read from the in-memory table.

**Writing the snapshot:**

The snapshot is written from disk-file-derived references only. Modified-buffer data must never be persisted — the snapshot reflects disk state, so that startup validation (step 2) remains correct.

**Cold start** (no `.cx` file): All project source files are parsed. This is slower but self-healing — no manual action needed to recover from a missing or corrupt snapshot.

==== Related Decisions and Details

* **link:/workspace/decisions#5[ADR-0005]**: Automatically find config files — enables project discovery by upward search
* **link:/workspace/decisions#13[ADR-0013]**: No archaic extern patterns — limits symbol visibility to include-based, making include closure complete
* **link:/workspace/decisions#14[ADR-0014]**: Adopt on-demand parsing architecture — formalizes this direction
* **link:/workspace/decisions#20[ADR-0020]**: Separate sync from dispatch — implemented, entry-point reparse with include-graph walking
* **link:/workspace/decisions#21[ADR-0021]**: Single-project server policy — foundation for index-based sessions
* **link:/workspace/decisions#22[ADR-0022]**: Lightweight file structure scanning — replaces `-create` and `callXref()`
* **Chapter 17**: Implementation details for Clean Persistence Store and Unified Symbol Database

=== Feature Vision: Full LSP Support

==== The Goal

Enable VS Code, Neovim, and other LSP-capable editors to use c-xrefactory's refactoring and navigation features with full feature parity to the Emacs integration.

==== Current State

* Go-to-definition for functions, global variables, types (single file only)
* Files parsed as opened, immediate symbol availability

==== Planned Capabilities

[cols="1,1"]
|===
|Feature |Enables

|**Multi-file navigation**
|Jump to definitions in other files without opening them first

|**Find all references**
|Show all usages of a symbol across the project

|**Hover information**
|Display type and documentation on mouse hover

|**Code completion**
|Context-aware symbol completion

|**Rename refactoring**
|Safe rename across all files

|**Workspace search**
|Find symbols by name across project
|===

==== Dependencies

Full LSP support depends on the "Memory as Truth" architecture:

* Multi-file navigation requires the unified symbol database
* Rename refactoring requires the "no callXref" path
* All features benefit from single-project server simplicity

=== Feature Vision: Modern Refactorings

==== The Goal

Provide refactoring capabilities that understand C semantics, going beyond what generic text-based tools can offer.

==== Current Capabilities

* Rename (symbols, parameters, macros)
* Extract function/macro/variable
* Add/delete/reorder parameters
* Move function between files (Phase 1 MVP)

==== Planned Improvements

[cols="1,2"]
|===
|Feature |Value

|**Move function Phase 2**
|Automatically add function declaration to target header file

|**Move function Phase 3**
|Detect and optionally move tightly-coupled static helper functions

|**Smart include management**
|Automatically add/remove `#include` directives based on dependencies

|**Refactoring preview**
|Show what will be changed before applying
|===

==== Details

See link:#move-function-refactoring[Chapter 16: Move Function Between Files] for implementation details and phase breakdown.
