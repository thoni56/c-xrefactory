== Roadmap

This chapter outlines the development roadmap for c-xrefactory, tracking completed work, current priorities, and future architectural goals.

=== Guiding Principles

The roadmap is guided by these principles:

* **Incremental improvement**: Each step should provide immediate value while moving toward long-term goals
* **Test-driven modernization**: Maintain ~80% test coverage to enable confident refactoring
* **Backward compatibility**: Preserve existing Emacs workflows while enabling modern IDE integration
* **Architectural simplification**: Replace artificial mode distinctions with unified, smart on-demand behavior
* **Legacy code respect**: Work with the existing 1990s codebase thoughtfully, not against it

=== Recent Accomplishments (2025 Q1)

==== C Preprocessor Compliance Fixes

**Problem**: c-xrefactory was incorrectly expanding function-like macros during `##` token pasting, violating C99 §6.10.3.3 which mandates that operands of `##` should NOT be macro-expanded before concatenation.

**Impact**: Caused SIGSEGV in `test_ffmpeg` when processing complex standard library macros like `INT64_MAX` which expands to `(__INT64_C(9223372036854775807))` where `__INT64_C(c)` is defined as `c ## L`.

**Fix**: Removed macro expansion logic from `collate()` function in `src/yylex.c:1749-1797`. Now matches GCC behavior exactly.

**Test Updates**: Updated 5 test cases to match correct GCC preprocessor behavior:

* `test_collate_empty`
* `test_token_pasting_with_expansion`
* `test_token_pasting_with_expansion_lhs`
* `test_token_pasting_with_expansion_rhs`
* `test_token_pasting_with_illegal_expansion`

==== Memory Scaling Improvements

**Problem**: Large projects like ffmpeg were hitting the 30MB `stackMemory` limit during symbol table construction.

**Root Cause**: Stack memory is a persistent arena allocator that accumulates symbol tables across all parsed files. Growth is expected and normal for large projects.

**Fix**: Increased `SIZE_stackMemory` from 30MB to 100MB in `src/constants.h:19`.

**Diagnostic Additions**: Added nesting level and stack index tracking in `src/xref.c` to monitor memory usage patterns and detect unbalanced block nesting.

=== Short-term Goals (Next 3-6 Months)

==== Test Coverage Expansion

*Current Status*: ~80% coverage, ongoing improvement

*Priority*: HIGH

*Goals*:

* Achieve 85%+ coverage for core modules
* Add focused tests for macro expansion subsystem
* Expand coverage for LSP integration points
* Systematic testing of error handling paths

==== LSP Feature Completeness

*Current Status*: Basic LSP communication works, features not yet accessible

*Priority*: HIGH

*Goals*:

* Wire up existing symbol navigation to LSP protocol
* Implement `textDocument/definition` using reference database
* Implement `textDocument/references`
* Implement `textDocument/hover` with symbol information
* Enable `textDocument/completion` for basic completion

*Approach*: Leverage existing reference database (`refTab`) and symbol tables - no major architectural changes needed initially.

==== Documentation Completeness

*Current Status*: Architecture documentation mostly complete

*Priority*: MEDIUM

*Goals*:

* Complete Structurizr C4 model with all major components
* Document memory management strategies across all arenas
* Create user guide for LSP integration
* Document LSP vs Emacs feature parity matrix

=== Medium-term Goals (6-12 Months)

These goals are detailed in <<16-proposed-refactorings.adoc#,Chapter 16: Proposed Refactorings>>. The roadmap establishes priority ordering:

==== 1. LexemStream API Improvements

*Reference*: <<16-proposed-refactorings.adoc#,Proposed Refactorings - LexemStream API Improvements>>

*Priority*: HIGH (Foundation for other refactorings)

*Rationale*: The macro expansion code suffers from pointer parameter proliferation (6+ parameters per function). Adding a manipulation API to `LexemStream` (similar to `LexemBuffer`) will simplify buffer management and reduce error-prone pointer arithmetic.

*Impact*:

* Reduces `collate()` from 6 parameters to 3-4
* Centralizes buffer management logic
* Enables clearer ownership semantics
* Foundation for macro module extraction

*Estimated Effort*: 3-4 weeks

* Week 1: Design and implement core API
* Week 2: Refactor `copyRemainingLexems()` and `collate()` as proof-of-concept
* Week 3-4: Migrate remaining macro expansion functions

==== 2. Extract Macro Expansion Module

*Reference*: <<16-proposed-refactorings.adoc#macro-expansion-module,Proposed Refactorings - Extract Macro Expansion Module>>

*Priority*: MEDIUM (Depends on LexemStream API)

*Rationale*: `yylex.c` is 2353 lines combining lexing, file management, preprocessor directives, and macro expansion (~800 lines). Extracting macro expansion improves modularity and testability.

*Impact*:

* Reduces yylex.c by 34% (~800 lines)
* Enables independent testing of macro expansion
* Clearer separation: lexing vs. preprocessing
* Facilitates future C++ macro support

*Estimated Effort*: 4-6 weeks

* Week 1-2: Create module structure and move memory management
* Week 3-4: Migrate token processing and expansion logic
* Week 5-6: Integration, testing, and documentation

==== 3. Unified Symbol Database Architecture

*Reference*: <<16-proposed-refactorings.adoc#unified-symbol-database,Proposed Refactorings - Unified Symbol Database Architecture>>

*Priority*: HIGH (Enables true on-demand LSP)

*Rationale*: Current artificial distinction between "file-based" and "on-demand" modes creates unnecessary complexity. Both Emacs and LSP clients want the same thing: up-to-date symbol information.

*Key Insight*: The `.cx` files are a **persistent cache** of analysis results, not a fundamental requirement. c-xrefactory should provide smart on-demand behavior that:

* Always ensures information is current using existing dependency tracking
* Scans incrementally only what's needed, when needed
* Uses `.cx` files for optimization, not as a prerequisite

*Impact*:

* **Eliminates cold start** - no upfront `-create` required
* **Single code path** for Emacs and LSP
* **Transparent caching** - `.cx` files automatically maintained
* **Leverages existing logic** - reuses proven dependency tracking system

*Architecture*:

[source,c]
----
Symbol* lookupSymbol(const char* name, Position pos) {
    // 1. Check if cached information is up-to-date
    if (symbolInfoIsCurrent(name, pos)) {
        return getCachedSymbolInfo(name, pos);
    }

    // 2. Use existing dependency tracking to scan minimal set
    FileList* filesToScan = calculateDependencyClosure(pos.file);
    for (FileItem* file : filesToScan) {
        if (checkFileModifiedTime(file->fileNumber)) {
            scanFileAndUpdateCache(file);
        }
    }

    // 3. Update persistent cache
    updateSymbolCache(name, pos);
    return getSymbolInfo(name, pos);
}
----

*Estimated Effort*: 8-12 weeks

* Week 1-3: Design unified interface and wrap existing logic
* Week 4-6: Implement smart dependency-driven on-demand scanning
* Week 7-9: Optimize caching strategies and incremental updates
* Week 10-12: Thorough testing, performance tuning, documentation

=== Long-term Vision (12-24 Months)

==== On-Demand Incremental Architecture for LSP

*Current Limitation*: Stack memory accumulates symbol tables across all files forever. This works for batch cross-referencing but is incompatible with long-running LSP servers handling file edits.

*Vision*: Enable true on-demand, per-file parsing suitable for LSP `textDocument/didChange` events.

===== Two-Phase Architecture

**Phase 1: Batch Indexing** (Current behavior, optimized)

----
For each file in project:
    Parse file → populate refTab → discard stackMemory symbols

Result: refTab contains all references, stackMemory reset between files
----

**Phase 2: LSP On-Demand** (Future capability)

----
Load refTab from .cx files (persistent cache)

On textDocument/didChange(file):
    1. Remove old references for file from refTab
    2. Reparse file → update refTab with new references
    3. Reset stackMemory (symbols discarded, only refTab persists)
    4. Navigation uses refTab, not stackMemory symbols!
----

===== Key Architectural Insights

* **Navigation uses refTab, not stackMemory**: This is crucial - symbol lookup queries the reference table, not the ephemeral symbol structures
* **stackMemory can be reset per-file**: As long as refTab is updated first
* **Incremental file updates become possible**: Parse → update refTab → discard symbols
* **Backward compatible**: Batch mode continues to work exactly as before

===== Memory Management Strategy

After unified symbol database is complete, investigate:

* Per-file stackMemory reset after populating refTab
* Separation of navigation data (refTab - persistent) from parsing data (stackMemory - ephemeral)
* Smart arena allocation strategies for long-running servers
* Background garbage collection for unused symbol data

*Estimated Effort*: 16-20 weeks (major architectural work)

==== Full LSP Protocol Compliance

*Dependencies*: Unified symbol database, on-demand architecture

*Goals*:

* Complete implementation of core LSP features:
** `textDocument/definition` ✓ (basic navigation exists)
** `textDocument/references` ✓ (reference database exists)
** `textDocument/hover` (symbol information)
** `textDocument/completion` ✓ (completion system exists)
** `textDocument/rename` ✓ (refactoring engine exists)
** `textDocument/documentSymbol` (symbol outline)
** `textDocument/formatting` (if desired)
** `workspace/symbol` (project-wide symbol search)

* Performance optimization for large projects:
** Lazy loading of symbol data
** Incremental parsing on file changes
** Background indexing
** Memory-mapped `.cx` file access

* Multi-workspace support
* Configuration via LSP initialization options

*Estimated Effort*: 20-24 weeks (building on unified database)

==== Modern IDE Integration Showcase

*Dependencies*: Full LSP compliance

*Goals*:

* **VS Code Extension**: Official c-xrefactory extension with feature parity to Emacs
* **Vim/Neovim Support**: LSP client configuration and documentation
* **Other IDEs**: Ensure LSP implementation works with CLion, Qt Creator, etc.
* **Feature Demonstrations**: Video tutorials showing refactoring capabilities
* **Benchmark Comparisons**: Performance vs. clangd, ccls for large C codebases

*Marketing*:

* Emphasize unique C-specific features (macro understanding, Yacc support)
* Highlight safe refactoring capabilities
* Target embedded systems and legacy C projects

=== Migration and Compatibility Strategy

==== Backward Compatibility Guarantee

* Existing Emacs workflows will continue to work unchanged
* `.cx` file format remains compatible (or auto-migrates transparently)
* Command-line interface preserved (though some commands may become no-ops)
* All existing refactoring operations maintain behavior

==== Deprecation Path

When unified symbol database is complete:

* `-create` becomes optional (auto-triggers on first query if needed)
* `-update` becomes automatic (modification time checking)
* Mode flags (`FILE_BASED`, `ON_DEMAND`) deprecated internally
* User-visible options remain for backward compatibility but may have no effect

==== Testing Strategy

Throughout all changes:

* **Zero test regressions** - 140+ test suite must pass
* **Coverage maintenance** - keep ~80%+ coverage during refactoring
* **Performance validation** - no >5% regression on large projects
* **Integration testing** - both Emacs and LSP workflows tested

=== Success Metrics

==== Technical Metrics

* **Test Coverage**: Maintain 80%+, target 85%+
* **Response Time**: LSP `textDocument/definition` < 100ms for 90th percentile
* **Memory Efficiency**: LSP server < 500MB RAM for 1M LOC project
* **Startup Time**: Zero cold start delay (no mandatory `-create`)

==== Adoption Metrics

* **VS Code Extension**: 1000+ downloads in first 6 months
* **GitHub Stars**: 500+ (currently ~150)
* **Issue Response**: <48 hours median time to first response
* **Documentation**: 100% of features documented with examples

==== Community Metrics

* **Contributors**: 5+ active contributors beyond maintainer
* **LSP Compatibility**: Works with 3+ major IDEs (VS Code, Vim, CLion)
* **User Satisfaction**: Positive feedback on LSP integration

=== Risk Management

==== Technical Risks

[cols="1,1,2"]
|===
|Risk |Likelihood |Mitigation

|Breaking existing Emacs users
|Medium
|Maintain strict backward compatibility, extensive testing, staged rollout

|Performance regression
|Medium
|Profile before/after each change, performance test suite, optimization budget

|LSP protocol complexity
|Low
|Use existing battle-tested LSP libraries, focus on core features first

|Memory leaks in long-running server
|Medium
|Careful arena allocator design, memory profiling, leak detection tools

|Difficulty attracting contributors
|High
|Excellent documentation, beginner-friendly issues, responsive maintainer

|Competing with clangd
|High
|Focus on unique strengths: macro understanding, Yacc support, safe refactoring
|===

==== Mitigation Strategies

* **Incremental delivery**: Each phase provides standalone value
* **Continuous testing**: Never sacrifice test coverage for features
* **User feedback loops**: Early LSP alpha with select users
* **Fallback options**: Keep old code paths during transition
* **Documentation first**: Write the docs before the code

=== Next Actions

Priority tasks for immediate action:

1. **Complete LSP handler wiring** (1-2 weeks)
   * Map existing navigation functions to LSP requests
   * Test with real LSP client (VS Code)
   * Document any gaps

2. **Design LexemStream API** (1 week)
   * Finalize interface based on proposal
   * Create initial implementation
   * Write unit tests

3. **Plan unified database refactoring** (2 weeks)
   * Detailed design document
   * Identify all affected code paths
   * Prototype dependency-driven scanning

4. **Establish performance baseline** (1 week)
   * Measure current Emacs operation speeds
   * Profile memory usage patterns
   * Document acceptable overhead budgets

=== Conclusion

The roadmap balances immediate user value (LSP features, bug fixes) with long-term architectural health (unified database, modular design). Each phase builds on previous work, with clear success metrics and risk mitigation strategies.

The end goal is a c-xrefactory that is:

* **Zero-configuration**: Works immediately on any C project
* **Modern**: First-class LSP support for all IDEs
* **Powerful**: Unique C-specific features unmatched by competitors
* **Maintainable**: Clean architecture enabling continued evolution
* **Backward compatible**: Existing Emacs users unaffected

This transformation from a 1990s batch cross-referencer to a modern, on-demand LSP server is achievable through careful incremental refactoring guided by comprehensive tests.

---

NOTE: This roadmap is a living document. As priorities shift and new insights emerge, it will be updated to reflect current understanding and goals. See also <<16-proposed-refactorings.adoc#,Chapter 16: Proposed Refactorings>> for detailed technical proposals.
