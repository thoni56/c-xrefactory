== Roadmap

This chapter outlines the high-level architectural and feature goals for c-xrefactory. For implementation details, see link:17-major-codebase-improvements.adoc[Chapter 17: Major Codebase Improvements].

=== Guiding Principles

* **Incremental improvement**: Each step should provide immediate value while moving toward long-term goals
* **Test-driven modernization**: Maintain 85%+ test coverage to enable confident refactoring
* **Backward compatibility**: Preserve existing Emacs workflows while enabling modern IDE integration
* **Architectural simplification**: Replace artificial mode distinctions with unified, smart on-demand behavior
* **Legacy code respect**: Work with the existing 1990s codebase thoughtfully, not against it

=== Architectural Vision: Memory as Truth

==== The Goal

**In-memory references become the single source of truth.** Currently, the system has two sources (in-memory `referenceableItemTable` and `.cx` files on disk) with different code paths for navigation vs. refactoring. This creates complexity, bugs, and makes preloaded editor buffers work inconsistently.

==== Dependency Chain

The following diagram shows how the remaining architectural pieces depend on each other. Work proceeds from bottom to top. Items at the base (single-project server, project-local configuration, unified startup) are already implemented.

----
                  Memory is truth
                  (convergence point)
                   /              \
                  v                v
    No callXref in           .cx becomes
    refactoring           startup snapshot
                  \              /
                   \            /
                    v          v
              Index-based sessions
          (keys + positions, not copies)
                       |
                       v
         ADR 20: Separate sync from dispatch
       (hoist buffer refresh to server entry;
        operations assume fresh data)
                       |
                       v
    ┌───────────────────────────────────┐
    │          FOUNDATION (done)        │
    │  Client sends all modified buffers│
    │  Single-project server (ADR-0021) │
    │  Project-local config (ADR-0005)  │
    │  Unified startup (shared init)    │
    └───────────────────────────────────┘
----

==== Component Summary

[cols="1,3"]
|===
|Component |Description

|**Separate sync from dispatch**
|Server-side restructuring (link:/workspace/decisions#20[ADR-0020]): hoist all buffer refresh to the server entry point so that operations can assume the in-memory table is current. This eliminates mid-operation re-parse issues and is valuable even before the full "memory is truth" goal is reached.

|**Index-based sessions**
|Session stores symbol key + current position instead of copying all references. Navigation reads directly from in-memory table, eliminating the "stale session copies" problem. Depends on upfront refresh (ADR 20) so that the table is always current when sessions read from it.

|**No callXref in refactoring**
|Refactoring uses same in-memory table as navigation. Include closure (already implemented, link:/workspace/decisions#13[ADR-0013]) finds affected files; parse on demand. Eliminates the architectural split between navigation and refactoring code paths. See link:18-insights.adoc[Chapter 18: RefactoryMode Internally Calls XrefMode] for the current architecture this replaces.

|**Disk snapshot strategy**
|The `.cx` file transitions from a live database to a startup snapshot. This requires a strategy for initial creation from disk files and incremental updates — taking care that modified-buffer data is never persisted to the snapshot (it reflects disk state only). See below for target semantics.
|===

==== Incremental Implementation Path

Both navigation and refactoring already use the same in-memory `ReferenceableItemTable` (see link:18-insights.adoc[Chapter 18: Unified In-Memory Table Discovery] for details). The disk scan operations merge with this table. This means the path to memory-is-truth is incremental:

1. **Parse all project files at startup** — populates the in-memory table completely
2. **Existing code continues to work** — scan operations find symbols already in memory, becoming effective no-ops
3. **Remove scan operations** — once step 1 is proven, scan code is dead and can be removed

==== .cx File: Startup Snapshot

Once memory is truth, the `.cx` file is a **startup snapshot** — a serialized copy of previously-computed references that avoids a full project parse on server start.

**Startup sequence:**

1. Load snapshot from `.cx` (if it exists)
2. Compare each entry's stored mtime against the current disk file
3. Re-parse any files that changed since the snapshot was written
4. Client connects, sends preloaded buffers — those are parsed into memory, overriding disk state

After startup, the `.cx` file is not consulted. All operations read from the in-memory table.

**Writing the snapshot:**

The snapshot is written from disk-file-derived references only. Modified-buffer data must never be persisted — the snapshot reflects disk state, so that startup validation (step 2) remains correct.

**Cold start** (no `.cx` file): All project source files are parsed. This is slower but self-healing — no manual action needed to recover from a missing or corrupt snapshot.

==== Related Decisions and Details

* **link:/workspace/decisions#5[ADR-0005]**: Automatically find config files — enables project discovery by upward search
* **link:/workspace/decisions#13[ADR-0013]**: No archaic extern patterns — limits symbol visibility to include-based, making include closure complete
* **link:/workspace/decisions#14[ADR-0014]**: Adopt on-demand parsing architecture — formalizes this direction
* **link:/workspace/decisions#21[ADR-0021]**: Single-project server policy — foundation for index-based sessions
* **Chapter 17**: Implementation details for Clean Persistence Store and Unified Symbol Database

=== Feature Vision: Full LSP Support

==== The Goal

Enable VS Code, Neovim, and other LSP-capable editors to use c-xrefactory's refactoring and navigation features with full feature parity to the Emacs integration.

==== Current State

* Go-to-definition for functions, global variables, types (single file only)
* Files parsed as opened, immediate symbol availability

==== Planned Capabilities

[cols="1,1"]
|===
|Feature |Enables

|**Multi-file navigation**
|Jump to definitions in other files without opening them first

|**Find all references**
|Show all usages of a symbol across the project

|**Hover information**
|Display type and documentation on mouse hover

|**Code completion**
|Context-aware symbol completion

|**Rename refactoring**
|Safe rename across all files

|**Workspace search**
|Find symbols by name across project
|===

==== Dependencies

Full LSP support depends on the "Memory as Truth" architecture:

* Multi-file navigation requires the unified symbol database
* Rename refactoring requires the "no callXref" path
* All features benefit from single-project server simplicity

=== Feature Vision: Modern Refactorings

==== The Goal

Provide refactoring capabilities that understand C semantics, going beyond what generic text-based tools can offer.

==== Current Capabilities

* Rename (symbols, parameters, macros)
* Extract function/macro/variable
* Add/delete/reorder parameters
* Move function between files (Phase 1 MVP)

==== Planned Improvements

[cols="1,2"]
|===
|Feature |Value

|**Move function Phase 2**
|Automatically add function declaration to target header file

|**Move function Phase 3**
|Detect and optionally move tightly-coupled static helper functions

|**Smart include management**
|Automatically add/remove `#include` directives based on dependencies

|**Refactoring preview**
|Show what will be changed before applying
|===

==== Details

See link:17-major-codebase-improvements.adoc#move-function-refactoring[Chapter 17: Move Function Between Files] for implementation details and phase breakdown.
