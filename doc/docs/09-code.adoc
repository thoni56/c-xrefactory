== Implementation Notes

This chapter collects cross-cutting implementation details that don't belong to a single component: editor-server protocol, file processing orchestration, multi-pass configuration, and other observations about how the subsystems interact.

=== Commands

The _editorExtension_ calls the server using command line
options. These are then converted to first a command enum starting in
`OP` ("operation") or `AVR` ("available refactoring").

Some times the server needs to call the crossreferencer which is
performed in the same manner, command line options, but this call is
internal so the wanted arguments are stored in a vector which is
passed to the `xref()` in the same manner as `main()` passes the
actual `argc`/`argv`.

Many of the commands require extra arguments like positions/markers
which are passed in as extra arguments. E.g. a rename requires the
name to rename to which is sent in the `renameto=` option, which is
argparsed and stored in the option structure.

Some of these extra arguments are fairly random, like `-olcxparnum=`
and `-olcxparnum2=`. This should be cleaned up.

A move towards "events" with arguments would be helpful. This would
mean that we need to:

* List all "events" that `c-xref` need to handle
* Define the parameters/extra info that each of them need
* Clean up the command line options to follow this
* Create event structures to match each event and pass this to `server`, `xref` and `refactory`
* Rebuild the main command loop to parse command line options into event structures

=== Passes

`c-xrefactory` makes it possible to parse the analyzed source multiple passes in case
you compile the project sources with different C defines. In the project configuration
file you specify `-passN' followed by the settings, typically C PreProcessor defines,
that are to be applied for this pass over the sources.

=== File Processing Orchestration

The file processing architecture differs significantly between Server mode, Xref mode,
and LSP mode, with confusing global state and naming inconsistencies that make the code
hard to follow.

==== File Scheduling - How Files Get Marked for Processing

All modes begin by marking files for processing using the `isScheduled` flag in the file table.

*_Initial Scheduling (All Modes)_*

*Called from:*

* Server: `initServer()` → `processFileArguments()` [`server.c:151`]
* Xref: `mainTaskEntryInitialisations()` → `processFileArguments()` [`startup.c:706`]

*Flow:*

[source]
----
processFileArguments() [options.c:1893]
  │
  └─> FOR each file in options.inputFiles
       │
       └─> processFileArgument(filename) [options.c:1864]
            │
            └─> dirInputFile(...) [options.c:465]
                 ├─ If directory: recursively map over files
                 ├─ If file: scheduleCommandLineEnteredFileToProcess(filename)
                 │           └─ SETS: fileItem->isScheduled = true [line 450]
                 └─ If wildcard: expand and recurse
----

*Result:* All command-line files (and directory contents if `-r` flag) are marked with `isScheduled = true`.

*_Additional Update Scheduling (Xref Mode Only)_*

*Called from:* `callXref()` → `scheduleModifiedFilesToUpdate()` [`xref.c:296`]

*Flow:*

[source]
----
scheduleModifiedFilesToUpdate(isRefactoring) [xref.c:207]
  │
  ├─> mapOverFileTable(schedulingToUpdate, isRefactoring)
  │    └─ For each file: if modified, SETS: fileItem->scheduledToUpdate = true
  │
  ├─> If UPDATE_FULL: makeIncludeClosureOfFilesToUpdate()
  │    └─ Expands scheduledToUpdate to include all files that #include updated files
  │
  └─> mapOverFileTable(schedulingUpdateToProcess)
       └─ For each file: if (scheduledToUpdate && isArgument)
           SETS: fileItem->isScheduled = true [line 115]
----

*Result:* In update mode, only modified files (and their includers) get `isScheduled = true`.

==== Server Mode Flow

*SINGLE FILE PER REQUEST* - Server processes one file per request, but all files are initially scheduled by `processFileArguments()` in `initServer()`.

[source]
----
initServer(args) [server.c:148]
  ├─> processOptions(args, ...)
  ├─> processFileArguments()  ← SCHEDULES ALL FILES
  └─ Sets up completions

server() [server.c:237] - Infinite request loop
  │
  └─> FOR EACH REQUEST:
       │
       └─> callServer(baseArgs, requestArgs, &firstPass) [server.c:214]
            │
            ├─> prepareInputFileForRequest() [server.c:95]
            │    ├─ Gets first scheduled file (local check only)
            │    ├─ SETS: requestFileNumber = NO_FILE_NUMBER [line 104] (if no file)
            │    └─ SETS: requestFileNumber = fileNumber [line 121] (if file found)
            │
            └─> processFile(baseArgs, requestArgs, &firstPass) [server.c:199]
                 ├─ SETS: inputFileName = fileItem->name [line 205]
                 │
                 └─> singlePass(args, nargs, &firstPass) [server.c:155]
                      │
                      ├─> initializeFileProcessing(args, nargs, &firstPass) [startup.c:490]
                      │    ├─ READS: fileName = inputFileName [line 502]
                      │    ├─ USES: parsingConfig.fileNumber = currentFile.characterBuffer.fileNumber [line 161]
                      │    │
                      │    └─> computeAndOpenInputFile(inputFileName) [startup.c:112]
                      │         ├─ Gets EditorBuffer or opens file
                      │         │
                      │         └─> initInput(inputFile, inputBuffer, "\n", fileName) [yylex.c]
                      │              └─ Sets up currentFile global with CharacterBuffer
                      │
                      ├─> parseInputFile() [server.c:131]
                      │    ├─ USES: currentFile.fileName [line 133]
                      │    ├─ Calls setupParsingConfig(requestFileNumber) [line 136]
                      │    │
                      │    └─> callParser(parsingConfig.fileNumber, parsingConfig.language) [line 140]
                      │
                      └─> SPECIAL CASE: Completion in macro body [lines 183-196]
                           ├─ SETS: inputFileName = getFileItemWithFileNumber(...)->name [line 189]
                           ├─> initializeFileProcessing(args, nargs, &firstPass) [again]
                           └─> parseInputFile() [again]
----

==== Xref Mode Flow

*PROCESSES ALL SCHEDULED FILES* - Xref creates a list of all scheduled files and processes them in a loop.

[source]
----
xref(args) [xref.c:354]
  │
  └─> callXref(args, isRefactoring) [xref.c:283]
       │
       ├─> IF options.update:
       │    └─> scheduleModifiedFilesToUpdate(isRefactoring) [line 296]
       │         └─ Adds modified files to scheduled list
       │
       ├─> fileItem = createListOfInputFileItems() [line 298]
       │    └─ Creates linked list of ALL scheduled files (sorted by directory)
       │
       └─> FOR LOOP over fileItem list [line 314]
            │
            └─> oneWholeFileProcessing(args, fileItem, &firstPass, ...) [xref.c:179]
                 ├─ SETS: inputFileName = fileItem->name [line 181]
                 │
                 └─> processInputFile(args, &firstPass, &atLeastOneProcessed) [xref.c:149]
                      │
                      ├─> initializeFileProcessing(args, nargs, &firstPass) [startup.c:490]
                      │    ├─ READS: fileName = inputFileName [line 502]
                      │    │
                      │    └─> computeAndOpenInputFile(inputFileName) [startup.c:112]
                      │         └─> initInput(inputFile, inputBuffer, "\n", fileName) [yylex.c]
                      │              └─ Sets currentFile.characterBuffer.fileNumber
                      │
                      ├─ SETS: parsingConfig.fileNumber = currentFileNumber [line 160]
                      │         (NOTE: currentFileNumber is DIFFERENT global!)
                      │
                      └─> parseToCreateReferences(inputFileName) [parsing.c:165]
                           ├─ Gets EditorBuffer using fileName parameter
                           │
                           ├─> initInput(NULL, buffer, "\n", fileName) [line 181]
                           │    └─ DUPLICATE call! Already called in initializeFileProcessing!
                           │
                           ├─ Calls setupParsingConfig(currentFile.characterBuffer.fileNumber) [line 183]
                           │
                           └─> callParser(parsingConfig.fileNumber, parsingConfig.language) [line 190]
----

==== LSP Mode Flow (New, Simplified)

[source]
----
parseToCreateReferences(fileName) [parsing.c:165]
  ├─ Takes fileName as PARAMETER (not from global!)
  ├─ Gets EditorBuffer
  │
  ├─> initInput(NULL, buffer, "\n", fileName) [line 181]
  │    └─ Sets currentFile.characterBuffer.fileNumber
  │
  ├─> setupParsingConfig(currentFile.characterBuffer.fileNumber) [line 183]
  │
  └─> callParser(parsingConfig.fileNumber, parsingConfig.language) [line 190]
----

==== Key Observations

*_Assignments to `inputFileName`_*

*Server Mode:* Set once per file processed

* `processFile()` line 205 - sets the file for the current request
* Special case: macro completion may parse a different file (line 189) to resolve symbols in unexpanded macro bodies

*Xref Mode:* Set ONCE per file

* `oneWholeFileProcessing()` line 181

*_`requestFileNumber` Only Used in Server Mode_*

* Set in `prepareInputFileForRequest()` (lines 104, 121)
* Used in `parseInputFile()` line 136: `setupParsingConfig(requestFileNumber)`
* NOT used in Xref mode at all

*_Confusion: THREE Different File Number Globals!_*

[source,c]
----
inputFileName           // The file name being processed
requestFileNumber       // Server: file number from scheduled file (server.c)
currentFileNumber       // Xref: file number after parsing starts (parsing.c:26)
----

In `xref.c` line 160:
[source,c]
----
parsingConfig.fileNumber = currentFileNumber;
----

But `currentFileNumber` is defined in `parsing.c:26`:
[source,c]
----
int currentFileNumber = -1;     /* Currently parsed file, maybe a header file */
----

The comment reveals the distinction: `currentFileNumber` can change DURING parsing when entering `#include` files, while `requestFileNumber` stays constant as "the file we were asked to process."

*_Double `initInput()` Call in Xref Mode_*

In Xref mode, `initInput()` is called TWICE for the same file:

1. First in `initializeFileProcessing()` → `computeAndOpenInputFile()` [`startup.c:128`]
2. Second in `parseToCreateReferences()` [`parsing.c:181`]

This appears to be a bug or wasteful duplication.

*_`initializeFileProcessing` is Heavy Orchestration_*

This 500-line function does five major phases:

* *Phase 1*: Project discovery (find `.c-xrefrc`)
* *Phase 2*: Options processing
* *Phase 3*: Compiler interrogation (expensive! runs `gcc -v`)
* *Phase 4*: Memory checkpointing (to skip Phase 3 for same-project files)
* *Phase 5*: Finally calls `computeAndOpenInputFile()` → `initInput()`

The `firstPass` parameter gates Phase 4's memory checkpoint save/restore.

*_Naming Inconsistency_*

* `inputFileName` - used in both Server and Xref modes, but set in different places
* `requestFileNumber` - only Server mode, represents the file from the request
* `currentFileNumber` - only Xref mode(?), set by `initInput()` after file opened

If they represent the same concept (the file being processed), they should have parallel names.

==== Summary: Multi-File vs Single-File Processing

*_Server Mode - Single File Per Request_*

* *Scheduling*: All files scheduled ONCE in `initServer()` → `processFileArguments()`
* *Processing*: Each request picks ONE file via `prepareInputFileForRequest()`
** Uses `getNextScheduledFile()` to get first scheduled file
** FLAWED: unschedules all higher-numbered files (works because `c-xref .` schedules all)
** Sets both `inputFileName` and `requestFileNumber`
* *Loop*: Infinite request loop in `server()` - different file per request

*_Xref Mode - All Files Per Invocation_*

* *Scheduling*: All files scheduled in `mainTaskEntryInitialisations()` → `processFileArguments()`
* *Additional*: In update mode, `scheduleModifiedFilesToUpdate()` adds modified files
* *Processing*: `createListOfInputFileItems()` creates list of ALL scheduled files
** Loops over entire list in `callXref()` [line 314]
** Each file processed via `oneWholeFileProcessing()`
** Sets `inputFileName` for each file
** Uses `currentFileNumber` (different global!) instead of `requestFileNumber`
* *Loop*: Single invocation processes all files

*_LSP Mode - Single File Per Request_*

* *No scheduling*: Takes fileName as direct parameter
* *No global state*: `parseToCreateReferences(fileName)` - clean interface
* *Processing*: Direct call, no file table lookup needed
* *Modern design*: Avoids the legacy scheduling/global state complexity

==== Opportunities for Alignment

The Server and Xref paths do similar things but with different names and structures, creating cognitive overhead. Potential improvements:

* *Naming consistency*: `processFile()` (server) vs `oneWholeFileProcessing()` (xref) could both use consistent naming
* *Eliminate duplication*: Fix the double `initInput()` call in xref path
* *Extract common logic*: The inner "process one file" logic should be identical between modes
* *Make differences explicit*:
** Server: `for (each request) { process one file }`
** Xref: `for (each scheduled file) { process one file }`

The paths are intertwined but different, making it hard to keep in your head which one you're modifying. Making them more similar where possible would reduce cognitive load during refactoring work.

=== Parsers

See the **Parsing** component in the <<08-components.adoc#,Components>> chapter.

=== Integrated Preprocessor

See the **Parsing** component's Internal Structure section in the <<08-components.adoc#,Components>> chapter.

=== Refactoring and the parsers

Some refactorings need more detailed information about the code, maybe all do?

One example, at least, is parameter manipulation.  Then the refactorer
calls the appropriate parser (`serverEditParseBuffer()`) which
collects information in the corresponding semantic actions.  This
information is stored in various global variables, like
`parameterBeginPosition`.

The parser is filling out a ParsedInfo structure which conveys
information that can be used e.g. when extracting functions etc.

NOTE: At this point I don't understand exactly how this interaction is
performed, there seems to be no way to parse only appropriate parts,
so the whole file need to be re-parsed.

Findings:

- some global variables are set as a result of command line
and arguments parsing, depending on which "command" the server is
acting on

- the semantic rules in the parser(s) contains code that matches these
  global variables and then inserts special lexems in the lexem stream

One example is how a Java 'move static method' was performed. It
requires a target position. That position is transferred from command
line options to global variables. When the Java parser was parsing a
class or similar it (or rather the lexer) looks at that "ddtarget
position information" and inserts a `OL_MARKER_TOKEN` in the stream.

NOTE: TODO: What extra "operation" the parsing should perform and return
data for should be packaged into some type of "command" or parameter
object that should be passed to the parser, rather than relying on
global variables.

=== Reading Files

Here are some speculations about how the complex file reading is structured.

Each file is identified by a filenumber, which is an index into the
file table, and seems to have a `lexBuffer` tied to it so that you can
just continue from where ever you were. That in turn contains a
`CharacterBuffer` that handles the actual character reading.

And there is also an "editorBuffer"...

The intricate interactions between these are hard to follow as the code
here are littered with short character names which are copies of fields
in the structures, and infested with many macros, probably in an ignorant
attempt at optimizing. ("The root of all evil is premature optimization" and
"Make it work, make it right, make it fast".)

It seems that everything start in `initInput()` in `yylex.c` where the
only existing call to `fillFileDescriptor()` is made. But you might
wonder why this function does some initial reading, this should be
pushed down to the buffers in the file descriptor.

==== Lexing/scanning

Lexing/scanning is performed in two layers, one in `lexer.c` which
seems to be doing the actual lexing into lexems which are put in a
lexembuffer. This contains a sequence of encoded and compressed
symbols which first has a `LexemCode` which is followed by extra data,
like `Position`. These seems to always be added but not always necessary.

The higher level "scanning" is performed, as per ususal,
by `yylex.c`. `lexembuffer` defines some functions to put and get
lexems, chars (identifiers and file names?) as well as integers and
positions.

At this point the put/get lexem functions take a pointer to a pointer
to chars (which presumably is the lexem stream in the lexembuffer)
which it also advances. This requires the caller to manage the
LexemBuffer's internal pointers outside and finally set them right
when done.

It would be much better to call the "putLexem()"-functions with a
lexemBuffer but there seems to be a few cases where the destination
(often `dd`) is not a lexem stream inside a lexemBuffer. These might
be related to macro handling.

NOTE: This is a work-in-progress.  Currently most of the "normal"
usages are prepared to use the LexemBuffer's pointers.  But the
handling of macros and defines are cases where the lexems are not put
in a LexemBuffer.  See the TODO.org for current status of this Mikado
sequence.

==== Semantic information

As the refactoring functions need some amount of semantic information,
in the sense of information gathered during parsing, this information
is collected in various ways when `c-xref` calls the "sub-task" to do
the parsing required.

Two structures hold information about various things, among which are
the memory index at certain points of the parsing. Thus it is possible
to verify e.g. that a editor region does not cover a break in block or
function structure. This structure is, at the point of writing, called
`parsedInfo` and definitely need to be tidied up.

=== Reference Database

See the **Cxref** component (in-memory reference tables and symbol resolution) and the **Cxfile** component (on-disk database format and reading) in the <<08-components.adoc#,Components>> chapter.

NOTE: A proposal for a unified symbol database architecture has been documented. See <<16-proposed-refactorings.adoc#unified-symbol-database,Proposed Unified Symbol Database>> in the Proposed Refactorings chapter.

=== Editor Plugin

The editor plugin has three different responsibilities:

- serve as the UI for the user when interacting with certain `c-xref`
  related functions

- query `c-xref server` for symbol references and support navigating
  these in the source

- initiate source code operations ("refactorings") and execute the
  resulting edits

Basically Emacs (and probably other editors) starts `c-xref` in
"server-mode" using `-server` which connects the editor
with `c-xref` through stdout/stdin. If you have `(setq
c-xref-debug-mode t)` this command is logged in the `\*Messages*` buffer
with the prefix "calling:".

Commands are sent from the editor to the server on its standard input.
They looks very much like normal command line options, and in fact
`c-xref` will parse that input in the same way using the same
code. When the editor sends an `end-of-options` line, the server will
start executing whatever was sent, and return some information in the
file given as an `-o` option when the editor starts the `c-xref`
server process. The file is named and created by the editor and
usually resides in `/tmp`. With `c-xref-debug-mode` set to on this is
logged as "sending:". If you `(setq c-xref-debug-preserve-tmp-files
t)` Emacs will also not delete the temporary files it creates so that
you can inspect them afterwards.

When the server has finished processing the command and placed the
output in the output file it sends a ``<sync>`` reply.

The editor can then pick up the result from the output file and do
what it needs to do with it ("dispatching:").

==== Invocations

The editor invokes a new `c-xref` process for the following cases:

- Refactoring
+
Each refactoring operation calls a new instance of `c-xref`?

- Create Project
+
When a `c-xref` function is executed in the editor and there is no
project covering that file, an interactive "create project" session is
started, which is run by a separate `c-xref` process.

==== Buffers

There is some magical editor buffer management happening inside of
`c-xref` which is not clear to me at this point. Basically it looks
like the editor-side tries to keep the server in sync with which
buffers are opened with what file...

At this point I suspect that `-preload <file1> <file2>` means that the
editor has saved a copy of `<file1>` in `<file2>` and requests the server
to set up a "buffer" describing that file and use it instead of the
`<file1>` that recides on disk.

This is essential when doing refactoring since the version of the file
most likely only exists in the editor, so the editor has to tell the
server the current content somehow, this is the `-preload` option.

=== Editor Server

When serving an editor the c-xrefactory application is divided into
the server, _c-xref_ and the editor part, at this point only Emacs:en
are supported so that's implemented in the
`editor/Emacs`-packages.


==== Interaction

The initial invocation of the edit server creates a process with which
communication is over stdin/stdout using a protocol which from the editor
is basically a version of the command line options.

When the editor has delivered all information to the server it sends
'end-of-option' as a command and the edit server processes whatever it
has and responds with ``<sync>`` which means that the editor can fetch
the result in the file it named as the output file using the '-o'
option.

NOTE: As long as the communication between the editor and the server
is open, the same output file will be used. This makes it hard to
catch some interactions, since an editor operation might result in
multiple interactions, and the output file is then re-used.

Setting the emacs variable `c-xref-debug-mode` forces the editor to
copy the content of such an output file to a separate temporary file
before re-using it.

For some interactions the editor starts a completely new and fresh
`c-xref` process, see below. And actually you can't do refactorings
using the server, they have to be separate calls. (Yes?) I have yet to
discover why this design choice was made.

NOTE: There are many things in the sources that handles refactorings
separately, such as `refactoring_options`, which is a separate copy of
the options structure used only when refactoring.


==== Protocol

Communication between the editor and the server is performed using
text through standard input/output to/from _c-xref_. The protocol is
defined in src/protocol.tc and must match `editor/emacs/c-xrefprotocol.el`.

The definition of the protocol only caters for the server->editor part,
the editor->server part consists of command lines resembling the command
line options and arguments, and actually is handled by the same code.

The file `protocol.tc` is included in `protocol.h` and `protocol.c`
which generates definitions and declarations for the elements through
using some macros.

There is a similar structure with _c-xrefprotocol.elt_ which
includes _protocol.tc_ to wrap the PROTOCOL_ITEMs into
``defvar``s.

There is also some Makefile trickery that ensures that the C and elisp
impementations are in sync.

One noteable detail of the protocol is that it carries strings in their native format,
utf-8. This means that lengths need to indicate _characters_ not bytes.


==== Invocation of server

The editor fires up a server and keeps talking over the established
channel (elisp function 'c-xref-start-server-process'). This probably
puts extra demands on the memory management in the server, since it
might need to handle multiple information sets and options (as read
from a .cxrefrc-file) for multiple projects simultaneously over a
longer period of time. (E.g. if the user enters the editor starting
with one project and then continues to work on another then new
project options need to be read, and new reference information be
generated, read and cached.)

NOTE: TODO: Figure out and describe how this works by looking at the
elisp-sources.

FINDINGS:

- c-xref-start-server-process in c-xref.el

- c-xref-send-data-to-running-process in c-xref.el

- c-xref-server-call-refactoring-task in c-xref.el


==== Communication Protocol

The editor server is started using the appropriate command line option
and then it keeps the communication over stdin/stdout open.

The editor part sends command line options to the server, which looks
something like (from the read_xrefs test case):

    -encoding=european -olcxpush -urldirect  "-preload" "<file>" "-olmark=0" "-olcursor=6" "<file>" -xrefrc ".c-xrefrc" -p "<project>"
    end-of-options

In this case the "-olcxpush" is the operative command which results in
the following output

    <goto>
     <position-lc line=1 col=4 len=66>CURDIR/single_int1.c</position-lc>
    </goto>

As we can see from this interaction, the server will handle (all?)
input as a command line and manage the options as if it was a command
line invocation.

This explains the intricate interactions between the main program and
the option handling.

The reason behind this might be that a user of the editor might be
editing files on multiple projects at once, so every
interrogation/operation needs to clearly set the context of that
operation, which is what a user would do with the command line
options.


==== OLCX Naming

It seems that all on-line editing server functions have an `olcx`
prefix, "On-Line C-Xrefactory", maybe...



=== Refactoring

See the **Refactory** and **Extract** components in the <<08-components.adoc#,Components>> chapter for the architecture and operation flow.

==== Refactoring Protocol Details

The refactoring protocol messages exchanged between the refactory process and the editor:

*_Rename Example_*

*Invocation:* `-rfct-rename -renameto=NEW_NAME -olcursor=POSITION FILE`

*Result:* A sequence of precheck/replacement pairs:
```
<goto>
 <position-off off=POSITION len=N>FILE</position-off>
</goto>
<precheck len=N>STRING</precheck>
```
followed by:
```
<goto>
 <position-off off=POSITION len=N>FILE</position-off>
</goto>
<replacement>
 <str len=N>ORIGINAL</str>  <str len=N>REPLACEMENT</str>
</replacement>
```

*_Extraction Example_*

Extraction (`-rfct-extract-function`) returns an `<extraction-dialog>` with three `<str>` parts: the call site replacement, the text to insert before the region (function header), and the text to insert after (closing brace). The editor applies these and then initiates a rename for the new function name.

*_Protocol Messages_*

`<goto>{position-off}</goto>`:: Move cursor to the indicated position.
`<precheck len={int}>{string}</precheck>`:: Verify that the text under the cursor matches the string.
`<replacement>{str}{str}</replacement>`:: Replace string1 under cursor with string2.
`<position-off off={int} len={int}>{path}</position-off>`:: Position in file ('off' is character offset).

=== Memory handling

c-xrefactory uses custom memory management via arena allocators rather than malloc/free for performance-critical operations.

See the **Components** chapter for the design and architecture of the Memory module, and the **Data Structures** chapter for details on the arena allocator data structure and allocation model.

For debugging memory issues, especially arena lifetime violations, see the **Development Environment** chapter.

==== The Memory Type

Memory allocation is managed through the `Memory` structure, which implements an arena/bump allocator. Different memory arenas serve different purposes:

* `cxMemory` - Cross-reference database (with overflow handling)
* `ppmMemory` - Preprocessor macro expansion
* `macroBodyMemory` - Macro definition storage
* `macroArgumentsMemory` - Macro argument expansion
* `fileTableMemory` - File table entries

See **Components** chapter for detailed description of each arena's purpose and lifetime.

==== Option Memory

The `optMemory` arena requires special handling because `Options` structures are copied during operation. When copying, all pointers into option memory must be adjusted to point into the target structure's memory area, not the source's.

Functions like `copyOptions()` perform this pointer adjustment through careful memory arithmetic, traversing a linked list of all memory locations that need updating.

NOTE: The linked list nodes themselves are allocated in the Options structure's dynamic memory.


=== Configuration

The legacy `c-xref` normally, in "production", uses a common configuration file in the
users home directory, `.c-xrefrc`. When a new project is defined its options will be
stored in this file as a new section.

It is possible to point to a specific configuration file using the command line option
`-xrefrc` which is used extensively in the tests to isolate them from the users
configuration.

Each "project" or "section" requires a name of the "project", which is the argument to
the `-p` command line option. And it may contain most other command line options on one
line each. These are always read, unless `-no-stdop` is used, before anything else. This
allows for different "default" options for each project.

==== Options

There are three possible sources for options.

- Configuration files (~/.c-xrefrc)
- Command line options at invocation, including server
- Piped options sent to the server in commands

Not all options are relevant in all cases.

All options sources uses exactly the same format so that the same code for decoding them can be used.

==== Logic

When the editor has a file open it needs to "belong" to a project. The
logic for finding which is very intricate and complicated.

In this code there is also checks for things like if the file is
already in the index, if the configuration file has changed since last
time, indicating there are scenarios that are more complicated (the
server, obviously).

But I also think this code should be simplified a lot.
