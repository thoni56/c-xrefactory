== Refactoring Recipes

This chapter documents mechanical steps for refactoring operations. Each recipe describes the algorithmic steps that an automated refactoring tool would perform.

For detailed discussions of refactoring feature architecture and implementation phases, see link:16a-planned-refactorings.adoc[Chapter 16a: Planned Refactoring Features].

=== Existing Refactorings

Refactorings that are already implemented and available.

==== Rename Symbol

Implemented. TBD.

==== Extract Function

Implemented. TBD.

==== Reorder Parameters

Implemented. TBD.

==== Make Function Static

**Purpose:** Convert functions that are only used within their compilation unit to `static` storage class for better encapsulation and compiler optimization.

**When to use:**

- Function has external linkage but no external callers
- Want to make implementation details explicit
- Enable compiler optimizations and reduce global namespace pollution

**Input:**

- Non-static function definition
- All references to that function

**Availability:**

When cursor is on a non-static function definition where all callers are in the same file.

**Algorithm:**

1. **Check current storage class** - Skip if already `static`

2. **Find definition and all references**
   - Locate function definition (not declarations)
   - Collect all call sites across project

3. **Verify all references are local**
   - For each reference (excluding definition itself):
     * Check if in same file as definition
     * If any reference is in different file, abort
   - Check if declared in header files (public API), abort if yes

4. **Apply transformation**
   - Find beginning of function definition
   - Insert "static " before return type

**Output:**

- Function marked as `static`
- Compiler can optimize more aggressively
- Clear signal that function is internal

**Example:**

```c
// Before - helper function with external linkage
int helperCompare(const void *a, const void *b) {
    return *(int*)a - *(int*)b;
}

void publicSort(int *array, size_t n) {
    qsort(array, n, sizeof(int), helperCompare);
}

// After - explicitly internal
static int helperCompare(const void *a, const void *b) {
    return *(int*)a - *(int*)b;
}

void publicSort(int *array, size_t n) {
    qsort(array, n, sizeof(int), helperCompare);
}
```

**Benefits:**

- Better encapsulation and code clarity
- Enables inlining and other compiler optimizations
- Smaller symbol tables, no name collisions
- Safe to refactor (can't break external code)

**Notes:**

- Similar to "Unused Symbols" detection but finds LOCAL-ONLY usage instead of NO usage
- Cannot handle functions used via function pointers passed externally (requires manual verification)

=== Suggested Refactorings

Refactorings that have been proposed, designed, or partially implemented but are not yet available.

==== Move Type to New File

**Input:**

- Type name to move
- Source file containing type definition
- Target file (new or existing)

**Algorithm:**

1. **Availability**

   - Available when the selected symbol is a type, that symbol is the type to move

2. **Identify dependencies**

   - Determine what types/macros the definition references/uses

3. **Create/update target file:**

   - If new file: create with include guards and appropriate includes/forward declarations
   - If existing: open the file and find a suitable insertion location

4. **Move definition**

   - Copy type definition to target file
   - Add necessary includes and forward declarations

5. **Replace in source file:**

   - If target is new file: Replace type definition with `#include "targetfile.h"`
   - If target is existing file: Remove type definition, add `#include "targetfile.h"` if not already present in the source file

**Output:**

- Type definition moved to target file
- Source file includes the target file
- Clean compilation

**Notes:**

- For new header files, steps 3-5 are particularly simple: create the new header with the type and replace the definition in source with an include
- For existing headers, must check if include is already present before adding
- Forward declarations (e.g., `struct foo;`) are sufficient for pointer-only dependencies
- Full type definitions or includes needed for non-pointer members

---

=== Introduce Semantic Type Aliases

**Purpose:** Make implicit semantic distinctions explicit by introducing type aliases for a single struct used for multiple purposes.

**When to use:**

- A single struct/type is reused for semantically different purposes
- Different usage contexts use different subsets of fields
- Want to clarify intent without changing implementation
- Want to prepare for future type divergence

**Input:**

- Original type name (e.g., `OlcxReferencesStack`)
- List of semantic contexts where type is used (e.g., "browser", "completion", "retrieval")
- Target file for type aliases (new or existing header)

**Algorithm:**

1. **Analyze usage patterns** - Identify distinct semantic contexts where type is used
   - Group usage sites by purpose/domain
   - Note which fields are used in each context
   - Verify that contexts are truly semantically different

2. **Create type aliases** - In appropriate header file, define semantic aliases:
   ```c
   typedef OriginalType SemanticName1;
   typedef OriginalType SemanticName2;
   // etc.
   ```

3. **Update structure declarations** - Change struct/variable declarations to use semantic types:
   - Data structure fields
   - Global variables
   - Static variables

4. **Update function signatures** - Change function parameters to use semantic types:
   - Functions operating on specific context → specific alias
   - Generic functions operating on any context → generic alias (if created)

5. **Update call sites** - Verify all usages compile with new types

6. **Verify** - Compile to ensure type compatibility

**Output:**

- Multiple type aliases for same underlying type
- Declarations and signatures use semantic types
- Intent clarified through type system
- Foundation for future divergence

**Example:**

Given a "kitchen sink" struct used for three purposes:

```c
// Before - single type for everything
typedef struct OlcxReferencesStack {
    OlcxReferences *top;
    OlcxReferences *root;
} OlcxReferencesStack;

typedef struct SessionData {
    OlcxReferencesStack browserStack;      // Uses: references, symbolsMenu
    OlcxReferencesStack completionsStack;  // Uses: completions
    OlcxReferencesStack retrieverStack;    // Uses: completions
} SessionData;

void pushEmptySession(OlcxReferencesStack *stack);  // Generic
```

After introducing semantic aliases:

```c
// After - semantic aliases make intent clear
typedef struct OlcxReferencesStack {
    OlcxReferences *top;
    OlcxReferences *root;
} OlcxReferencesStack;

// Semantic aliases
typedef OlcxReferencesStack ReferencesStack;   // Generic
typedef OlcxReferencesStack BrowserStack;      // For navigation
typedef OlcxReferencesStack CompletionStack;   // For completion
typedef OlcxReferencesStack RetrieverStack;    // For search

typedef struct SessionData {
    BrowserStack    browserStack;
    CompletionStack completionsStack;
    RetrieverStack  retrieverStack;
} SessionData;

void pushEmptySession(ReferencesStack *stack);  // Generic operation
```

**Benefits:**

- Intent is immediately clear from type names
- No runtime or ABI changes (aliases compile to same type)
- Can add domain-specific operations per type later
- Enables gradual migration toward separate types if needed

**Notes:**

- Particularly useful in C where classes/interfaces are unavailable
- Type aliases are compile-time only - no runtime overhead
- Can coexist with original type name during migration
- Common pattern when refactoring legacy C code

---

==== Rename Included File

**Purpose:** Rename a file appearing in an include and update all the include directives

**When to use:**

- A (header) file is inappropriately named
- In the process of renaming a complete C "module" this is one step (until `c-xrefactory` can do all of that)

**Input:**

- The old and new file names
- All `#include` locations for the old file

**Availability**

When the cursor is on an `#include` directive. The file it references will be the "source".

**Algorithm:**

1. **Rename the source file to the destination**

2. **Update all include locations**
   - This will often include multiple locations

**Output:**

- New header file
- All `#include` directives updated

---

==== Move Function to Different File

See link:16a-planned-refactorings.adoc[Chapter 16a: Planned Refactoring Features] for detailed design and implementation status.

Proposed refactoring to move a function definition from one C source file to another while automatically managing visibility (static vs extern) and potentially adding necessary declarations and includes.

**Status**: Phase 1 MVP complete.

---

==== Turn include guard into pragma once

Tentative.

---

==== Change return type

Tentative.

**Purpose:** Convert functions that are only used within their compilation unit to `static` storage class for better encapsulation and compiler optimization.

**When to use:**

- Function has external linkage but no external callers
- Want to make implementation details explicit
- Enable compiler optimizations and reduce global namespace pollution

**Input:**

- Non-static function definition
- All references to that function

**Availability:**

When cursor is on a non-static function definition where all callers are in the same file.

**Algorithm:**

1. **Check current storage class** - Skip if already `static`

2. **Find definition and all references**
   - Locate function definition (not declarations)
   - Collect all call sites across project

3. **Verify all references are local**
   - For each reference (excluding definition itself):
     * Check if in same file as definition
     * If any reference is in different file, abort
   - Check if declared in header files (public API), abort if yes

4. **Apply transformation**
   - Find beginning of function definition
   - Insert "static " before return type

**Output:**

- Function marked as `static`
- Compiler can optimize more aggressively
- Clear signal that function is internal

**Example:**

```c
// Before - helper function with external linkage
int helperCompare(const void *a, const void *b) {
    return *(int*)a - *(int*)b;
}

void publicSort(int *array, size_t n) {
    qsort(array, n, sizeof(int), helperCompare);
}

// After - explicitly internal
static int helperCompare(const void *a, const void *b) {
    return *(int*)a - *(int*)b;
}

void publicSort(int *array, size_t n) {
    qsort(array, n, sizeof(int), helperCompare);
}
```

**Benefits:**

- Better encapsulation and code clarity
- Enables inlining and other compiler optimizations  
- Smaller symbol tables, no name collisions
- Safe to refactor (can't break external code)

**Notes:**

- Similar to "Unused Symbols" detection but finds LOCAL-ONLY usage instead of NO usage
- Cannot handle functions used via function pointers passed externally (requires manual verification)
- Estimated complexity: ~0.3× Move Function Phase 1

