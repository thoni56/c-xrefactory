/*
	$Revision: 1.11 $
	$Date: 2002/08/22 14:22:19 $
*/

#include "stdinc.h"
#include "head.h"
#include "proto.h"      /*SBD*/
#include "protocol.h"
//

#define HTML_EMPTY_REF_FILE "/XrefEmptyRefs.html"

#define EXTERN_JDOC_AVAILABLE(refItem) (\
	LANGUAGE(LAN_JAVA) \
	&& s_opt.htmlGenJdkDocLinks \
	&& (s_opt.htmlJdkDocUrl!=NULL || s_opt.javaDocPath!=NULL) \
	&& htmlJdkDocAvailable(refItem) \
)

#define GENERATE_FRAMES() ((s_opt.htmlglobalx || s_opt.htmllocalx))

#define HTML_COLOR_LARGE_TAB_HEAD "#c0d0ff"
#define HTML_COLOR_SMALL_TAB_HEAD "#c0d0ff"
#define HTML_COLOR_CLASS_TREE "#ffffcc"

#define HTML_PUTCH_REF_TABULATOR 1
#define HTML_PUTCH_REF_TABN 6

static char s_htmlEmptyRefs[MAX_FILE_NAME_SIZE];
static S_olSymbolsMenu *s_htmlCurrentCxlist;
static char *s_cxGlobalReferencesBase;

#if defined(__WIN32__) || defined (__OS2__)		/*SBD*/
char *htmlNormalizedPath(char *p) {
	if (p[0]!=0 && p[1]==':') return(p+2);
	return(p);
}
#else							/*SBD*/
char *htmlNormalizedPath(char *p) {
	return(p);
}
#endif							/*SBD*/

#if defined(__WIN32__) || defined (__OS2__)		/*SBD*/
int isAbsolutePath(char *p) {
	if (p[0]!=0 && p[1]==':' && p[2]==SLASH) return(1);
	if (p[0]==SLASH) return(1);
	return(0);
}
#else							/*SBD*/
int isAbsolutePath(char *p) {
	return(p[0]==SLASH);
}
#endif							/*SBD*/

static char *cutHtmlPath(char *path) {
	char *pp,*cutp;
	int i,m,cutpl;
	pp = htmlNormalizedPath(path);
	m = s_opt.htmlCut.pathesNum;
	for(i=0; i<m; i++) {
		cutp = s_opt.htmlCut.path[i];
		cutpl = s_opt.htmlCut.plen[i];
		if (fnnCmp(pp, cutp, cutpl)==0) return(pp+cutpl);
	}
	return(pp);
}

static void htmlCompressFile(char *fname) {
	char sss[MAX_HTML_REF_LEN];
	char *s;
	int len1;
	if (s_opt.htmlZipCommand == NULL) return;
	s = strchr(s_opt.htmlZipCommand, '!');
	if (s==NULL) {
		static int message=1;
		if (message) error(ERR_ST,"missing the ! meta-char in the zip command");
		message = 0;
		return;
	}
	len1 = s-s_opt.htmlZipCommand;
	strncpy(sss, s_opt.htmlZipCommand, len1);
	strcpy(sss+len1, fname);
	strcat(sss, s+1);
	InternalCheck(strlen(sss) < MAX_HTML_REF_LEN-2);
	system(sss);
}

char *htmlGetLinkFileNameStatic(char *link, char *file) {
	static char fn[MAX_FILE_NAME_SIZE];
	char *p1,*p2,*ls1,*ls2,*resp, *ls;
/*&fprintf(dumpOut,"getting relative of '%s'  '%s'\n",link,file);fflush(dumpOut);&*/
	p1=ls1=htmlNormalizedPath(file);
	p2=ls2=htmlNormalizedPath(getRealFileNameStatic(link));
	p1=ls1=cutHtmlPath(p1);
	p2=ls2=cutHtmlPath(p2);
	for(; *p1 && *p1==*p2; p1++,p2++) {
		if (*p1 == SLASH) {ls1=p1+1; ls2=p2+1;}
	}
//&	if (*p1==0 && *p2==0) return("");
	resp = fn;
	for(; *p1; p1++) {
		if (*p1 == SLASH) {
			sprintf(resp,"..%c",HTML_SLASH); resp+=3;
			InternalCheck(resp-fn < MAX_FILE_NAME_SIZE-2);
		}
	}
	strcpy(resp,ls2);
	ls = resp;
	while ((ls=strchr(ls+1, SLASH))!=NULL) *ls = HTML_SLASH;
	InternalCheck(resp-fn < MAX_FILE_NAME_SIZE-2);
/*&fprintf(dumpOut,"result is '%s'\n",fn);fflush(dumpOut);&*/
	return(fn);
}

static char *htmlCutLastSuffixStatic(char *fname) {
	static char res[MAX_FILE_NAME_SIZE];
	char *dd,*ld;
	if (! s_opt.htmlCutSuffix) return(fname);
	strcpy(res, fname);
	dd = ld = res;
	dd = strchr(dd, '.');
	while (dd) {
		ld = dd; 
		dd = strchr(dd+1, '.');
	}
	if (ld != res) *ld = 0;
	return(res);
}

static void htmlGenLogo() {
	fprintf(ccOut,"<p><font size=-1><center>\n");
	fprintf(ccOut, "Html form generated by ");
	if (JAVA2HTML()) {
	  fprintf(ccOut, "<A HREF=\"http://www.xref-tech.com/java2html/\" target=\"_top\">");
	  fprintf(ccOut,"<B>Xref-Java2Html</B></A> version 1.4.0 ");
	} else {
	  fprintf(ccOut, "<A HREF=\"http://www.xref-tech.com/c-xrefactory/\" target=\"_top\">");
	  fprintf(ccOut,"<B>C-xrefactory</B></A>");
	  fprintf(ccOut," version %s ",C_XREF_VERSION_NUMBER);
	}
	fprintf(ccOut," on %s\n", ctime(&s_fileProcessStartTime));
#if ZERO
#if defined(BIN_RELEASE)
	if (! JAVA2HTML()) {
		setExpirationFromLicenseString();
		if (s_expTime!=((time_t)-1)) {
			fprintf(ccOut,"<br>Trial version.");
//&		    fprintf(ccOut,"<br>Trial version licensed until %s",ctime(&s_expTime));
		}
	}
#elif defined(TIME_LIMITED)
	{ 
		time_t t = EXPIRATION;
		fprintf(ccOut,"<br>Trial version.");
//&		fprintf(ccOut,"<br>Trial version licensed until %s", ctime(&t));
	}
#endif
#endif
	fprintf(ccOut,"</center></font><p>\n");
}

static char *htmlAuxFileNameStatic(int fnum, char *subdir, 
								char *suff1, char *suff2) {
	static char res[MAX_FILE_NAME_SIZE];
	char *fn,*fd;
	int n;
	assert(s_fileTab.tab[fnum]);
	fn = s_fileTab.tab[fnum]->name;
	fn = getRealFileNameStatic(fn);
	fn = cutHtmlPath(fn);
	fd = lastOccurenceOfSlashOrAntiSlash(fn);
	n = fd - fn;
	strncpy(res, fn, n);
	sprintf(res+n,"%c%s%s%s%s",SLASH,subdir,fd,suff1,suff2);
	InternalCheck(strlen(res)<MAX_FILE_NAME_SIZE-1);
	return(res);
}

static void htmlGenHead(int fn) {
	char *fname,*de,*ss0,*ss,*cutfn;
	int i,ch,sn,cutFlag;
	cutFlag = 0;
	assert(s_fileTab.tab[fn]);
	fname = getRealFileNameStatic(s_fileTab.tab[fn]->name);
	cutfn = cutHtmlPath(fname);
	if (cutfn != fname) cutFlag = 1;
	fprintf(ccOut,"<HTML><HEAD><TITLE>%s</TITLE>\n",fname);
	if (s_opt.htmlNoUnderline) {
		fprintf(ccOut,"<STYLE TYPE=\"text/css\">\n");
		fprintf(ccOut,"<!-- A:link{text-decoration: none}\n");
		fprintf(ccOut,"A:visited{text-decoration: none}\n");
		fprintf(ccOut,"A:active{text-decoration: none} -->\n");
		fprintf(ccOut,"</STYLE>\n");
	}
	fprintf(ccOut,"</HEAD>\n");
	fprintf(ccOut,"<body topmargin=\"0\" leftmargin=\"0\"");
	fprintf(ccOut,"bgcolor=\"#FFFFFF\"\n");
	fprintf(ccOut,"link=\"%s\" vlink=\"%s\" alink=\"red\">\n",
			s_opt.htmlLinkColor, s_opt.htmlLinkColor);
	fprintf(ccOut,"<center>");
	if (GENERATE_FRAMES()) {
		fprintf(ccOut,"<font size=-1>");
		fprintf(ccOut,"<A HREF=\"XFRM%c%s.frm.html%s\" ",
						HTML_SLASH, simpleFileName(fname),s_opt.htmlLinkSuffix);
//		fprintf(ccOut,"target=\"_top\"");
		fprintf(ccOut,">");
		fprintf(ccOut,"Create Xref-Html Frames</A>");
		for(i=0; i<10; i++) fprintf(ccOut,"&nbsp; ");
		fprintf(ccOut,"<A HREF=\"%s.html%s\" target=\"_top\">",
				htmlCutLastSuffixStatic(simpleFileName(fname)),
				s_opt.htmlLinkSuffix);
		fprintf(ccOut,"Remove All Frames</A>");
		fprintf(ccOut,"</font>");
		fprintf(ccOut,"<hr>");
	}
	fprintf(ccOut,"file:<B>");
	sn = 0;
	for(i=0; fname[i]; i++) if (fname[i]==SLASH) sn++;
	ss0 = fname;
	while (sn > 0) {
		for(ss=ss0; *ss && *ss!=SLASH; ss++) ;
		assert(*ss);
		ch = *ss; *ss = 0;
		if (cutFlag && ss0<cutfn) {
			fprintf(ccOut,"%s/", ss0);
		} else {
			fprintf(ccOut,"<A HREF=\".%c",HTML_SLASH);
			for(i=1; i<sn; i++) fprintf(ccOut,"..%c",HTML_SLASH);
			fprintf(ccOut,"\">%s</A>/", ss0);
		}
		*ss = ch;
		ss0 = ss+1;
		sn--;
	}
	fprintf(ccOut,"%s",ss0);
	fprintf(ccOut,"</B>");
	fprintf(ccOut," &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(%s) ",
			ctime(&s_fileTab.tab[fn]->lastModif));
	fprintf(ccOut,"</center>");
	fprintf(ccOut,"<hr>\n");
	fprintf(ccOut,"<pre>\n");
}

static void htmlGenTail() {
  int i;
  for(i=0;i<40;i++) fprintf(ccOut,"\n");
	fprintf(ccOut,"</pre>\n");
	fprintf(ccOut,"<hr>\n");
	htmlGenLogo();
	fprintf(ccOut,"</BODY></HTML>\n");
}

static void htmlGenAlphaHashLink( FILE *ff, int fi, int i, char *cc) {
  if (i == fi) {
	fprintf(ff, "%s ",cc);
  } else {
	fprintf(ff,"<A HREF=\"X%04d.html%s\" target=\"packageFrame\">%s</A> ",
			i, s_opt.htmlLinkSuffix,cc);
  }
}


static void htmlGenRefListFileHeadAlphaRefs(FILE *ff, int fi) {
  int i, thisletter, thisindex, ll;
  char tt[10];
  if (s_opt.xfileHashingMethod==XFILE_HASH_ALPHA1) {
	ll = fi + 'A';
	if (ll>'Z') ll='+';
	fprintf(ff,"<center><h3>%c</h3>", ll);
	fprintf(ff,"<pre>\n");
	for(i=0; i<='Z'-'A'; i++) {
	  if (i== 13) fprintf(ff,"\n");
	  sprintf(tt,"%c",i+'A');
	  htmlGenAlphaHashLink( ff, fi, i, tt);
	}
	htmlGenAlphaHashLink( ff, fi, i, "+");
	fprintf(ff,"\n");
	fprintf(ff,"</pre></center>\n");
  } else if (s_opt.xfileHashingMethod==XFILE_HASH_ALPHA2) {
	thisindex = fi / XFILE_HASH_ALPHA1_REFNUM;
	thisletter = thisindex+'A';
	if (thisletter > 'Z') thisletter = '+';
	ll = fi%XFILE_HASH_ALPHA1_REFNUM + 'A';
	if (ll>'Z') ll='+';
	fprintf(ff,"<center><h3>%c%c</h3>", thisletter, ll);
	fprintf(ff,"<pre>\n");
	for(i=0; i<='Z'-'A'; i++) {
	  if (i== 13) fprintf(ff,"\n");
	  sprintf(tt,"%c",i+'A');
	  htmlGenAlphaHashLink( ff, fi, i*XFILE_HASH_ALPHA1_REFNUM, tt);
	}
	htmlGenAlphaHashLink( ff, fi, i*XFILE_HASH_ALPHA1_REFNUM, "+");
	fprintf(ff,"\n\n");
	for(i=0; i<='Z'-'A'; i++) {
	  if (i== 13) fprintf(ff,"\n");
	  sprintf(tt,"%c%c", thisletter, i+'A');
	  htmlGenAlphaHashLink( ff, fi, thisindex*XFILE_HASH_ALPHA1_REFNUM+i, tt);
	}
	sprintf(tt,"%c+", thisletter);
	htmlGenAlphaHashLink( ff, fi, thisindex*XFILE_HASH_ALPHA1_REFNUM+i, tt);
	fprintf(ff,"\n");
	fprintf(ff,"</pre></center>\n");
  }
}

static void htmlGenRefListFileHead(FILE *ff, int fi) {
	fprintf(ff,"<HTML><HEAD><TITLE>Reflist</TITLE></HEAD>\n");
	fprintf(ff,"<base target=\"classFrame\">\n");
	fprintf(ff,"<body topmargin=\"0\" leftmargin=\"0\"");
	fprintf(ff,"bgcolor=\"#FFFFFF\"\n");
	fprintf(ff,"link=\"navy\" vlink=\"navy\" alink=\"red\">\n");
	if (fi < 0) {
		fprintf(ff,"<center><H3>Local&nbsp;Cross&nbsp;References</H3></center>\n");
	} else {
		fprintf(ff,"<center><H3>Cross&nbsp;References</H3></center>\n");
		if (s_opt.xfileHashingMethod==XFILE_HASH_DEFAULT) {
		  fprintf(ff,"<pre>\n");
		  if (fi>0) {
			fprintf(ff,"<A HREF=\"X%04d.html%s\" target=\"packageFrame\">prev</A>",fi-1, s_opt.htmlLinkSuffix);
		  } else {
			fprintf(ff,"    ",fi-1);
		  }
		  fprintf(ff," X%04d ",fi);
		  if (fi<s_opt.refnum-1) {
			fprintf(ff,"<A HREF=\"X%04d.html%s\" target=\"packageFrame\">next</A>",fi+1, s_opt.htmlLinkSuffix);
			fprintf(ff,"</pre>\n");
		  }
		} else {
		  htmlGenRefListFileHeadAlphaRefs(ff, fi);
		}
	}
}

static void htmlSymbolCxTableBeg(FILE *ff) {
	fprintf(ff, "<table border=1 cellpadding=\"7\" cellspacing=\"0\" width=\"400\">\n");
}

static void htmlVirtualTableSymName(FILE *ff,S_olSymbolsMenu *rrr,char *color){
	char 			ln[MAX_HTML_REF_LEN];
	fprintf(ff, "<tr><td bgcolor=\"%s\">\n", color);
	fprintf(ff, "<font FACE=\"arial,helvetica\">\n");
	if ((rrr->s.b.accessFlags&ACC_STATIC) && rrr->s.b.storage!=StorageField){
		fprintf(ff, "static ");
	}
	linkNamePrettyPrint(ln, rrr->s.name, MAX_HTML_REF_LEN,SHORT_NAME);
	fprintf(ff, "<B>%s</B>\n", ln);
	fprintf(ff, "</font></td></tr>\n");
}

static void  htmlSymbolCxTableEnd(FILE *ff) {
	fprintf(ff, "</table>");
}

static void htmlGenSmallTabHead( FILE *ff, char *color, int genFlag) {
	if (genFlag!=SINGLE_VIRT_ITEM) {
		fprintf(ff,"<tr><td bgcolor=\"%s\">", color);
		fprintf(ff,"<font FACE=\"arial,helvetica\">\n");
	}
}

static void htmlGenSmallTabTail( FILE *ff, int genFlag ) {
	if (genFlag!=SINGLE_VIRT_ITEM) {
		fprintf(ff,"</font></td></tr>\n");
	}
}

static void htmlGenRefListItemHead(FILE *ff, char *ln, char *symName,
								   S_symbolRefItem *p, int usage, int genFlag){
	char	ttt[TMP_STRING_SIZE];
	char	*s,*sn,*snn,*d,*ld,*apc;
	int 	i,len;
	sn = symName;
	if (p!=NULL && p->b.symType==TypeCppInclude) {
		htmlGenSmallTabHead( ff, HTML_COLOR_SMALL_TAB_HEAD, genFlag);
		fprintf(ff,"<A NAME=\"%s\"></A>",ln);
		sn = s_fileTab.tab[p->vApplClass]->name; 
		sn = simpleFileName(getRealFileNameStatic(sn));
		fprintf(ff,"(#include)&nbsp;<B>%s</B>",sn);
		htmlGenSmallTabTail( ff, genFlag);
	} else if (p!=NULL && p->b.symType==TypeCppCollate) {
		htmlGenSmallTabHead( ff, HTML_COLOR_SMALL_TAB_HEAD, genFlag);
		fprintf(ff,"<A NAME=\"%s\"></A>",ln);
		fprintf(ff,"(##)&nbsp;<B>%s</B>",sn);
		htmlGenSmallTabTail( ff, genFlag);
	} else if (p!=NULL && 
			   (p->b.storage==StorageField 
				|| p->b.storage==StorageMethod
				|| p->b.storage==StorageConstructor)) {
		assert(genFlag==SINGLE_VIRT_ITEM || genFlag==VIRT_ITEM);
		//javaGetClassNameFromFileNum(p->vFunClass,ttt);
		apc =  javaGetNudePreTypeName_st(getRealFileNameStatic(
			s_fileTab.tab[p->vFunClass]->name), s_opt.nestedClassDisplaying);
		if (genFlag == SINGLE_VIRT_ITEM) {
			fprintf(ff,"<A NAME=\"%s\"></A>",ln);
		} else {
			htmlGenSmallTabHead( ff, HTML_COLOR_SMALL_TAB_HEAD, genFlag);
			fprintf(ff,"<A NAME=\"%s.rf\"></A>",ln);
			fprintf(ff,"<B>%s</B>&nbsp;of&nbsp;%s", sn, apc);
			if (p->b.storage!=StorageField 
				&& (p->b.accessFlags&ACC_STATIC)==0) {
				apc =  javaGetNudePreTypeName_st(getRealFileNameStatic(
					s_fileTab.tab[p->vApplClass]->name), s_opt.nestedClassDisplaying);
				fprintf(ff,"<br>at <B>%s</B>", apc);
			}
			htmlGenSmallTabTail( ff, genFlag);
		}
	} else if (p!=NULL) {
		htmlGenSmallTabHead( ff, HTML_COLOR_SMALL_TAB_HEAD, genFlag);
		fprintf(ff,"<A NAME=\"%s\"></A>",ln);
		if (p->b.symType==TypeStruct && LANGUAGE(LAN_JAVA)) {
			if (p->b.accessFlags & ACC_INTERFACE) {
				fprintf(ff,"interface&nbsp;");
			} else {
				fprintf(ff,"class&nbsp;");
			}
		} else if (p->b.symType==TypeDefault && p->b.storage==StorageTypedef) {
			fprintf(ff,"typedef&nbsp;");
		} else if (p->b.symType!=TypeDefault) {
			fprintf(ff,"%s&nbsp;", typesName[p->b.symType]);
		}
		ld = sn;
		while ((d=strchr(ld, '.'))!=NULL) ld = d+1;
		if (LANGUAGE(LAN_JAVA)) {
			while ((d=strchr(ld, '$'))!=NULL) ld = d+1;
		}
		fprintf(ff,"<B>%s</B>",ld);
		htmlGenSmallTabTail(ff, genFlag);
		if (ld!=sn) {
			// nested something
			htmlGenSmallTabHead(ff, HTML_COLOR_CLASS_TREE, genFlag);
			//&fprintf(ff, "of <em>");
			for(s=sn; s<ld-1; s++) fputc(*s, ff);
			//&fprintf(ff,"</em>");
			htmlGenSmallTabTail( ff, genFlag);
		}
	} else {
		htmlGenSmallTabHead( ff, HTML_COLOR_SMALL_TAB_HEAD, genFlag);
		fprintf(ff,"<A NAME=\"%s\"></A>",ln);
		fprintf(ff,"<B>%s</B>",sn);
		htmlGenSmallTabTail( ff, genFlag);
	}
}

static void htmlGenRefListTail(FILE *ff) {
	int i;
	fprintf(ff,"\n");
	for(i=0; i<30; i++) fprintf(ff,"<br>");
	fprintf(ff,"\n</BODY></HTML>\n");
}

static char * getDefaultCxFileStatic() {
	static char ttt[MAX_FILE_NAME_SIZE];
	char tt[MAX_FILE_NAME_SIZE];
	char *ss;
	if (s_opt.refnum <= 1) {
		sprintf(tt,"%s.html", s_opt.cxrefFileName);
	} else {
		sprintf(tt,"%s%s%04d.html", 
				normalizeFileName(s_opt.cxrefFileName,s_cwd),
				PRF_REF_PREFIX, 0);
	}
	ss = cutHtmlPath(tt);
	concatPathes(ttt,MAX_FILE_NAME_SIZE,
				s_opt.htmlRoot, 
				cutHtmlPath(tt),
				"");
	return(ttt);
}

static void htmlGenFrameFile(FILE *ff, int fnum, char *thisfn) {
	char *ssn;
	char	ffn[MAX_FILE_NAME_SIZE];
	assert(s_fileTab.tab[fnum]);
	fprintf(ff,"<HTML><HEAD><TITLE>Xref-Html Frames</TITLE></HEAD>\n");
	fprintf(ff,"<frameset cols=\"20%,80%\">\n");

	fprintf(ff,"<frame src=\"%s%s\" name=\"packageFrame\">\n",
			htmlGetLinkFileNameStatic(getDefaultCxFileStatic(),thisfn),
			s_opt.htmlLinkSuffix);

	concatPathes(ffn,MAX_FILE_NAME_SIZE,
				s_opt.htmlRoot, 
				cutHtmlPath(getRealFileNameStatic(s_fileTab.tab[fnum]->name)),
				"");
	fprintf(ff,"<frame src=\"%s.html%s\" name=\"classFrame\">\n", 
			htmlCutLastSuffixStatic(htmlGetLinkFileNameStatic(ffn,thisfn)),
			s_opt.htmlLinkSuffix);
	fprintf(ff,"</frameset>\n");
	fprintf(ff,"</html>");
}

/* ****************************************************************** */


void htmlGetDefinitionReferences() {
	char *tt;
//&fprintf(dumpOut,"start scanning ref files\n");fflush(dumpOut);
	scanReferenceFiles(s_opt.cxrefFileName,s_cxFullScanFunTab);
	/* following lines, just ensures, there will be enough space for refs */
	CX_ALLOCC(s_cxGlobalReferencesBase, CX_MEMORY_CHUNK_SIZE, char);
	CX_ALLOCC(tt, CX_MEMORY_CHUNK_SIZE, char);
	CX_FREE_UNTIL(s_cxGlobalReferencesBase);
//&fprintf(dumpOut,"ref files scanned\n");fflush(dumpOut);
}

/* ****************************************************************** */
/* ****************************************************************** */

static int htmlRefListOrdering(S_reference *r1, S_reference *r2) {
	char *sss1,*sss2; 
	int fc;
/*
	sss1 = simpleFileName(s_fileTab.tab[r1->p.file]->name);
	sss2 = simpleFileName(s_fileTab.tab[r2->p.file]->name);
	fc = strcmp(sss1, sss2);
	if (fc < 0) return(1);
	if (fc > 0) return(0);
*/
	if (r1->p.file < r2->p.file) return(1);
	if (r1->p.file > r2->p.file) return(0);
	if (r1->p.line < r2->p.line) return(1);
	if (r1->p.line > r2->p.line) return(0);
	if (r1->p.coll < r2->p.coll) return(1);
	if (r1->p.coll > r2->p.coll) return(0);
	if (r1->usg.base < r2->usg.base) return(1);
	if (r1->usg.base > r2->usg.base) return(0);
	return(0);
}

/* ordering on HtmlRefList */
#define SORTED_LIST_LESS(tmp,key) (htmlRefListOrdering((tmp)->r, (key).r))

#define SORTED_LIST_NEQ(tmp,key) (\
	((tmp)->r->p.file != (key).r->p.file) || \
	((tmp)->r->p.line != (key).r->p.line) || \
	((tmp)->r->p.coll != (key).r->p.coll) \
)

void htmlPutChar(FILE *ff, int c) {
	static int collumn=0;
	int n;
	collumn++;
	switch (c) {
	case HTML_PUTCH_REF_TABULATOR:
		// a reference list tabulator
		n = HTML_PUTCH_REF_TABN-(collumn-1)%HTML_PUTCH_REF_TABN-1;
		collumn += n;
		if (collumn >= s_opt.htmlCxLineLen) {
			fprintf(ff,"\n%*s",HTML_PUTCH_REF_TABN,"");
			collumn= HTML_PUTCH_REF_TABN;
		} else {
			fprintf(ff,"%*s",n+1,"");
		}
		break;
	case '<':
		fprintf(ff,"&lt;");
		break;
	case '>':
		fprintf(ff,"&gt;");
		break;
	case '&':
		fprintf(ff,"&amp;");
		break;
	case 015:		// convert ^M to space, to work also with MS-DOS files
		fputc(' ', ff);
		break;
	case '\n':
		fputc('\n',ff);
		collumn=0;
		break;
	case '\t':
		n = s_opt.tabulator-(collumn-1)%s_opt.tabulator-1;
		collumn += n;
		fprintf(ff,"%*s",n+1,"");
		break;
	default:
		fputc(c,ff);
	}
}

void htmlPrint(FILE *ff, char *ss) {
	char *s;
	for(s=ss; *s; s++) htmlPutChar(ff,*s);
}

static void htmlPutCharLF(FILE *ff, int c, S_position *cp) {
	htmlPutChar(ff,c);
	if (c=='\n') {
		fprintf(ff,"<A NAME=\"%s%d\"></A>",s_opt.htmlLineNumLabel, cp->line+1);
		if (s_opt.htmlLineNums) {
			if (s_opt.htmlLineNumColor!=NULL) {
				fprintf(ff,"<font color=\"%s\">", s_opt.htmlLineNumColor);
			}
			fprintf(ff,"%4d: ",cp->line+1);
			if (s_opt.htmlLineNumColor!=NULL) {
				fprintf(ff,"</font>");
			}
		}
	}
}

static int htmlPositionLess(S_position *p1, S_position *p2) {
	return(		p1->line < p2->line
			||  (p1->line == p2->line && p1->coll < p2->coll)
		);
}

void recursivelyCreateFileDirIfNotExists(char *fpath) {
	char 	*p;
	int 	ch,len,loopFlag;
	S_stat	st;
#if 1  // NEW VERSION
	len = strlen(fpath);
	loopFlag = 1;
	for (p=fpath+len; p>fpath && loopFlag; p--) {
		if (*p!=SLASH) continue;
		ch = *p; *p = 0;
		if (stat(fpath, &st)==0 && (st.st_mode & S_IFMT) == S_IFDIR) {
			 loopFlag=0;
		}
		*p = ch;
	}
	for(p+=2; *p; p++) {
		if (*p!=SLASH) continue;
		ch = *p; *p = 0;
		createDir(fpath);
		*p = ch;
	}
#else
	for(p=fpath+1; *p; p++) {
		if (*p!=SLASH) continue;
		ch = *p; *p = 0;
		if (stat(fpath, &st)==0) {
			if ((st.st_mode & S_IFMT) != S_IFDIR) continue;
		} else {
			createDir(fpath);
		}
		*p = ch;
	}
#endif
}

void concatPathes(char *res, int rsize, char *p1, char *p2, char *p3) {
	int	i,j;
	if (p1==NULL) p1="";
	if (p2==NULL) p2="";
	if (p3==NULL) p3="";
	sprintf(res,"%s%s%s",p1,htmlNormalizedPath(p2),htmlNormalizedPath(p3));
	// check there is space for some additional suffixes
	InternalCheck(strlen(res)<rsize-1);
}

static S_reference * htmlGetDefinitionRef(S_htmlRefList *rrr, int usage) {
	S_symbolRefItem *rr,*cr;
	register S_reference *r,*res;
	assert(rrr && rrr->s && rrr->s->refs);
	rr = rrr->s;
	res = NULL; 
	if (rr->vApplClass == s_noneFileIndex) {
		for(r=rr->refs; r!=NULL; r=r->next) {
			if (r->usg.base==usage) {
				if (res==NULL || res<r /*!!tricky*/) res=r;
			}
		}
	} else {
		for(cr=rrr->slist; cr!=NULL; cr=cr->next) {
			if (itIsSameCxSymbol(cr,rr)) {
				for(r=cr->refs; r!=NULL; r=r->next) {
					if (	(r->usg.base==UsageDefined || r->usg.base==UsageDeclared)
						&& cr->vFunClass==rr->vFunClass) {
						res = r;
						goto fini;
/* // instead of this && ....
						&& 	olcxVirtualyAdequate(r->usage, cr->vApplClass, 
								cr->vFunClass, UsageUsed, rr->vApplClass, 
								rr->vFunClass)) {
						if (	res==NULL 
							|| 	cr->vFunClass==rr->vFunClass) {
							res = r;
						}
						goto nextsym;
*/
					}
				}
			}
			nextsym:;
		}
	}
fini:
	return(res);
}

static char *htmlStSymbolCode(S_symbolRefItem *r, int usage) {
	static char ss[MAX_CX_SYMBOL_SIZE];
	char ttt[MAX_CX_SYMBOL_SIZE];
	char *sss, *tt;
	if (r->b.category==CatLocal) {
		sprintf(ss,"local.%x",r);
	} else {
		if (r->vApplClass == s_noneFileIndex) {
			sprintf(ss,"%s.%s", typesName[r->b.symType], r->name);
		} else {
			if (r->b.storage == StorageField) {
				strcpy(ttt, s_fileTab.tab[r->vFunClass]->name);
			} else {
				strcpy(ttt, s_fileTab.tab[r->vApplClass]->name);
			}
			tt = strchr(ttt, '.');
			if (tt!=NULL) *tt = 0;
			tt = ttt;
			if (*tt == ZIP_SEPARATOR_CHAR) tt++;
			if (r->b.symType == TypeDefault) {
				sprintf(ss,"%s.%s", tt, r->name);
			} else {
				sprintf(ss,"%s.%s.%s", typesName[r->b.symType], tt, r->name);
			}
		}
		for(sss=ss; *sss; sss++) {		// netscape don't like some chars
			if (*sss=='/' || *sss=='\\') *sss = '.';
		}
	}
	InternalCheck(strlen(ss) < MAX_CX_SYMBOL_SIZE-2);
	return(ss);
}

static void htmlCrGlobalXrefsFileName(S_symbolRefItem *cri, int usage, 
								char *fout, char *lout) {
	char *s;
	if (s_opt.refnum > 1) {
		sprintf(fout,"%s%s%04d", normalizeFileName(s_opt.cxrefFileName,s_cwd), 
						PRF_REF_PREFIX, cxFileHashNumber(cri->name));
	} else {
		sprintf(fout,"%s", normalizeFileName(s_opt.cxrefFileName,s_cwd));
	}
	assert(strlen(fout) + 10 < MAX_HTML_REF_LEN);
	strcpy(lout, htmlStSymbolCode(cri,usage));
	assert(strlen(lout) + 10 < MAX_HTML_REF_LEN);
	for(s=lout; *s; s++) if (*s=='/' || *s=='\\' || *s=='#') *s='.';
}

static void htmlCrLocalRefsFileName(int fnum, S_symbolRefItem *cri,
									int usage, char *fout, char *lout) {
	char *ss,*s;
	strcpy(fout, htmlAuxFileNameStatic(fnum, "XLL", "", ""));
	assert(strlen(fout) + 10 < MAX_HTML_REF_LEN);
	strcpy(lout, htmlStSymbolCode(cri,usage));
	assert(strlen(lout) + 10 < MAX_HTML_REF_LEN);
	for(s=lout; *s; s++) if (*s=='/' || *s=='\\') *s='.';
}

static int htmlJdkDocAvailable(S_symbolRefItem *rr){
	char *lfn, *url;
	// the following would remove also some classes, do no uncomment
//&	if ((rr->b.accessFlags & ACC_PUBLIC)==0) return(0);
	url = getJavaDocUrl_st(rr);
	lfn = getLocalJavaDocFile_st(url);
	if (lfn==NULL && ! htmlJdkDocAvailableForUrl(url)) return(0);
	return(1);
//&	return(htmlJdkDocAvailableForUrl(getJavaDocUrl_st(rr)));
}

static void htmlPrintExternHtmlJavaDocReference(char *prf,S_symbolRefItem *rr){
	int 		off;
	struct stat st;
	char		*ss;
#if 1
	sprintf(prf, "<A HREF=\"%s\">", getFullUrlOfJavaDoc_st(getJavaDocUrl_st(rr)));
#else
	if (strncmp(s_opt.htmlJdkDocPath,"http:",5)==0) {
		sprintf(prf, "<A HREF=\"%s\">", 
				getFullUrlOfJavaDoc_st(getJavaDocUrl_st(rr)));
	} else {
		off=0;
		if (strncmp(s_opt.htmlJdkDocPath,"file:",5)==0) off=5;
		sprintf(prf,"%s",
				getFullUrlOfJavaDoc_st(getJavaDocUrl_st(rr)));
		ss = strchr(prf,'#');
		if (ss!=NULL) *ss=0;
		if (stat(prf,&st)==0 && (st.st_mode & S_IFMT) != S_IFDIR) {
			sprintf(prf, "<A HREF=\"%s\">", 
					getFullUrlOfJavaDoc_st(getJavaDocUrl_st(rr)));
		} else {
			sprintf(prf,"<A>");
		}
	}
#endif
}

static void htmlGetStaticHREFItems(
							S_htmlRefList *ref,
							S_position *cp,
							char **prefix1,
							char **suffix1,
							char **prefix,
							char **suffix
							) {
	static char		prf[MAX_HTML_REF_LEN];
	static char		prf1[MAX_HTML_REF_LEN];
	char			tmp[MAX_HTML_REF_LEN];
	char			tmp2[MAX_HTML_REF_LEN];
	S_reference		*dr;
	char			*df;
	char			*thisfn;
	int 			usage,emph;
	S_symbolRefItem *cri;
	S_reference 	*rr;
	cri = ref->s;
	rr = ref->r;
	usage = UsageUsed; // so many times modified !!!! rr->usage; 
	*prefix = prf;
	*suffix = "</A>";
	*prefix1 = prf1;
	*suffix1 = "</A>";
	emph = 0;
	thisfn = s_fileTab.tab[cp->file]->name;
	if (usage==UsageDeclared) {
		dr = htmlGetDefinitionRef(ref, UsageDefined);
		if (dr!=NULL) {
			df = s_fileTab.tab[dr->p.file]->name;
			df = htmlGetLinkFileNameStatic(df,thisfn);
			df = htmlCutLastSuffixStatic(df);
			sprintf(prf,"<A HREF=\"%s.html%s#%s%d\">",df,s_opt.htmlLinkSuffix,
					s_opt.htmlLineNumLabel, dr->p.line);
		} else {
			sprintf(prf,"<EM>");
			*suffix = "</EM>";
			emph = 1;
		}
	} else if (usage==UsageDefined) {
		sprintf(prf,"<EM>");
		*suffix = "</EM>";
		emph = 1;
	} else {
		dr=htmlGetDefinitionRef(ref, UsageDefined);
		if (dr==NULL) dr=htmlGetDefinitionRef(ref, UsageDeclared);
		if (dr!=NULL) {
			df = s_fileTab.tab[dr->p.file]->name;
			df = htmlGetLinkFileNameStatic(df,thisfn);
			df = htmlCutLastSuffixStatic(df);
			sprintf(prf,"<A HREF=\"%s.html%s#%s%d\">",df,s_opt.htmlLinkSuffix,
					s_opt.htmlLineNumLabel, dr->p.line);
		} else if (EXTERN_JDOC_AVAILABLE(ref->s)) {
			htmlPrintExternHtmlJavaDocReference(prf, ref->s);
		} else {
			sprintf(prf,"<A>");
		}
	}
	InternalCheck(strlen(prf)<MAX_HTML_REF_LEN-2);
	if (cri->b.category == CatLocal) {
		htmlCrLocalRefsFileName(cp->file, cri, usage, tmp, tmp2);
	} else {
		htmlCrGlobalXrefsFileName(cri, usage, tmp, tmp2);
	}
	df = htmlGetLinkFileNameStatic(tmp,thisfn);
	if (emph) {
		sprintf(prf1,"<EM><A HREF=\"%s.html%s#%s\" target=\"packageFrame\">", 
				df, s_opt.htmlLinkSuffix, tmp2);
		*suffix1 = "</A></EM>";
	} else {
		sprintf(prf1,"<A HREF=\"%s.html%s#%s\" target=\"packageFrame\">", 
				df, s_opt.htmlLinkSuffix, tmp2);
	}
}

static int htmlNotYetInList(S_htmlRefList *place, S_htmlRefList *ref) {
	while (place!=NULL && ! SORTED_LIST_NEQ(place, *ref)) {
		if (	place->s->b.symType == ref->s->b.symType
			&& strcmp(place->s->name,ref->s->name)==0
			&& place->s->b.category == ref->s->b.category) return(0);
		place = place->next;
	}
	return(1);
}

static void htmlGenListLink(FILE *off,char *lname,char *lfile,int line,
					char *ofname, int usage) {
	char			ttt[TMP_STRING_SIZE];
	char			*ln;
	ln = htmlGetLinkFileNameStatic(lfile, ofname);
	ln = htmlCutLastSuffixStatic(ln);
	htmlPutChar(off, HTML_PUTCH_REF_TABULATOR);
	htmlPutChar(off, refCharCode(usage));
	fprintf(off,"<A HREF=\"%s.html%s#%s%d\">", ln, 
			s_opt.htmlLinkSuffix, s_opt.htmlLineNumLabel, line);
	sprintf(ttt,"%d", line);
	htmlPrint(off,ttt);
	fprintf(off,"</A>");
}

static int genRefListFileBody(FILE *ff, char *fname,
							  S_symbolRefItem *p, int usages, int option){
	S_reference *r,*oldr;
	char		*rfn;
	char		*ln;
	int			genflag,filen,linen,usage,count,groupedCount,lastFilen;
	count = 0;
	lastFilen = s_noneFileIndex;
	oldr = NULL;
	r = p->refs;
	while (r!=NULL) {
		assert(r != oldr);
		genflag = 0; filen=r->p.file; linen=r->p.line; usage=r->usg.base;
		groupedCount = 0;
		while (r!=NULL && ((filen==r->p.file && linen==r->p.line)
						   || (r->usg.base>UsageMaxOLUsages))) {
			if (r->usg.base<UsageMaxOLUsages 
				&& (usages==USAGE_ANY || r->usg.base==usages)) {
				genflag=1; groupedCount ++;
				if (usage>r->usg.base) usage=r->usg.base;
			}
			r=r->next;
		}
		if (genflag) {
			if (option != COUNT_ONLY) {
				ln = s_fileTab.tab[filen]->name;
				if (lastFilen != filen) {
					htmlPutChar(ff,'\n');
					sprintf(tmpBuff,"%s", 
							simpleFileName(getRealFileNameStatic(ln)));
					htmlPrint(ff,tmpBuff);
					htmlPutChar(ff,':');
					lastFilen = filen;
				}
				htmlGenListLink(ff,"",ln,linen,fname,usage);
				if (groupedCount>1) {
					sprintf(tmpBuff,"+");
//&					sprintf(tmpBuff,"(%d", groupedCount);
					htmlPrint(ff,tmpBuff);
				}
			}
			count++;
		}
	}
	return(count);
}

static void htmlGenLocalRefList2(FILE *ff, char *fname, S_symbolRefItem *p,
								int fnum, int usage){
	static char fn2[MAX_HTML_REF_LEN];
	static char fn3[MAX_HTML_REF_LEN];
	char *cut;
	htmlCrLocalRefsFileName(fnum,p,usage, fn2, fn3); // !!!!!!! redund ?
//&fprintf(dumpOut,"%s <-> %s\n",fn2,fname);fflush(dumpOut);
//&	assert(strcmp(fn2,fname)==0);
	cut = strchr(p->name, LINK_NAME_CUT_SYMBOL);
	if (cut==NULL) cut = p->name;
	else cut ++;
	fprintf(ff,"\n<br>");
	htmlSymbolCxTableBeg(ff);
	htmlGenRefListItemHead(ff, fn3, cut, NULL, USAGE_ANY, DEFAULT_VALUE);
	fprintf(ff,"<tr><td><pre>\n");
	genRefListFileBody(ff, fn2, p, USAGE_ANY,DEFAULT_VALUE);
	fprintf(ff,"</pre></td></tr>");
	htmlSymbolCxTableEnd(ff);
}

static int htmlContainFileReference(S_symbolRefItem *p, int fnum) {
	S_reference *r;
	if (p==NULL) return(0);
	for(r=p->refs; r!=NULL; r=r->next) {
		if (r->p.file == fnum) return(1);
	}
	return(0);
}

static void htmlGenLocalRefList(FILE *ff, char *fname,
								S_symbolRefItem *p, int fnum) {
	if (p->b.category != CatLocal) return;
	if (p->b.htmlWasLn == 0) return;
	if (LANGUAGE(LAN_YACC) && p->name[0] == '$') return;  // !!! hack
	if (! htmlContainFileReference(p, fnum)) return;
	htmlGenLocalRefList2(ff, fname, p, fnum, UsageUsed);
	// other usages are useless, local symbols xrefs do not depends
	// on the usage (because there are no virtuals).
}

static void htmlGenLocalRefLists(S_symbolRefItem *p, void *ss) {
	S_htmlLocalListms *s;
	s = (S_htmlLocalListms *)ss;
	if (p->b.category==CatLocal && p->b.htmlWasLn) {
		htmlGenLocalRefList(s->ff, s->fname, p, s->fnum);
	}
}

static void htmlGetThisFileReferences(int fnum, S_htmlRefList **rrr, int kind){
	S_symbolRefItem *d,*dd;
	S_reference		*rr;
	S_htmlRefList	**place,*r,rref,**rrr0;
	int i;
	*rrr = NULL;
	for(i=0; i<s_cxrefTab.size; i++) {
		dd = s_cxrefTab.tab[i];
		for(d=dd; d!=NULL; d=d->next) {
			rrr0 = rrr;
			for(rr=d->refs; rr!=NULL; rr=rr->next) {
				if (rr->p.file == fnum &&
					(kind==ALL_REFS || rr->usg.base<UsageMaxOLUsages)) {
/*&fprintf(dumpOut,"checking ref [%s,%d,%d](%s) on %s:%x\n",s_fileTab.tab[rr->p.file]->name,rr->p.line,rr->p.coll,usagesName[rr->usg.base],d->name,d);fflush(dumpOut);&*/
//&					if ((char*)rr<s_cxGlobalReferencesBase) continue;//!!tricky
					FILL_htmlRefList(&rref,d,rr,dd,NULL);
					SORTED_LIST_PLACE2(place, S_htmlRefList, rref, rrr0);
					if (*place==NULL 
						|| SORTED_LIST_NEQ(*place,rref)
						|| htmlNotYetInList(*place,&rref)) {
						PP_ALLOC(r, S_htmlRefList);
						// ?? why PP_ALLOC ? Because called
						// once per file and it is cleared after.
						*r = rref;
/*&fprintf(dumpOut,"adding ref [%s,%d,%d](%s) on %s:%x\n",s_fileTab.tab[r->r->p.file]->name,r->r->p.line,r->r->p.coll,usagesName[r->r->usg.base],r->s->name,r->s);fflush(dumpOut);&*/
						LIST_CONS(r,(*place));
					}
					rrr0 = place;
				}
			}
		}
	}
}

/* ************************************************************* */

static int htmlGenGlobRefListBody(FILE *ff, S_symbolRefItem *pp,
								   char *fname, int usage, int opt) {
	S_reference 	*r;
	S_symbolRefItem *p;
	int detail, count;
	count = 0; detail=0;
#if 1
	count += genRefListFileBody(ff, fname, pp, USAGE_ANY, opt);
#else
	if (pp->vApplClass==s_noneFileIndex) {
		count += genRefListFileBody(ff, fname, pp, USAGE_ANY, opt);
	} else {
		for(p=topp; p!=NULL; p=p->next) {
			if (itIsSameCxSymbol(p,pp)) {
				if (p->vApplClass == pp->vApplClass) {
					count += genRefListFileBody(ff, fname, p, USAGE_ANY,opt);
				} 
			}
		}
	}
#endif
	return(count);
}

static void htmlGenGlobRefList(FILE *ff, char *fname,
								S_symbolRefItem *p, int usage,
							   int genFlag) {
	static char sn[MAX_HTML_REF_LEN];
	static char ln[MAX_HTML_REF_LEN];
	char		lab[MAX_HTML_REF_LEN];
	char *deffn, *cut;
	int i, count, llen;
	if (p->refs == NULL) return;
	htmlCrGlobalXrefsFileName(p, usage, sn, lab); 
//&fprintf(dumpOut,"check %s <-> %s\n",sn,fname);fflush(dumpOut);
//&	assert(strcmp(sn,fname)==0);
	linkNamePrettyPrint( ln, p->name,MAX_HTML_REF_LEN,SHORT_NAME);
	count = htmlGenGlobRefListBody(ff, p, sn, usage, COUNT_ONLY);
	if (count != 0) {
	  htmlGenRefListItemHead(ff, lab, ln, p, usage, genFlag);
	  fprintf(ff,"<tr><td><pre>\n");
	  LIST_MERGE_SORT(S_reference, p->refs, olcxListLessFunction);
/*&
	  LIST_LEN(llen, S_reference, p->refs);
	  fprintf(ff, "references: %d\n", llen);
&*/
	  htmlGenGlobRefListBody(ff, p, sn, usage, DEFAULT_VALUE);
	  fprintf(ff,"</pre></td></tr>");
	}
}

/* ******************************************************************** */


static int chUpperAdequate(S_fileItem *s, S_fileItem *origin) {
	return(origin->b.isInterface == s->b.isInterface);
}

int htmlRefItemsOrderLess(S_olSymbolsMenu *ss1, S_olSymbolsMenu *ss2) {
	S_symbolRefItem *s1, *s2;
	int r,len1,len2;
	char *n1, *n2;
	s1 = &ss1->s; s2 = &ss2->s;
	GET_NUDE_NAME(s1->name, n1, len1);
	GET_NUDE_NAME(s2->name, n2, len2);
	r = strcmp(n1, n2);
	if (r!=0) return(r<0);
	r = strcmp(s1->name, s2->name);
	if (r!=0) return(r<0);
	r = classHierarchyClassNameLess(ss1->s.vApplClass,ss2->s.vApplClass);
	return(r);
}

static void shiftToTheBeginningOfClassList(S_fileItem *fi,S_chReference **orr){
	S_chReference *rr;
	assert(orr!=NULL);
	for(rr= *orr; rr!=NULL && s_fileTab.tab[rr->clas]!=fi; rr=rr->next) ;
	if (rr==NULL) return;
}

int isThereSomethingPrintable(S_olSymbolsMenu *itt) {
	S_reference *r;
	for(r=itt->s.refs; r!=NULL; r=r->next) {
		if (r->usg.base<UsageMaxOLUsages) return(1);
	}
	return(0);
}

static int htmlIsThereSomethingPrintable(S_olSymbolsMenu *itt) {
	S_reference *r;
	//&fprintf(dumpOut,"looking for something printable in %s\n", itt->s.name);
	if (LANGUAGE(LAN_JAVA) && itt->s.b.symType==TypeCppInclude) return(0);
	for(r=itt->s.refs; r!=NULL; r=r->next) {
		//&fprintf(dumpOut,"hecking ref %d,%d\n", r->p.line, r->p.coll);
		if (r->usg.base==UsageClassTreeDefinition) return(1);
		if (r->usg.base<UsageMaxOLUsages) return(1);
	}
	//&fprintf(dumpOut,"nothing found\n");
	return(0);
}

void genClassHierarchyItemLinks( FILE *ff, S_olSymbolsMenu *itt,
										int virtFlag) {
	char			thisFileName[MAX_HTML_REF_LEN];
	char			ttt[MAX_HTML_REF_LEN];
	char			tmp[MAX_HTML_REF_LEN];
	char			tmp2[MAX_HTML_REF_LEN];
	S_symbolRefItem	*rr;
	S_position  	*dr;
	char			*ln,*jdoc, *df, *ccc;
	assert(itt);
	rr = &itt->s;
	dr = NULL;
	htmlCrGlobalXrefsFileName(rr, UsageUsed, thisFileName, tmp2);
	if (isThereSomethingPrintable(itt)) {
		if (virtFlag!=SINGLE_VIRT_ITEM) {
			fprintf(ff,"<A NAME=\"%s\"></A>",tmp2);
			fprintf(ff,"<A HREF=\"#%s.rf\" target=\"packageFrame\">x</A> ",
					tmp2);
		} else {
			fprintf(ff,"  ");
		}
	} else {
		fprintf(ff,"  ");
	}
	if (itt!=NULL && itt->defpos.file != s_noneFileIndex) {
		dr = & itt->defpos;
	}
	if (dr!=NULL && rr->vApplClass==rr->vFunClass) {
		df = s_fileTab.tab[dr->file]->name;
		df = htmlGetLinkFileNameStatic(df, thisFileName);
		df = htmlCutLastSuffixStatic(df);
		fprintf(ff,"<A HREF=\"%s.html%s#%s%d\">s</A> ",df,
				s_opt.htmlLinkSuffix, s_opt.htmlLineNumLabel, dr->line);
#if ZERO
		if (s_opt.javaDoc) {
			linkNamePrettyPrint(tmp, rr->name,MAX_HTML_REF_LEN,LONG_NAME);
			strcpy(ttt, df);
			ccc = lastOccurenceInString(ttt, '.');
			if (ccc!=NULL) {
				*ccc = 0;
				fprintf(ff," <A HREF=\"%s.html#%s\">d</A>", ttt, tmp);
			}
		}	
	} else if (EXTERN_JDOC_AVAILABLE(rr) && rr->vApplClass==rr->vFunClass) {
		fprintf(ff, " <A HREF=\"%s\">d</A>", 
				getFullUrlOfJavaDoc_st(getJavaDocUrl_st(rr)));
#endif
	} else {
		fprintf(ff, "  ");
	}
}

void htmlGenNonVirtualGlobSymList( FILE *ff, char *fn, S_symbolRefItem *p ) {
	fprintf(ff,"<br><br><br>");
	htmlSymbolCxTableBeg(ff);
	htmlGenGlobRefList(ff, fn, p, UsageDefined, 
					   DEFAULT_VALUE);
	htmlSymbolCxTableEnd(ff);
}

static void genVirtualsGlobRefLists2( S_olSymbolsMenu *rrr, FILE *ff, 
									  char *fn, int genFlag ){
	S_olSymbolsMenu *ss;
	S_symbolRefItem *p;
	int				loop, cmin, minline;
	loop = 1; minline = 0; p=NULL;
	while (loop) {
		loop = 0; 
		cmin = MAXIMAL_INT;
		for(ss=rrr; ss!=NULL; ss=ss->next) {
			if (ss->outOnLine>=minline && ss->outOnLine<cmin) {
				cmin = ss->outOnLine;
				p = &ss->s;
			}
		}
		if (cmin != MAXIMAL_INT) {
			assert(p!=NULL);
			htmlGenGlobRefList(ff, fn, p, UsageDefined, genFlag);
			loop = 1;
			minline = cmin+1;
			p = NULL;
		}
	}
}

static void htmlMarkVisibleAllClassesHavingReferences(S_olSymbolsMenu *rrr) {
	S_olSymbolsMenu *ss;
	for(ss=rrr; ss!=NULL; ss=ss->next) {
		if (htmlIsThereSomethingPrintable(ss)) {
			ss->visible = ss->selected = 1;
		}
	}
}

// !!!!!!!! This will destroy original lists !!!!!!!!!!!!!!!!!!
static void htmlJoinAllStaticLinkedRefs(S_olSymbolsMenu *rrr) {
	S_olSymbolsMenu *rr, *ss;
	int cFunCl;
	for(rr=rrr; rr!=NULL; rr=rr->next) {
		cFunCl = rr->s.vFunClass;
		if (cFunCl==rr->s.vApplClass && cFunCl!=s_noneFileIndex) {
			for(ss=rrr; ss!=NULL; ss=ss->next) {
				if (ss->s.vFunClass == cFunCl && ss!=rr) {
					LIST_APPEND(S_reference, rr->s.refs, ss->s.refs);
					ss->s.refs = NULL;
					ss->selected = 0;
				}
			}
		}
	}
}

void htmlGenGlobRefsForVirtMethod(FILE *ff, char *fn, S_olSymbolsMenu *rrr) {
	int 			vcount, virtFlag;
	S_olSymbolsMenu *rr;
	if (JAVA_STATICALLY_LINKED(rrr->s.b.storage, rrr->s.b.accessFlags)) {
		htmlJoinAllStaticLinkedRefs(rrr);
	}
	vcount = 0;
	for(rr=rrr; rr!=NULL; rr=rr->next) {
		if (rr->selected) vcount++;
	}
	if (vcount==1) virtFlag = SINGLE_VIRT_ITEM;
	else virtFlag = VIRT_ITEM;
	fprintf(ff,"<br><br><br>");
	htmlSymbolCxTableBeg(ff);
	htmlVirtualTableSymName(ff, rrr, HTML_COLOR_LARGE_TAB_HEAD);
	fprintf(ff, "<tr><td bgcolor=\"%s\">\n", HTML_COLOR_CLASS_TREE);
	fprintf(ff, "<pre>\n");
	classHierarchyGenInit();
	setTmpClassBackPointersToMenu(rrr);
	genClassHierarchies( ff, rrr, virtFlag, FIRST_PASS);
//&fprintf(ff,"interfaces:\n");
	setTmpClassBackPointersToMenu(rrr);
	genClassHierarchies( ff, rrr, virtFlag, SECOND_PASS);
	// finally gen links
	fprintf(ff,"</pre></tr>");
	genVirtualsGlobRefLists2( rrr, ff, fn, virtFlag);
	htmlSymbolCxTableEnd(ff);
}

static void htmlGetReferencesMetrics( S_symbolRefItem *p,  
									  int *refn,
									  int *defRefn,
									  int *defusage,
									  S_position *defpos
	) { 
	S_reference *r;
	int rn, drn;
	rn = drn = 0;
	*defpos = s_noPos;
	for (r=p->refs; r!=NULL; r=r->next) {
		if (r->usg.base == UsageDefined) {
			*defusage = r->usg.base;
			*defpos = r->p;
			drn ++;
		} else if (r->usg.base == UsageDeclared) {
			drn++;
		} else if (r->usg.base == UsageClassTreeDefinition) {
			*defusage = r->usg.base;
			*defpos = r->p;
		} else if (r->usg.base < UsageMaxOLUsages) {
			rn++;
		}
	}
	*refn = rn;
	*defRefn = drn;
}


static void htmlCreateGlobSymList(int i, void *off, void *ffn, void *genfi) {
	FILE *ff;
	char *fn;
	int genFileIndex, refn, defRefn, defusage;
	static int counter;
	S_symbolRefItem *p,*pp;
	S_olSymbolsMenu *hh;
	S_reference *r;
	S_position defpos;
	ff = off;
	fn = ffn;
	assert(genfi);
	genFileIndex = *((int *)genfi);
	pp = s_cxrefTab.tab[i];
	for (p=pp; p!=NULL; p=p->next) {
		if (p->b.category == CatGlobal && p->b.symType<MAX_HTML_LIST_TYPE) {
			if (genFileIndex==HTML_GXANY 
				|| genFileIndex == cxFileHashNumber(p->name)) {
			  htmlGetReferencesMetrics( p, &refn, &defRefn, &defusage,&defpos);
			  CX_ALLOC(hh, S_olSymbolsMenu);
			  FILL_olSymbolsMenu(hh, *p, 
								 0, 0,  					// selected/visible
								 DEFAULT_SELECTION_OO_BITS,	// ooBits
								 UsageUsed,
								 0,
								 refn, defRefn, defusage, defpos,
								 0, NULL, 
								 s_htmlCurrentCxlist);
			  s_htmlCurrentCxlist = hh;
			}
		}
	}
}

static void htmlScanCxFileAndGenRefLists(char *fn1, char *fn2, 
										 int fi, int genFlag) {
	char 	        	fn[MAX_FILE_NAME_SIZE];
	char 				ln[MAX_FILE_NAME_SIZE];
	char				*ffn;
	FILE				*ff;
	S_symbolRefItem 	*rr;
	S_olSymbolsMenu		*ss;
	sprintf(fn, "%s%s", getRealFileNameStatic(normalizeFileName(fn1,s_cwd)), fn2);
	InternalCheck(strlen(fn) < MAX_FILE_NAME_SIZE-1);
	if (! s_opt.noCxFile) {
	  fIn = fopen(fn, "r");
	  if (fIn == NULL) {
		error(ERR_CANT_OPEN, fn);
	  } else {
		scanCxFile(s_cxHtmlGlobRefListScanFunTab);
		fclose(fIn);
	  }
	}
	ffn = cutHtmlPath(fn);
	if (genFlag == HTML_GEN) {
		//& fprintf(stdout,"\n %s ",ffn);fflush(stdout);
		if (!s_opt.xref2) {
			if (fi%10==0) fprintf(stdout,"\n");
			fprintf(stdout,"X%04d ",fi);
			fflush(stdout);
		}
		concatPathes(ln,MAX_FILE_NAME_SIZE,	s_opt.htmlRoot, ffn,".html");
		recursivelyCreateFileDirIfNotExists(ln);
		ff = fopen(ln, "w");
		if (ff==NULL) error(ERR_CANT_OPEN, ln);
		else {
			htmlGenRefListFileHead(ff,fi);
			s_htmlCurrentCxlist = NULL;
			refTabMap32(&s_cxrefTab, htmlCreateGlobSymList, ff, ffn, &fi);
			LIST_MERGE_SORT(S_olSymbolsMenu,
							s_htmlCurrentCxlist,htmlRefItemsOrderLess);
			htmlMarkVisibleAllClassesHavingReferences(s_htmlCurrentCxlist);
			htmlGenGlobRefLists(s_htmlCurrentCxlist, ff, ffn);
			htmlGenRefListTail(ff);
			fclose(ff);
			htmlCompressFile(ln);
		}
	}
}

/* ***************************************************************** */

#define GetFileChar(ch,ff,cp) {\
	if (ch=='\n') {(cp)->line++; (cp)->coll=0;}\
	else (cp)->coll++;\
	ch=fgetc(ff);\
	if (ch==EOF) {\
		fclose(ff);\
		ff = NULL;\
	}\
}

#define HtmlPassSourceIdent(cp,ch,ff) {\
		while (ch!=EOF && (isalpha(ch)||isdigit(ch)||ch=='_'||ch=='$')) {\
			htmlPutCharLF(ccOut, ch, cp);\
			GetFileChar(ch, ff, cp);\
		}\
}


#define JAVA_DOC_SCOPE_DEF(xxx) (\
  (xxx->r->usg.base==UsageDefined &&  xxx->s->b.symType==TypeDefault)\
)\

static void htmlJavaDocPosProcess(	FILE **fff, 
							S_htmlRefList **rrr, 
							S_position *cp,
							int *cch
						) {
  S_htmlRefList *dr,*rr;
  char 			*prf,*suf,*prf1,*suf1;
  int  usage;
  assert(rrr);
  rr = *rrr;
  assert(rr && rr->r);
  if (rr->r->usg.base == UsageJavaDocFullEntry
	  || rr->r->usg.base == UsageJavaDoc) {
	usage = rr->r->usg.base;
	dr = rr;
	if (usage == UsageJavaDoc) {
	  // invalidate full entry items until the next definition
	  for(; dr!=NULL && !JAVA_DOC_SCOPE_DEF(dr); dr=dr->next) {
		if (dr->r->usg.base == UsageJavaDocFullEntry) dr->r->usg.base=UsageNone;
	  }
	}
	if (dr!=NULL) {
	  htmlGetStaticHREFItems(dr,cp, &prf1, &suf1, &prf, &suf);
	  if (usage == UsageJavaDocFullEntry) fprintf(ccOut," /**");
	  fprintf(ccOut,"\n  * @see %s[Source]%s\n",prf,suf);
	  fprintf(ccOut,"  * @see %s[Xrefs]%s\n",prf1,suf1);
	  if (usage == UsageJavaDocFullEntry) fprintf(ccOut,"  */\n");
	}
  }
  rr = rr->next;
  *rrr = rr;
}

static void htmlPosProcess(	FILE **fff, 
							S_htmlRefList **rrr, 
							S_position *cp,
							int *cch
						) {
	int 			ch,rlen;
	S_htmlRefList 	*rr;
	S_symbolRefItem *cri;
	char 			*prf,*suf,*prf1,*suf1;
	char 			*prf0,*suf0;
	FILE			*ff;
	ff = *fff;
	rr = *rrr;
	ch = *cch;
	cri = rr->s;
	prf = suf = "";
	prf0 = suf0 = "";
	prf1 = suf1 = "";
/*&fprintf(dumpOut,"processing '%s' at %d,%d,%d\n",cri->name,rr->r->p.file,rr->r->p.line,rr->r->p.coll);fflush(dumpOut);&*/
	if (cri->b.symType == TypeFunSep) {
		if (s_opt.htmlFunSeparate) {
			fprintf(ccOut, "</pre><font size= -1 color=\"red\"><hr><center>");
			fprintf(ccOut,"%s:%d", 
					s_fileTab.tab[cp->file]->name, cp->line);
			fprintf(ccOut, "</center><hr></font><pre>");
		}
		goto fini;
	} else if (cri->b.symType == TypeComment) {
		if (rr->r->usg.base == UsageDefined) {
			fprintf(ccOut,"<font color=\"green\">");
		} else {
			fprintf(ccOut,"</font>");
		}
		goto fini;
	} else if (cri->b.symType == TypeCppAny) {
		prf0 = "<font color=\"brun\">";
		suf0 = "</font>";
	} else if (cri->b.symType == TypeKeyword) {
		prf0 = "<font color=\"blue\">"; //"<B>";
		suf0 = "</font>";//"</B>";
	} else {
		if (cri->b.symType == TypeCppIfElse) {
			if (s_opt.htmlNoColors==0) {
				prf0 = "<font color=\"brun\">";
				suf0 = "</font>";
			}
		} 
		if (cri->b.symType==TypeCppInclude && rr->r->usg.base==UsageDefined) {
			goto fini;
		}
		htmlGetStaticHREFItems(rr,cp, &prf1, &suf1, &prf, &suf);
		/*&
		if (LANGUAGE(LAN_JAVA) && rr->s->vFunClass != s_noneFileIndex) {
		  // if virtual method, then point to cxrefs
		  prf = prf1; suf=suf1;
		}
		&*/
	}
	if (ff == NULL) goto fini;
	if (htmlPositionLess(&rr->r->p, cp)) {
		fprintf(ccOut,"%s%s",prf0,prf);
		fprintf(ccOut,"%s%s",suf,suf0);
	} else {
		if (	cri->b.symType==TypeCppIfElse 
				|| cri->b.symType==TypeCppInclude//include is now a link
				|| cri->b.symType==TypeCppAny
			) {
#ifdef DEBUG
			if (ch != '#') {
				fprintf(dumpOut,"cpp ref on '%c' not at #: %s,%d,%d\n",ch,s_fileTab.tab[rr->r->p.file]->name,rr->r->p.line,rr->r->p.coll);fflush(dumpOut);
			}
#endif
			htmlPutCharLF(ccOut, ch, cp);
			GetFileChar(ch, ff, cp);
			while (ch==' '||ch=='\t') {
				htmlPutCharLF(ccOut, ch, cp);
				GetFileChar(ch, ff, cp);
			}
		}
#if ZERO       // this was with first char cxlink only
		if ((cri->b.category == CatGlobal && s_opt.htmlglobalx) 
			 ||	(cri->b.category == CatLocal && s_opt.htmllocalx)) {
			fprintf(ccOut,"%s%s",prf0,prf1);
			if (ch!=EOF && (isalpha(ch)||isdigit(ch)||ch=='_'||ch=='$')) {
				htmlPutCharLF(ccOut, ch, cp);
				GetFileChar(ch, ff, cp);
			}
			fprintf(ccOut,"%s%s",suf1,prf);
		} else {
			fprintf(ccOut,"%s%s",prf0,prf);
		}
		while (ch!=EOF && (isalpha(ch)||isdigit(ch)||ch=='_'||ch=='$')) {
			htmlPutCharLF(ccOut, ch, cp);
			GetFileChar(ch, ff, cp);
		}
		fprintf(ccOut,"%s%s",suf,suf0);
		cri->b.htmlWasLn = 1;
#endif
		if (rr->r->usg.base==UsageDefined) {
		  if ((rr->s->b.category==CatLocal && s_opt.htmllocalx)
			  || (rr->s->b.category==CatGlobal && s_opt.htmlglobalx)) {
			fprintf(ccOut,"%s%s",prf0,prf1);
			HtmlPassSourceIdent(cp,ch,ff);
			fprintf(ccOut,"%s%s",suf1,suf0);
		  } else {
			fprintf(ccOut,"%s",prf0);
			HtmlPassSourceIdent(cp,ch,ff);
			fprintf(ccOut,"%s",suf0);
		  }
		} else if (s_opt.htmlDirectX &&
				   ((cri->b.category == CatGlobal && s_opt.htmlglobalx) 
					||	(cri->b.category == CatLocal && s_opt.htmllocalx))) {
			fprintf(ccOut,"%s%s",prf0,prf1);
			if (ch!=EOF && (isalpha(ch)||isdigit(ch)||ch=='_'||ch=='$')) {
				htmlPutCharLF(ccOut, ch, cp);
				GetFileChar(ch, ff, cp);
			}
			fprintf(ccOut,"%s%s",suf1,prf);
			HtmlPassSourceIdent(cp,ch,ff);
			fprintf(ccOut,"%s%s",suf,suf0);
		} else {
			fprintf(ccOut,"%s%s",prf0,prf);
			HtmlPassSourceIdent(cp,ch,ff);
			fprintf(ccOut,"%s%s",suf,suf0);
		}
		cri->b.htmlWasLn = 1;
	}
fini:
	rr = rr->next;
	*rrr = rr;
	*fff = ff;
	*cch = ch;
}

static void htmlPassRefsThroughSourceFile(S_htmlRefList **rrr, int ifile,
										int genFlag) {
	S_htmlRefList 		*rr,*oldrr;
	int					n,ch;
	FILE				*cofile;
	char				*cofileName;
	S_position			cp;
	rr = *rrr;
	assert(s_fileTab.tab[ifile]);
	cofileName = s_fileTab.tab[ifile]->name;
	cofile = fopen(cofileName, "r");
/*&fprintf(dumpOut,"[passRefsThrowSourceFile] openning file %s (%d)\n",cofileName,cofile!=NULL);fflush(dumpOut);&*/
	if (cofile==NULL) error(ERR_CANT_OPEN, cofileName);
	FILL_position(&cp, ifile, 0, 0);
	ch = '\n';
	if (genFlag==GEN_HTML) htmlPutCharLF(ccOut, ch, &cp);
	else fputc(ch,ccOut);
	if (cofile!=NULL) {
		GetFileChar(ch, cofile, &cp);
	}
	oldrr = NULL;
	while (rr != NULL) {
		assert(oldrr!=rr); oldrr=rr;	// because it is a dangerous loop
		while (cofile!=NULL && htmlPositionLess(&cp, &rr->r->p)) {
		  if (genFlag==GEN_HTML) htmlPutCharLF(ccOut, ch, &cp);
		  else fputc(ch,ccOut);
		  GetFileChar(ch, cofile, &cp);
		}
		if (genFlag==GEN_HTML) htmlPosProcess(&cofile, &rr, &cp, &ch);
		else htmlJavaDocPosProcess(&cofile, &rr, &cp, &ch);
	}
	while (cofile!=NULL) {
	  if (genFlag==GEN_HTML) htmlPutCharLF(ccOut, ch, &cp);
	  else fputc(ch,ccOut);
	  GetFileChar(ch, cofile, &cp);
	}
	if (cofile != NULL) fclose(cofile);
	*rrr = rr;
}

static void htmlGenerateFileToCcOut(int fnum) {
	S_htmlRefList 		*rr;
	S_position			cp;
	/* free memories, especially ppmMemory */
	recoverCachePoint(1,s_cache.cp[1].lbcc,0);
	htmlGenHead(fnum);
	FILL_position(&cp, fnum, 1, 0);
	htmlGetThisFileReferences(fnum, &rr, ONLINE_ONLY);
	htmlPassRefsThroughSourceFile(&rr,fnum,GEN_HTML);
	htmlGenTail();
}

static void htmlGenerateFile(int fnum) {
	S_htmlLocalListms	sss;
	char				*fn,*frn,*lrn;
	char				ffn[MAX_FILE_NAME_SIZE];
	char				ffn2[MAX_FILE_NAME_SIZE];
	int					i;
	FILE				*ff;
	assert(s_fileTab.tab[fnum]);
/*&fprintf(dumpOut,"opening %s\n",fn);&*/
	concatPathes(ffn,MAX_FILE_NAME_SIZE,
			s_opt.htmlRoot,
			htmlAuxFileNameStatic(fnum,"XFRM","",".frm.html"),
			NULL);
	if (GENERATE_FRAMES()) {
		recursivelyCreateFileDirIfNotExists(ffn);
		ff = fopen(ffn,"w");
		if (ff==NULL) error(ERR_CANT_OPEN,ffn);
		else {
			htmlGenFrameFile(ff,fnum, ffn);
			fclose(ff);
			htmlCompressFile(ffn);
		}
	}
	concatPathes(ffn,MAX_FILE_NAME_SIZE,
			s_opt.htmlRoot,htmlCutLastSuffixStatic(cutHtmlPath(getRealFileNameStatic(s_fileTab.tab[fnum]->name))),".html");
	recursivelyCreateFileDirIfNotExists(ffn);
	ccOut = fopen(ffn,"w");
	if (ccOut==NULL) {
		warning(ERR_CANT_OPEN,ffn);
		ccOut=stdout;
	} else {
		if (!s_opt.xref2) {
			fprintf(dumpOut," -> '%s'\n", ffn); fflush(dumpOut);
		}
		htmlGenerateFileToCcOut(fnum);
		fclose(ccOut);
		htmlCompressFile(ffn);
		ccOut=stdout;
		/* now create local reference lists */
		if (s_opt.htmllocalx) {
			strcpy(ffn,htmlAuxFileNameStatic(fnum,"XLL","",""));
			concatPathes(ffn2,MAX_FILE_NAME_SIZE,s_opt.htmlRoot,ffn,".html");
			recursivelyCreateFileDirIfNotExists(ffn2);
			ff = fopen(ffn2,"w");
			if (ff==NULL) error(ERR_CANT_OPEN,ffn2);
			else {
				htmlGenRefListFileHead(ff, -1);
				FILL_htmlLocalListms(&sss, ff, fnum, ffn);
				refTabMap2(&s_cxrefTab, htmlGenLocalRefLists, &sss);
				htmlGenRefListTail(ff);
				fclose(ff);
				htmlCompressFile(ffn2);
			}
		}
	}
}

static void htmlGenerateJavaDocFile(int fnum) {
	char				*fn;
	S_htmlRefList 		*rr;
	char				ffn[MAX_FILE_NAME_SIZE];
	struct stat			st;
	int					stt;
	assert(s_fileTab.tab[fnum]);
/*&fprintf(dumpOut,"opening %s\n",fn);&*/
	concatPathes(ffn,MAX_FILE_NAME_SIZE,
				 s_opt.jdocTmpDir,
				 cutHtmlPath(getRealFileNameStatic(s_fileTab.tab[fnum]->name)),
				 ""); // maybe some suffix .doc ?
	if (!s_opt.xref2) {
		fprintf(dumpOut," -> '%s'\n", ffn); fflush(dumpOut);
	}
	recursivelyCreateFileDirIfNotExists(ffn);
	stt = stat(ffn,&st);
	if (stt==0) {
		sprintf(tmpBuff, "file %s exists, not overwriting it", ffn);
		warning(ERR_ST, tmpBuff);
		return;
	}
	ccOut = fopen(ffn,"w");
	if (ccOut==NULL) {
		warning(ERR_CANT_OPEN,ffn);
		ccOut=stdout;
	} else {
		htmlGetThisFileReferences(fnum, &rr, ALL_REFS);
   		htmlPassRefsThroughSourceFile(&rr,fnum,GEN_JAVA_DOC);
		fclose(ccOut);
	}
}

void htmlAddFunctionSeparatorReference() {
	S_position pos;
	if (s_opt.taskRegime == RegimeHtmlGenerate) {
		FILL_position(&pos, cFile.lb.cb.fileNumber, cFile.lineNumber+1, -1);
		addTrivialCxReference(LINK_NAME_FUNCTION_SEPARATOR, TypeFunSep,StorageDefault,
							  &pos, UsageUsed);
		return;
	}
}


void htmlAddJavaDocReference(S_symbol  *p, S_position  *pos,
							 int  vFunClass, int  vApplClass) {
	S_position npos;
	if (s_opt.taskRegime == RegimeHtmlGenerate && s_opt.javaDoc) {
		FILL_position(&npos, pos->file, pos->line, 0);
   		addCxReference(p, &npos, UsageJavaDocFullEntry, vFunClass, vApplClass);
	}
}

/* ******************************************************************** */

int isJavaClassFile(S_fileItem *ffi) {
	char *ss;
	ss = getFileSuffix(ffi->name);
	if (strcmp(ss,".class")==0) return(1);
	return(0);
}

void htmlGenEmptyRefsFile() {
	FILE		*ff;
	ff = fopen(s_htmlEmptyRefs,"w");
	if (ff!=NULL) {
		htmlGenRefListFileHead(ff, -1);
		htmlGenRefListItemHead(ff, "", 
		"Xrefs",
		NULL, USAGE_ANY, DEFAULT_VALUE
		);
		htmlGenRefListTail(ff);
		fclose(ff);
		htmlCompressFile(s_htmlEmptyRefs);
	}
}

/* ******************************************************************** */

static void dumpClList(S_chReference *ll) {
	for(; ll!=NULL; ll=ll->next) {
		fprintf(dumpOut,"  %s\n", 
				javaGetNudePreTypeName_st(getRealFileNameStatic(
					s_fileTab.tab[ll->clas]->name), s_opt.nestedClassDisplaying));
	}
}

static void sortSubClassesList(S_fileItem *fi) {
//&fprintf(dumpOut,"sorting\n"); dumpClList(fi->infs);
	LIST_MERGE_SORT(S_chReference, fi->infs, classHierarchySupClassNameLess);
//&fprintf(dumpOut,"result is\n"); dumpClList(fi->infs);
}

void htmlGenGlobalReferenceLists(char *cxMemFreeBase) {
	char 	fn[MAX_FILE_NAME_SIZE];
	char 	*dirname,*fname,*newFreeBase;
	int		i;
	if (s_opt.htmlglobalx == 0) return;
	if (!s_opt.xref2) {
		fprintf(dumpOut,"\nGenerating global symbol reference lists");
		fflush(dumpOut);
	}
	fname = s_opt.cxrefFileName;
	if (s_opt.refnum <= 1) {
		/* single reference file */
		recoverMemoriesAfterOverflow(cxMemFreeBase);
		htmlScanCxFileAndGenRefLists(fname, "",HTML_GXANY, HTML_GEN);
	} else {
		/* several reference files */
		dirname = fname;
		recoverMemoriesAfterOverflow(cxMemFreeBase);
		htmlScanCxFileAndGenRefLists(dirname,PRF_FILES,HTML_GXANY,HTML_NO_GEN);
		htmlScanCxFileAndGenRefLists(dirname,PRF_CLASS,
										 HTML_GXANY, HTML_NO_GEN);
		idTabMap(&s_fileTab, sortSubClassesList);
		CX_ALLOCC(newFreeBase, 0, char);
		for (i=0; i<s_opt.refnum; i++) {
			recoverMemoriesAfterOverflow(newFreeBase);
			sprintf(fn, "%s%04d", PRF_REF_PREFIX, i);
			htmlScanCxFileAndGenRefLists(dirname,fn, i, HTML_GEN);
		}
	}
	if (!s_opt.xref2) {
		fprintf(dumpOut,"\nDone.\n"); fflush(dumpOut);
	}
}


void generateHtml() {
	register int 	i;
	S_fileItem		*fi;

	if (s_opt.htmlRoot==NULL ||  s_opt.htmlRoot[0]==0) {
		fatalError(ERR_ST, "No HTML output directory specified, use -htmlroot=<dir>", XREF_EXIT_ERR);
	}
	concatPathes(s_htmlEmptyRefs,MAX_FILE_NAME_SIZE,
					s_opt.htmlRoot,HTML_EMPTY_REF_FILE,"");
	for(i=0; i<MAX_FILES; i++) {
		fi = s_fileTab.tab[i];
		if (fi == NULL) continue;
		if (fi->b.cxLoading==0) continue;
		if (isJavaClassFile(fi)) continue;
		htmlGenerateFile(i);
		if (s_opt.javaDoc) htmlGenerateJavaDocFile(i);
	}
}



