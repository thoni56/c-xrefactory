# Boilerplate Makefile for many c-xref tests
#
# - Names the test from directory name
# - Generates a specific, simple, c-xrefrc from a template
# - Can verify output to expected with colours
#
# In the test Makefiles you just need to include this and define the
# $(TEST) target where the execution of the test should go.
#

MAKEFILE_DIR = $(dir $(lastword $(MAKEFILE_LIST)))
include $(MAKEFILE_DIR)/Makefile.messages

# You can override which c-xref to run by setting CXREF_PROGRAM, but
# each test need to define ARGUMENTS and can use $(COMMAND)
CXREF_PROGRAM = $(MAKEFILE_DIR)/../src/c-xref
BASE_ARGUMENTS = -xrefrc .c-xrefrc -p $(CURDIR) $(EXTRA)
CXREF = $(CXREF_PROGRAM) $(BASE_ARGUMENTS)
COMMAND = $(CXREF) $(ARGUMENTS)

# Define the test name as the directory name
TEST = $(shell basename '$(CURDIR)')

all: .c-xrefrc $(TEST)
$(TEST): .c-xrefrc

# Make all testcases silent by default. Use VERBOSE=1 to revert
$(VERBOSE).SILENT:

# All tests that uses a server driver should use this
SERVER_DRIVER = $(MAKEFILE_DIR)/../utils/server_driver.py

# Convert any (absolute) reference to current directory to CURDIR
NORMALIZE = sed -e "s+$(CURDIR)+CURDIR+g" -e "s/ len=[0-9]*/ len=<n>/g" -e "s+/.*/usr/+/usr/+g" -e "s/[0-9][0-9]:[0-9][0-9]:[0-9][0-9]/00:00:00/g" -e "/<progress>[0-9]/d"

# Do we need date normalization too?
# -E 's/[[:digit:]]{4}-[[:digit:]]{2}-[[:digit:]]{2} [[:digit:]]{2}:[[:digit:]]{2}:[[:digit:]]{2}/0000-00-00 00:00:00/' >> output.tmp

# Verification is often done by comparing an output with the expected
VERIFY = diff --strip-trailing-cr output expected > /dev/null 2>&1 ; \
	if [ $$? -ne 0 ] ; then \
		$(FAIL) ; \
		diff --strip-trailing-cr output expected ; \
		exit 1 ; \
	else \
		rm -f output ; \
		$(OK) ; \
		exit 0 ; \
	fi

# Target to just show and run the COMMAND
run:
	echo $(COMMAND)
	$(COMMAND)

# If the test requires a .c-xrefrc for test directory you need to
# generate one. The .c-xrefrc requires absolute paths, and to work in
# any directory, a .c-xrefrc can be generated from a common
# c-xrefrc.tpl by replacing some symbols as per rules below.
#
# We use the name '.c-xrefrc' so that a test can set HOME to CWD and
# editors will automatically read the correct file as if it was in the
# users HOME.
#
# Uses local c-xrefrc.tpl if it exists, otherwise falls back to ../c-xrefrc.tpl
# wildcard makes the local template optional - expands to empty if it doesn't exist
.c-xrefrc: $(MAKEFILE_DIR)/c-xrefrc.tpl $(wildcard c-xrefrc.tpl)
	@if [ -f c-xrefrc.tpl ]; then \
		sed -e "s+CURDIR+$(CURDIR)+g" -e "s+TEST+$(TEST)+g" c-xrefrc.tpl > .c-xrefrc ; \
	else \
		sed -e "s+CURDIR+$(CURDIR)+g" -e "s+TEST+$(TEST)+g" $(MAKEFILE_DIR)/c-xrefrc.tpl > .c-xrefrc ; \
	fi

clean:
	@-rm -rf CXrefs .c-xref .c-xrefrc out* log *.log .cov/* input.lsp

coverage:
	cd ../../src ; make clean-coverage
	@echo "Doing coverage in this directory only"
	$(MAKE) $(TEST)
	cd ../../src ; make COVERAGE_CASE=$(TEST) coverage-report

# Debugging targets are provided by the specialized Makefiles:
# - Makefile.cli for command-line tests
# - Makefile.lsp for LSP tests
# - Makefile.server for server driver tests
# Include one of those instead of this boilerplate to get appropriate debug targets

valgrind:
	valgrind $(COMMAND)

valgrind-gdb:
	{ \
		valgrind --vgdb=yes --vgdb-error=0 $(COMMAND) & \
		pid=$$! ; \
		gdb $(CXREF_PROGRAM) -ex 'set non-stop off' -ex 'target remote | vgdb' ; \
		kill -9 $$pid ; \
	}
