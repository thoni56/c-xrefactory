/* -*- c -*-*/
#include "misc.h"
#include <cgreen/mocks.h>

void jarFileParse(char *file_name) {
  mock(file_name);
}

void scanJarFilesForTagSearch(void) {
  mock();
}

void classFileParse(void) {
  mock();
}

void dumpOptions(int nargc, char **nargv) {
  mock(nargc, nargv);
}

void symDump(Symbol *symbol) {
  mock(symbol);
}

void symbolRefItemDump(ReferencesItem *ss) {
  mock(ss);
}

int javaTypeStringSPrint(char *buff, char *str, int nameStyle, int *oNamePos) {
  return (int) mock(buff, str, nameStyle, oNamePos);
}

void typeSPrint(char *buff, int *size, TypeModifier *t, char *name, int dclSepChar, int maxDeep, int typedefexp, int longOrShortName, int *oNamePos) {
  mock(buff, size, t, name, dclSepChar, maxDeep, typedefexp, longOrShortName, oNamePos);
}

void throwsSprintf(char *out, int outsize, SymbolList *exceptions) {
  mock(out, outsize, exceptions);
}

void macDefSPrintf(char *buff, int *size, char *name1, char *name2, int argn, char **args, int *oNamePos) {
  mock(buff, size, name1, name2, argn, args, oNamePos);
}

char *string3ConcatInStackMem(char *str1, char *str2, char *str3) {
  return (char *) mock(str1, str2, str3);
}

void javaSignatureSPrint(char *buff, int *size, char *sig, int classstyle) {
  mock(buff, size, sig, classstyle);
}

char *strmcpy(char *dest, char *src) {
  return (char *) mock(dest, src);
}

char *simpleFileName(char *fullFileName) {
  return (char *) mock(fullFileName);
}

char *directoryName_static(char *fullFileName) {
  return (char *) mock(fullFileName);
}

char *simpleFileNameWithoutSuffix_st(char *fullFileName) {
  return (char *) mock(fullFileName);
}

bool containsWildcard(char *ss) {
  return (bool) mock(ss);
}

bool shellMatch(char *string, int stringLen, char *pattern, bool caseSensitive) {
  return (bool) mock(string, stringLen, pattern, caseSensitive);
}

void expandWildcardsInOnePath(char *filename, char *outpaths, int availableSpace) {
  mock(filename, outpaths, availableSpace);
}

void expandWildcardsInPaths(char *paths, char *outpaths, int availableSpace) {
  mock(paths, outpaths, availableSpace);
}

char *getRealFileName_static(char *fn) {
  return (char *) mock(fn);
}

bool stringContainsSubstring(char *s, char *subs) {
  return (bool) mock(s, subs);
}

void javaGetPackageNameFromSourceFileName(char *src, char *opack) {
  mock(src, opack);
}

void javaGetClassNameFromFileNumber(int nn, char *tmpOut, DotifyMode dotify) {
  mock(nn, tmpOut, dotify);
}

void javaDotifyFileName(char *ss) {
  mock(ss);
}

char *javaGetNudePreTypeName_static(char *name, NestedClassesDisplay displayMode) {
  return (char *) mock(name, displayMode);
}

char *javaGetShortClassName(char *inn) {
  return (char *) mock(inn);
}

char *javaGetShortClassNameFromFileNum_static(int fnum) {
  return (char *) mock(fnum);
}

int substringIndex(char *s, char *subs) {
  return (int) mock(s, subs);
}

bool fileNameHasOneOfSuffixes(char *fname, char *suffs) {
  return (bool) mock(fname, suffs);
}

int mapPatternFiles(char *pattern, void (*fun)(char *file, char *a1, char *a2, Completions *a3, void *a4, int *a5), char *a1, char *a2, Completions *a3, void *a4, int *a5) {
  return (int) mock(pattern, fun, a1, a2, a3, a4, a5);
}

void mapOverDirectoryFiles(char *dirname, void (*fun)(char *file, char *a1, char *a2, Completions *a3, void *a4, int *a5), int allowEditorFilesFlag, char *a1, char *a2, Completions *a3, void *a4, int *a5) {
  mock(dirname, fun, allowEditorFilesFlag, a1, a2, a3, a4, a5);
}

void javaMapOverDirectoryFiles1(char *packfile, void (*fun)(char *file, char *a1, char *a2, Completions *a3, void *a4, int *a5), Completions *a1, void *a2, int *a3) {
  mock(packfile, fun, a1, a2, a3);
}

void javaMapOverDirectoryFiles2(IdList *packid, void (*fun)(char *file, char *a1, char *a2, Completions *a3, void *a4, int *a5), Completions *a1, void *a2, int *a3) {
  mock(packid, fun, a1, a2, a3);
}

char *lastOccurenceInString(char *string, int ch) {
  return (char *) mock(string, ch);
}

char *lastOccurenceOfSlashOrBackslash(char *string) {
  return (char *) mock(string);
}

char *getFileSuffix(char *fn) {
  return (char *) mock(fn);
}

char *javaCutClassPathFromFileName(char *fname) {
  return (char *) mock(fname);
}

char *javaCutSourcePathFromFileName(char *fname) {
  return (char *) mock(fname);
}

int pathncmp(char *path1, char *path2, int length, bool caseSensitive) {
  return (int) mock(path1, path2, length, caseSensitive);
}

int compareFileNames(char *ss1, char *ss2) {
  return (int) mock(ss1, ss2);
}

int filenameCompare(char *ss1, char *ss2, int n) {
  return (int) mock(ss1, ss2, n);
}

void linkNamePrettyPrint(char *ff, char *javaLinkName, int maxlen, int argsStyle) {
  mock(ff, javaLinkName, maxlen, argsStyle);
}

char *simpleFileNameFromFileNum(int fnum) {
  return (char *) mock(fnum);
}

char *getShortClassNameFromClassNum_st(int fnum) {
  return (char *) mock(fnum);
}

void printSymbolLinkNameString(FILE *ff, char *linkName) {
  mock(ff, linkName);
}

void printClassFqtNameFromClassNum(FILE *ff, int fnum) {
  mock(ff, fnum);
}

void sprintfSymbolLinkName(SymbolsMenu *ss, char *ttt) {
  mock(ttt, ss);
}

void printSymbolLinkName(SymbolsMenu *ss, FILE *ff) {
  mock(ff, ss);
}

bool requiresCreatingRefs(ServerOperation operation) {
  return (bool) mock(operation);
}

void formatOutputLine(char *tt, int startingColumn) {
  mock(tt, startingColumn);
}

void getBareName(char *name, char **start, int *len) {
    mock(name, start, len);
}

Language getLanguageFor(char *inFileName) {
    return (Language)mock(inFileName);
}
