/* -*- c -*-*/
#include <cgreen/mocks.h>

#include "cxref.h"


char olSymbolType[COMPLETION_STRING_SIZE];
char olSymbolClassType[COMPLETION_STRING_SIZE];


int olcxReferenceInternalLessFunction(Reference *r1, Reference *r2) {
    return (int) mock(r1, r2);
}

void printTagSearchResults(void) {
    mock();
}

SymbolsMenu *olCreateSpecialMenuItem(char *fieldName, int cfi, Storage storage) {
    return (SymbolsMenu *) mock(fieldName, cfi, storage);
}

bool isSameCxSymbol(ReferenceItem *p1, ReferenceItem *p2) {
    return (bool) mock(p1, p2);
}

bool isSameCxSymbolIncludingApplicationClass(ReferenceItem *p1, ReferenceItem *p2) {
    return (bool) mock(p1, p2);
}

bool olcxIsSameCxSymbol(ReferenceItem *p1, ReferenceItem *p2) {
    return (bool) mock(p1, p2);
}

void olcxRecomputeSelRefs(OlcxReferences *refs) {
    mock(refs);
}

void olProcessSelectedReferences(OlcxReferences *rstack, void (*referencesMapFun)(OlcxReferences *rstack,
                                                                                    SymbolsMenu *ss)) {
    mock(rstack, referencesMapFun);
}

void olcxPopOnly(void) {
    mock();
}

void olStackDeleteSymbol(OlcxReferences *refs) {
    mock(refs);
}

int getFileNumberFromName(char *name) {
    return (int) mock(name);
}

void gotoOnlineCxref(Position *pos, UsageKind usageKind, char *suffix) {
    mock(pos, usageKind, suffix);
}

Reference *addNewCxReference(Symbol *symbol, Position *pos, Usage usage_arg, int vFunClass, int vApplClass) {
    Usage *usage = &usage_arg;
    return (Reference *) mock(symbol, pos, usage, vFunClass, vApplClass);
}

Reference *addCxReference(Symbol *symbol, Position *pos, UsageKind usage, int vFunClass, int vApplClass) {
    char *symbol_name = symbol->name; /* "meta" parameter to be able to access field */
    return (Reference *) mock(symbol, symbol_name, pos, usage, vFunClass, vApplClass);
}

Reference *addSpecialFieldReference(char *name, int storage, int fnum, Position *p, int usage) {
    return (Reference *) mock(name, storage, fnum, p, usage);
}

void addClassTreeHierarchyReference(int fnum, Position *p, int usage) {
    mock(fnum, p, usage);
}

void addCfClassTreeHierarchyRef(int fnum, int usage) {
    mock(fnum, usage);
}

void addTrivialCxReference(char *name, int symType, int storage, Position pos, UsageKind usageKind) {
    Position *position = &pos;
    mock(name, symType, storage, position, usageKind);
}

void olcxAddReferences(Reference *list, Reference **dlist, int fnum, int bestMatchFlag) {
    mock(list, dlist, fnum, bestMatchFlag);
}

void olSetCallerPosition(Position *pos) {
    mock(pos);
}

void renameCollationSymbols(SymbolsMenu *sss) {
    mock(sss);
}

void olCompletionListReverse(void) {
    mock();
}

int itIsSymbolToPushOlReferences(ReferenceItem *p, OlcxReferences *rstack, SymbolsMenu **rss,
                               int checkSelFlag) {
    return (int) mock(p, rstack, rss, checkSelFlag);
}

void putOnLineLoadedReferences(ReferenceItem *p) {
    mock(p);
}

void genOnLineReferences(OlcxReferences *rstack, SymbolsMenu *cms) {
    mock(rstack, cms);
}

SymbolsMenu *createSelectionMenu(ReferenceItem *dd) {
    return (SymbolsMenu *) mock(dd);
}

void mapCreateSelectionMenu(ReferenceItem *dd) {
    mock(dd);
}

void olcxFreeOldCompletionItems(OlcxReferencesStack *stack) {
    mock(stack);
}

void olcxInit(void) {
    mock();
}

Reference *getDefinitionRef(Reference *rr) {
    return (Reference *) mock(rr);
}

void olCreateSelectionMenu(int command) {
    mock(command);
}

void pushEmptySession(OlcxReferencesStack *stack) {
    mock(stack);
}

bool ooBitsGreaterOrEqual(unsigned oo1, unsigned oo2) {
    return (bool) mock(oo1, oo2);
}

void olcxReferencesDiff(Reference **anr1, Reference **aor2, Reference **diff) {
    mock(anr1, aor2, diff);
}

bool olcxShowSelectionMenu(void) {
    return (int) mock();
}

void getLineAndColumnCursorPositionFromCommandLineOptions(int *lineP, int *colP) {
    mock(lineP, colP);
}

void changeClassReferencesUsages(char *linkName, int category, int fnum, Symbol *cclass) {
    mock(linkName, category, fnum, cclass);
}

bool isStrictlyEnclosingClass(int enclosedClass, int enclosingClass) {
    return (bool) mock(enclosedClass, enclosingClass);
}

void olcxPushSpecialCheckMenuSym(char *symname) {
    mock(symname);
}

void olcxPushSpecial(char *fieldName, int command) {
    mock(fieldName, command);
}

bool isPushAllMethodsValidRefItem(ReferenceItem *ri) {
    return (bool) mock(ri);
}

void olcxPrintPushingAction(ServerOperation operation) {
    mock(operation);
}

void olPushAllReferencesInBetween(int minMemi, int maxMemi) {
    mock(minMemi, maxMemi);
}

void pushLocalUnusedSymbolsAction(void) {
    mock();
}

void answerEditAction(void) {
    mock();
}

void generateReferences(void) {
    mock();
}
