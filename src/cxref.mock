/* -*- c -*-*/
#include "cxref.h"
#include <cgreen/mocks.h>

#include "session.h"

void fillReference(Reference *reference, Usage usage, Position position,
                    Reference *next) {
    reference->usage = usage;
    reference->position = position;
    reference->next = next;
}

void fillReferencesItem(ReferencesItem *referencesItem, char *name, unsigned fileHash, int vApplClass,
                        int vFunClass, Type symType, Storage storage, ReferenceScope scope,
                        Access accessFlags, ReferenceCategory category) {
    referencesItem->name = name;
    referencesItem->fileHash = fileHash;
    referencesItem->vApplClass = vApplClass;
    referencesItem->vFunClass = vFunClass;
    referencesItem->references = NULL;
    referencesItem->next = NULL;
    referencesItem->type = symType;
    referencesItem->storage = storage;
    referencesItem->scope = scope;
    referencesItem->access = accessFlags;
    referencesItem->category = category;
}

void fillSymbolsMenu(SymbolsMenu *symbolsMenu, ReferencesItem s,
                     bool selected, bool visible, unsigned ooBits, char olUsage,
                     short int vlevel, short int refn, short int defRefn,
                     char defUsage, struct position defpos, int outOnLine,
                     struct editorMarkerList *markers,	/* for refactory only */
                     SymbolsMenu *next) {
    symbolsMenu->references = s;
    symbolsMenu->selected = selected;
    symbolsMenu->visible = visible;
    symbolsMenu->ooBits = ooBits;
    symbolsMenu->olUsage = olUsage;
    symbolsMenu->vlevel = vlevel;
    symbolsMenu->refn = refn;
    symbolsMenu->defRefn = defRefn;
    symbolsMenu->defUsage = defUsage;
    symbolsMenu->defpos = defpos;
    symbolsMenu->outOnLine = outOnLine;
    symbolsMenu->markers = markers;
    symbolsMenu->next= next;
}

int olcxReferenceInternalLessFunction(Reference *r1, Reference *r2) {
    return (int) mock(r1, r2);
}

void tagSearchCompactShortResults(void) {
    mock();
}

void printTagSearchResults(void) {
    mock();
}

SymbolsMenu *olCreateSpecialMenuItem(char *fieldName, int cfi, Storage storage) {
    return (SymbolsMenu *) mock(fieldName, cfi, storage);
}

bool isSameCxSymbol(ReferencesItem *p1, ReferencesItem *p2) {
    return (bool) mock(p1, p2);
}

bool isSameCxSymbolIncludingFunctionClass(ReferencesItem *p1, ReferencesItem *p2) {
    return (bool) mock(p1, p2);
}

bool isSameCxSymbolIncludingApplicationClass(ReferencesItem *p1, ReferencesItem *p2) {
    return (bool) mock(p1, p2);
}

bool olcxIsSameCxSymbol(ReferencesItem *p1, ReferencesItem *p2) {
    return (bool) mock(p1, p2);
}

void olcxRecomputeSelRefs(OlcxReferences *refs) {
    mock(refs);
}

void olProcessSelectedReferences(OlcxReferences *rstack, void (*referencesMapFun)(OlcxReferences *rstack,
                                                                                    SymbolsMenu *ss)) {
    mock(rstack, referencesMapFun);
}

void olcxPopOnly(void) {
    mock();
}

Reference *olcxCopyRefList(Reference *ll) {
    return (Reference *) mock(ll);
}

void olStackDeleteSymbol(OlcxReferences *refs) {
    mock(refs);
}

int getFileNumberFromName(char *name) {
    return (int) mock(name);
}

void gotoOnlineCxref(Position *p, int usage, char *suffix) {
    mock(p, usage, suffix);
}

Reference *olcxAddReferenceNoUsageCheck(Reference **rlist, Reference *ref, int bestMatchFlag) {
    return (Reference *) mock(rlist, ref, bestMatchFlag);
}

Reference *olcxAddReference(Reference **rlist, Reference *ref, int bestMatchFlag) {
    return (Reference *) mock(rlist, ref, bestMatchFlag);
}

void olcxFreeReferences(Reference *r) {
    mock(r);
}

bool isSmallerOrEqClass(int inf, int sup) {
    return (bool) mock(inf, sup);
}

char *getJavaDocUrl_st(ReferencesItem *rr) {
    return (char *) mock(rr);
}

char *getLocalJavaDocFile_st(char *fileUrl) {
    return (char *) mock(fileUrl);
}

char *getFullUrlOfJavaDoc_st(char *fileUrl) {
    return (char *) mock(fileUrl);
}

bool htmlJdkDocAvailableForUrl(char *ss) {
    return (bool) mock(ss);
}

Reference *duplicateReference(Reference *r) {
    return (Reference *) mock(r);
}

Reference *addNewCxReference(Symbol *symbol, Position *pos, Usage usage_arg, int vFunClass, int vApplClass) {
    Usage *usage = &usage_arg;
    return (Reference *) mock(symbol, pos, usage, vFunClass, vApplClass);
}

Reference *addCxReference(Symbol *symbol, Position *pos, UsageKind usage, int vFunClass, int vApplClass) {
    char *symbol_name = symbol->name; /* "meta" parameter to be able to access field */
    return (Reference *) mock(symbol, symbol_name, pos, usage, vFunClass, vApplClass);
}

Reference *addSpecialFieldReference(char *name, int storage, int fnum, Position *p, int usage) {
    return (Reference *) mock(name, storage, fnum, p, usage);
}

void addClassTreeHierarchyReference(int fnum, Position *p, int usage) {
    mock(fnum, p, usage);
}

void addCfClassTreeHierarchyRef(int fnum, int usage) {
    mock(fnum, usage);
}

void addTrivialCxReference(char *name, int symType, int storage, Position pos, UsageKind usageKind) {
    Position *position = &pos;
    mock(name, symType, storage, position, usageKind);
}

void olcxAddReferences(Reference *list, Reference **dlist, int fnum, int bestMatchFlag) {
    mock(list, dlist, fnum, bestMatchFlag);
}

void olSetCallerPosition(Position *pos) {
    mock(pos);
}

Completion *olCompletionListPrepend(char *name, char *fullText, char *vclass, int jindent, Symbol *s,
                                        ReferencesItem *ri, Reference *dfpos, int symType, int vFunClass,
                                        OlcxReferences *stack) {
    return (Completion *) mock(name, fullText, vclass, jindent, s, ri, dfpos, symType, vFunClass, stack);
}

SymbolsMenu *olCreateNewMenuItem(ReferencesItem *sym, int vApplClass, int vFunCl, Position *defpos,
                                     int defusage, int selected, int visible, unsigned ooBits, int olusage,
                                     int vlevel) {
    return (SymbolsMenu *) mock(sym, vApplClass, vFunCl, defpos, defusage, selected, visible, ooBits, olusage, vlevel);
}

SymbolsMenu *olAddBrowsedSymbol(ReferencesItem *sym, SymbolsMenu **list, int selected, int visible,
                                    unsigned ooBits, int olusage, int vlevel, Position *defpos, int defusage) {
    return (SymbolsMenu *) mock(sym, list, selected, visible, ooBits, olusage, vlevel, defpos, defusage);
}

void renameCollationSymbols(SymbolsMenu *sss) {
    mock(sss);
}

void olCompletionListReverse(void) {
    mock();
}

Reference **addToRefList(Reference **list, Usage usage_arg, Position pos_arg) {
    Position *pos = &pos_arg;
    Usage *usage = &usage_arg;
    return (Reference **) mock(list, usage, pos);
}

int itIsSymbolToPushOlReferences(ReferencesItem *p, OlcxReferences *rstack, SymbolsMenu **rss,
                               int checkSelFlag) {
    return (int) mock(p, rstack, rss, checkSelFlag);
}

void olcxAddReferenceToSymbolsMenu(SymbolsMenu *cms, Reference *rr, int bestFitFlag) {
    mock(cms, rr, bestFitFlag);
}

void putOnLineLoadedReferences(ReferencesItem *p) {
    mock(p);
}

void genOnLineReferences(OlcxReferences *rstack, SymbolsMenu *cms) {
    mock(rstack, cms);
}

SymbolsMenu *createSelectionMenu(ReferencesItem *dd) {
    return (SymbolsMenu *) mock(dd);
}

void mapCreateSelectionMenu(ReferencesItem *dd) {
    mock(dd);
}

void olcxFreeOldCompletionItems(OlcxReferencesStack *stack) {
    mock(stack);
}

void olcxInit(void) {
    mock();
}

Reference *getDefinitionRef(Reference *rr) {
    return (Reference *) mock(rr);
}

bool safetyCheck2ShouldWarn(void) {
    return (bool) mock();
}

void olCreateSelectionMenu(int command) {
    mock(command);
}

void pushEmptySession(OlcxReferencesStack *stack) {
    mock(stack);
}

void olcxPrintSelectionMenu(SymbolsMenu *sss) {
    mock(sss);
}

bool ooBitsGreaterOrEqual(unsigned oo1, unsigned oo2) {
    return (bool) mock(oo1, oo2);
}

void olcxPrintClassTree(SymbolsMenu *sss) {
    mock(sss);
}

void olcxReferencesDiff(Reference **anr1, Reference **aor2, Reference **diff) {
    mock(anr1, aor2, diff);
}

bool olcxShowSelectionMenu(void) {
    return (int) mock();
}

int getClassNumFromClassLinkName(char *name, int defaultResult) {
    return (int) mock(name, defaultResult);
}

void getLineAndColumnCursorPositionFromCommandLineOptions(int *lineP, int *colP) {
    mock(lineP, colP);
}

void changeClassReferencesUsages(char *linkName, int category, int fnum, Symbol *cclass) {
    mock(linkName, category, fnum, cclass);
}

bool isStrictlyEnclosingClass(int enclosedClass, int enclosingClass) {
    return (bool) mock(enclosedClass, enclosingClass);
}

void changeMethodReferencesUsages(char *linkName, int category, int fnum, Symbol *cclass) {
    mock(linkName, category, fnum, cclass);
}

void olcxPushSpecialCheckMenuSym(char *symname) {
    mock(symname);
}

bool refOccursInRefs(Reference *r, Reference *list) {
    return (bool) mock(r, list);
}

void olcxCheck1CxFileReference(ReferencesItem *ss, Reference *r) {
    mock(ss, r);
}

void olcxPushSpecial(char *fieldName, int command) {
    mock(fieldName, command);
}

bool isPushAllMethodsValidRefItem(ReferencesItem *ri) {
    return (bool) mock(ri);
}

bool symbolsCorrespondWrtMoving(SymbolsMenu *osym, SymbolsMenu *nsym, ServerOperation operation) {
    return (bool) mock(osym, nsym, operation);
}

void olcxPrintPushingAction(int opt, int afterMenu) {
    mock(opt, afterMenu);
}

void olPushAllReferencesInBetween(int minMemi, int maxMemi) {
    mock(minMemi, maxMemi);
}

Symbol *getMoveTargetClass(void) {
    return (Symbol *) mock();
}

int javaGetSuperClassNumFromClassNum(int cn) {
    return (int) mock(cn);
}

bool javaIsSuperClass(int superclas, int clas) {
    return (bool) mock(superclas, clas);
}

void pushLocalUnusedSymbolsAction(void) {
    mock();
}

void answerEditAction(void) {
    mock();
}

SymbolsMenu *olcxFreeSymbolMenuItem(SymbolsMenu *ll) {
    return (SymbolsMenu *) mock(ll);
}

void olcxFreeResolutionMenu(SymbolsMenu *sym) {
    mock(sym);
}

int refCharCode(int usage) {
    return (int) mock(usage);
}

void generateReferences(void) {
    mock();
}
