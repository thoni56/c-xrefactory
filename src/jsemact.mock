/* -*- c -*-*/
#include "jsemact.h"
#include <cgreen/mocks.h>

JavaStat *javaStat;
JavaStat s_initJavaStat;

void fill_nestedSpec(S_nestedSpec *nestedSpec, struct symbol *cl,
                     char membFlag, short unsigned  accFlags) {
    nestedSpec->cl = cl;
    nestedSpec->membFlag = membFlag;
    nestedSpec->accFlags = accFlags;
}

void fillJavaStat(JavaStat *javaStat, IdList *className, TypeModifier *thisType, Symbol *thisClass,
                  int currentNestedIndex, char *currentPackage, char *unnamedPackagePath,
                  char *namedPackagePath, SymbolTable *locals, IdList *lastParsedName,
                  unsigned methodModifiers, CurrentlyParsedClassInfo parsingPositions, int classFileIndex,
                  JavaStat *next) {
    javaStat->className = className;
    javaStat->thisType = thisType;
    javaStat->thisClass = thisClass;
    javaStat->currentNestedIndex = currentNestedIndex;
    javaStat->currentPackage = currentPackage;
    javaStat->unnamedPackagePath = unnamedPackagePath;
    javaStat->namedPackagePath = namedPackagePath;
    javaStat->locals = locals;
    javaStat->lastParsedName = lastParsedName;
    javaStat->methodModifiers = methodModifiers;
    javaStat->cp = parsingPositions;
    javaStat->classFileNumber = classFileIndex;
    javaStat->next = next;
}

void javaCheckForPrimaryStart(Position *cpos, Position *pp) {
    mock(cpos, pp);
}

void javaCheckForStaticPrefixInNameList(IdList *name, Position *pp) {
    mock(name, pp);
}

Position *javaGetNameStartingPosition(IdList *name) {
    return (Position *) mock(name);
}

char *javaCreateComposedName(char *prefix, IdList *className, int classNameSeparator, char *name,
                             char *resultBuffer, int resultBufferSize) {
    return (char *) mock(prefix, className, classNameSeparator, name, resultBuffer, resultBufferSize);
}

Result findTopLevelName(char *name, S_recFindStr *resRfs, Symbol **resMemb, int classif) {
    return (Result) mock(name, resRfs, resMemb, classif);
}

int javaClassifySingleAmbigNameToTypeOrPack(IdList *name, Symbol **str, IncludeCxrefs cxrefFlag) {
    return (int) mock(name, str, cxrefFlag);
}

void javaAddImportConstructionReference(Position *importPos, Position *pos, int usage) {
    mock(importPos, pos, usage);
}

Type javaClassifyAmbiguousName(IdList *name, S_recFindStr *rfs, Symbol **str, TypeModifier **expr,
                               Reference **oref, Reference **rdtoref, int allowUselesFqtRefs,
                               int classif, int usage) {
    return (Type)mock(name, rfs, str, expr, oref, rdtoref, allowUselesFqtRefs, classif, usage);
}

Reference *javaClassifyToTypeOrPackageName(IdList *tname, int usage, Symbol **str, int allowUselesFqtRefs) {
    return (Reference *) mock(tname, usage, str, allowUselesFqtRefs);
}

void javaClassifyToPackageName(IdList *id) {
    mock(id);
}

void javaClassifyToPackageNameAndAddRefs(IdList *id, int usage) {
    mock(id, usage);
}

char *javaImportSymbolName_st(int file, int line, int coll) {
    return (char *) mock(file, line, coll);
}

int javaTypeToString(TypeModifier *type, char *pp, int ppSize) {
    return (int) mock(type, pp, ppSize);
}

int javaIsYetInTheClass(Symbol *clas, char *lname, Symbol **eq) {
    return (int) mock(clas, lname, eq);
}

int javaSetFunctionLinkName(Symbol *clas, Symbol *decl, enum memoryClass mem) {
    return (int) mock(clas, decl, mem);
}

Symbol *javaGetFieldClass(char *fieldLinkName, char **fieldAdr) {
    return (Symbol *) mock(fieldLinkName, fieldAdr);
}

bool javaTypeFileExist(IdList *name) {
    return (int) mock(name);
}

Symbol *javaTypeSymbolDefinition(IdList *tname, int accessFlags, int addType) {
    return (Symbol *) mock(tname, accessFlags, addType);
}

Symbol *javaTypeSymbolUsage(IdList *tname, int accessFlags) {
    return (Symbol *) mock(tname, accessFlags);
}

void javaReadSymbolFromSourceFileEnd(void) {
    mock();
}

void javaReadSymbolFromSourceFileInit(int sourceFileNum, JslTypeTab *typeTab) {
    mock(sourceFileNum, typeTab);
}

void javaReadSymbolsFromSourceFileNoFreeing(char *fname, char *asfname) {
    mock(fname, asfname);
}

void javaReadSymbolsFromSourceFile(char *fname) {
    mock(fname);
}

int javaLinkNameIsAnnonymousClass(char *linkname) {
    return (int) mock(linkname);
}

int javaLinkNameIsANestedClass(char *cname) {
    return (int) mock(cname);
}

Reference *addUselessFQTReference(int classIndex, Position *pos) {
    return (Reference *) mock(classIndex, pos);
}

Reference *addUnimportedTypeLongReference(int classIndex, Position *pos) {
    return (Reference *) mock(classIndex, pos);
}

void addThisCxReferences(int classIndex, Position *pos) {
    mock(classIndex, pos);
}

void javaLoadClassSymbolsFromFile(Symbol *memb) {
    mock(memb);
}

void addMethodCxReferences(unsigned modif, Symbol *method, Symbol *clas) {
    mock(modif, method, clas);
}

void javaAddMethodParametersToSymTable(Symbol *method) {
    mock(method);
}

Symbol *javaFQTypeSymbolDefinition(char *name, char *fqName) {
    return (Symbol *) mock(name, fqName);
}

TypeModifier *javaNewAfterName(IdList *name, Id *id, IdList *idl) {
    return (TypeModifier *) mock(name, id, idl);
}

TypeModifier *javaMethodInvocationT(TypeModifier *tt, Id *name, S_typeModifierList *args) {
    return (TypeModifier *) mock(tt, name, args);
}

TypeModifier *javaMethodInvocationS(Id *super, Id *name, S_typeModifierList *args) {
    return (TypeModifier *) mock(super, name, args);
}

int javaClassIsInCurrentPackage(Symbol *cl) {
    return (int) mock(cl);
}

int javaFqtNamesAreFromTheSamePackage(char *classFqName, char *fqname2) {
    return (int) mock(classFqName, fqname2);
}
