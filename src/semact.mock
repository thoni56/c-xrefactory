/* -*- c -*-*/
#include "semact.h"
#include <cgreen/mocks.h>

void fillRecFindStr(S_recFindStr *recFindStr, Symbol *baseClass, Symbol *currentClass, Symbol *nextRecord,
                    unsigned recsClassCounter) {
    recFindStr->baseClass            = baseClass;
    recFindStr->currentClass         = currentClass;
    recFindStr->nextRecord           = nextRecord;
    recFindStr->recsClassCounter     = recsClassCounter;
    recFindStr->superClassesCount    = 0;
    recFindStr->anonymousUnionsCount = 0;
}

void initSymStructSpec(S_symStructSpec *symStruct, Symbol *records) {
    mock(symStruct, records);
}

void unpackPointers(Symbol *pp) {
    mock(pp);
}

bool displayingErrorMessages(void) {
    return (int) mock();
}

void noSuchFieldError(char *rec) {
    mock(rec);
}

void deleteSymDef(void *p) {
    mock(p);
}

void addSymbolToFrame(SymbolTable *tab, Symbol *pp) {
    mock(pp, tab);
}

void recFindPush(Symbol *sym, S_recFindStr *rfs) {
    mock(sym, rfs);
}

S_recFindStr *iniFind(Symbol *s, S_recFindStr *rfs) {
    return (S_recFindStr *) mock(s, rfs);
}

bool javaOuterClassAccessible(Symbol *cl) {
    return (int) mock(cl);
}

Result findStrRecordSym(Symbol **res, S_recFindStr *ss, char *recname,
                        AccessibilityCheckYesNo accessibilityCheck, VisibilityCheckYesNo visibilityCheck) {
    return (Result) mock(ss, recname, res, accessibilityCheck, visibilityCheck);
}

Symbol *addNewSymbolDefinition(SymbolTable *table, char *fileName, Symbol *symbol, Storage storage, UsageKind usage) {
    return (Symbol *) mock(symbol, fileName, storage, table, usage);
}

Symbol *addNewDeclaration(SymbolTable *table, Symbol *baseType, Symbol *declaration, IdList *idList, Storage storage) {
    return (Symbol *) mock(baseType, declaration, idList, storage, table);
}

int styyerror(char *s) {
    return (int) mock(s);
}

int styyErrorRecovery(void) {
    return (int) mock();
}

void setToNull(void *p) {
    mock(p);
}

Symbol *typeSpecifier1(unsigned t) {
    return (Symbol *) mock(t);
}

void declTypeSpecifier1(Symbol *d, unsigned t) {
    mock(d, t);
}

Symbol *typeSpecifier2(TypeModifier *t) {
    return (Symbol *) mock(t);
}

void declTypeSpecifier2(Symbol *d, TypeModifier *t) {
    mock(d, t);
}

TypeModifier *addComposedTypeToSymbol(Symbol *symbol, Type type) {
    return (TypeModifier *)mock(symbol, type);
}

TypeModifier *appendComposedType(TypeModifier **d, unsigned t) {
    return (TypeModifier *) mock(d, t);
}

void completeDeclarator(Symbol *t, Symbol *d) {
    mock(t, d);
}

void addFunctionParameterToSymTable(SymbolTable *table, Symbol *function, Symbol *parameter, int position) {
    mock(function, parameter, position, table);
}

SymbolList *createDefinitionList(Symbol *symbol) {
    return (SymbolList *) mock(symbol);
}

Symbol *createSimpleDefinition(unsigned storage, unsigned t, Id *id) {
    return (Symbol *) mock(storage, t, id);
}

int findStrRecord(Symbol *symbol, char *recname, Symbol **res) {
    return (int) mock(symbol, recname, res);
}

Reference *findStrRecordFromSymbol(Symbol *str, Id *record, Symbol **res, Id *super) {
    return (Reference *) mock(str, record, res, super);
}

Reference *findStructureFieldFromType(TypeModifier *structure, Id *field, Symbol **resultingSymbol, int javaClassifier) {
    return (Reference *) mock(structure, field, resultingSymbol, javaClassifier);
}

Result mergeArguments(Symbol *id, Symbol *ty) {
    return (Result) mock(id, ty);
}

TypeModifier *simpleStrUnionSpecifier(Id *typeName, Id *id, UsageKind usage) {
    return (TypeModifier *) mock(typeName, id, usage);
}

TypeModifier *createNewAnonymousStructOrUnion(Id *typeName) {
    return (TypeModifier *) mock(typeName);
}

void specializeStrUnionDef(Symbol *sd, Symbol *rec) {
    mock(sd, rec);
}

TypeModifier *simpleEnumSpecifier(Id *id, UsageKind usage) {
    return (TypeModifier *) mock(id, usage);
}

void setGlobalFileDepNames(char *iname, Symbol *pp, int memory) {
    char **pp_name = &pp->name;
    mock(iname, pp, pp_name, memory);
}

TypeModifier *createNewAnonymousEnum(SymbolList *enums) {
    return (TypeModifier *) mock(enums);
}

void appendPositionToList(PositionList **list, Position *pos) {
    mock(list, pos);
}

void setParamPositionForFunctionWithoutParams(Position *lpar) {
    mock(lpar);
}

void setParamPositionForParameter0(Position *lpar) {
    mock(lpar);
}

void setParamPositionForParameterBeyondRange(Position *rpar) {
    mock(rpar);
}

Symbol *createEmptyField(void) {
    return (Symbol *) mock();
}

void handleDeclaratorParamPositions(Symbol *decl, Position *lpar, PositionList *commas, Position *rpar, bool hasParam, bool isVoid) {
    mock(decl, lpar, commas, rpar, hasParam, isVoid);
}

void handleInvocationParamPositions(Reference *ref, Position *lpar, PositionList *commas, Position *rpar, bool hasParam) {
    mock(ref, lpar, commas, rpar, hasParam);
}

void setLocalVariableLinkName(struct symbol *p) {
    mock(p);
}

void labelReference(Id *id, UsageKind usage) {
    mock(id, usage);
}

void generateInternalLabelReference(int counter, int usage) {
    mock(counter, usage);
}
